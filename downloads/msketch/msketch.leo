<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20191210220017.1"><vh>開發註記</vh>
<v t="leo.20191210220042.1"><vh>有關 jquery.min.js 位置</vh></v>
</v>
<v t="leo.20191210192811.1"><vh>@clean http-server.py</vh></v>
<v t="leo.20191210163956.1"><vh>@clean index.html</vh>
<v t="leo.20191210194051.1"><vh>&lt;&lt; head &gt;&gt;</vh></v>
<v t="leo.20191210195941.1"><vh>&lt;&lt; position_panel_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200043.1"><vh>&lt;&lt; apply_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200159.1"><vh>&lt;&lt; motor_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200305.1"><vh>&lt;&lt; pattern_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200440.1"><vh>&lt;&lt; analysis_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200603.1"><vh>&lt;&lt; tool_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200857.1"><vh>&lt;&lt; linkage_generation_javascript &gt;&gt;</vh></v>
<v t="leo.20191210200953.1"><vh>&lt;&lt; link_3d_javascript &gt;&gt;</vh></v>
<v t="leo.20191210201039.1"><vh>&lt;&lt; load_panel_javascript &gt;&gt;</vh></v>
<v t="leo.20191210201136.1"><vh>&lt;&lt; setting_javascript &gt;&gt;</vh></v>
<v t="leo.20191210201840.1"><vh>&lt;&lt; panel_close_javascript &gt;&gt;</vh></v>
<v t="leo.20191210201926.1"><vh>&lt;&lt; show_message_javascript &gt;&gt;</vh></v>
<v t="leo.20191210194620.1"><vh>&lt;&lt; dialog_javascript &gt;&gt;</vh></v>
<v t="leo.20191210194333.1"><vh>&lt;&lt; included_javascript &gt;&gt;</vh></v>
</v>
<v t="leo.20191210202921.1"><vh>@path public/js/</vh>
<v t="leo.20191210204346.1"><vh>@clean main.js</vh>
<v t="leo.20191210204410.1"><vh>function animate</vh></v>
<v t="leo.20191210204410.2"><vh>function render</vh></v>
<v t="leo.20191210204410.3"><vh>function actuate</vh></v>
<v t="leo.20191210204410.4"><vh>function initMechCalc</vh></v>
<v t="leo.20191210204410.5"><vh>function addAssemblyGroup</vh></v>
<v t="leo.20191210204410.6"><vh>function removeAssemblyGroup</vh></v>
<v t="leo.20191210204410.7"><vh>function selectAssembly</vh></v>
<v t="leo.20191210204410.8"><vh>function findCurrentAssemblyNum</vh></v>
</v>
<v t="leo.20191210202937.1"><vh>@path common</vh>
<v t="leo.20191210202950.1"><vh>@clean subs.js</vh>
<v t="leo.20191210203004.1"><vh>function Point2D</vh></v>
<v t="leo.20191210203004.2"><vh>Point2D.prototype.getX = function</vh></v>
<v t="leo.20191210203004.3"><vh>Point2D.prototype.getY = function</vh></v>
<v t="leo.20191210203004.4"><vh>Point2D.prototype.setLocation = function</vh></v>
<v t="leo.20191210203004.5"><vh>Point2D.prototype.distance = function</vh></v>
<v t="leo.20191210203004.6"><vh>function ArrayList</vh>
<v t="leo.20191210203004.7"><vh>this.add = function</vh></v>
<v t="leo.20191210203004.8"><vh>this.addIn = function</vh></v>
<v t="leo.20191210203004.9"><vh>this.length = function</vh></v>
<v t="leo.20191210203004.10"><vh>this.get = function</vh></v>
<v t="leo.20191210203004.11"><vh>this.addAll = function</vh></v>
<v t="leo.20191210203004.12"><vh>this.remove = function</vh></v>
<v t="leo.20191210203004.13"><vh>this.removeOf = function</vh></v>
<v t="leo.20191210203004.14"><vh>this.clear = function</vh></v>
<v t="leo.20191210203004.15"><vh>this.isEmpty = function</vh></v>
<v t="leo.20191210203004.16"><vh>this.contains = function</vh></v>
<v t="leo.20191210203004.17"><vh>this.containsAll = function</vh></v>
<v t="leo.20191210203004.18"><vh>this.set = function</vh></v>
<v t="leo.20191210203004.19"><vh>this.indexOf = function</vh></v>
</v>
<v t="leo.20191210203004.20"><vh>MMath.distToLine = function</vh></v>
<v t="leo.20191210203004.21"><vh>MMath.distToLineSquared = function</vh></v>
<v t="leo.20191210203004.22"><vh>MMath.distToSegment = function</vh></v>
<v t="leo.20191210203004.23"><vh>MMath.distToSegmentSquared = function</vh></v>
<v t="leo.20191210203004.24"><vh>MMath.getNearestTfromALine = function</vh></v>
<v t="leo.20191210203004.25"><vh>MMath.dist2 = function</vh></v>
<v t="leo.20191210203004.26"><vh>MMath.dist = function</vh></v>
<v t="leo.20191210203004.27"><vh>Math.radians = function</vh></v>
<v t="leo.20191210203004.28"><vh>Math.degrees = function</vh></v>
<v t="leo.20191210203004.29"><vh>Math.map = function</vh></v>
<v t="leo.20191210203004.30"><vh>function getTimeStamp</vh></v>
<v t="leo.20191210203004.31"><vh>function leadingZeros</vh></v>
</v>
</v>
<v t="leo.20191210203049.1"><vh>@path core/constraints</vh>
<v t="leo.20191210203119.1"><vh>@clean Constraint.js</vh>
<v t="leo.20191210203154.1"><vh>function Constraint</vh></v>
<v t="leo.20191210203154.2"><vh>Constraint.prototype.getAllLink = function</vh></v>
<v t="leo.20191210203154.3"><vh>Constraint.prototype.getLink = function</vh></v>
<v t="leo.20191210203154.4"><vh>Constraint.prototype.setLink = function</vh></v>
<v t="leo.20191210203154.5"><vh>Constraint.prototype.getDOF = function</vh></v>
</v>
<v t="leo.20191210203240.1"><vh>@clean AngularConstraint.js</vh>
<v t="leo.20191210203247.1"><vh>function AngularConstraint</vh></v>
<v t="leo.20191210203247.2"><vh>AngularConstraint.prototype.setAngle = function</vh></v>
<v t="leo.20191210203247.3"><vh>AngularConstraint.prototype.getAngle = function</vh></v>
</v>
<v t="leo.20191210203303.1"><vh>@clean CoaxialConstraint.js</vh>
<v t="leo.20191210203308.1"><vh>function CoaxialConstraint</vh></v>
<v t="leo.20191210203308.2"><vh>CoaxialConstraint.prototype.toString = function</vh></v>
<v t="leo.20191210203308.3"><vh>CoaxialConstraint.prototype.addPoint = function</vh></v>
<v t="leo.20191210203308.4"><vh>CoaxialConstraint.prototype.removePoint = function</vh></v>
<v t="leo.20191210203308.5"><vh>CoaxialConstraint.prototype.getAllPoint = function</vh></v>
<v t="leo.20191210203308.6"><vh>CoaxialConstraint.prototype.getPoint = function</vh></v>
</v>
<v t="leo.20191210203325.1"><vh>@clean SliderConstraint.js</vh>
<v t="leo.20191210203332.1"><vh>function SliderConstraint</vh></v>
<v t="leo.20191210203332.2"><vh>SliderConstraint.prototype.toString = function</vh></v>
<v t="leo.20191210203332.3"><vh>SliderConstraint.prototype.getPoint1 = function</vh></v>
<v t="leo.20191210203332.4"><vh>SliderConstraint.prototype.setPoint1 = function</vh></v>
<v t="leo.20191210203332.5"><vh>SliderConstraint.prototype.getPoint2 = function</vh></v>
<v t="leo.20191210203332.6"><vh>SliderConstraint.prototype.setPoint2 = function</vh></v>
<v t="leo.20191210203332.7"><vh>SliderConstraint.prototype.getPoints = function</vh></v>
<v t="leo.20191210203332.8"><vh>SliderConstraint.prototype.setPoints = function</vh></v>
<v t="leo.20191210203332.9"><vh>SliderConstraint.prototype.getAngle = function</vh></v>
</v>
</v>
<v t="leo.20191210203414.1"><vh>@path core/assembly</vh>
<v t="leo.20191210203432.1"><vh>@clean Assembly.js</vh>
<v t="leo.20191210203441.1"><vh>function Assembly</vh></v>
<v t="leo.20191210203441.2"><vh>Assembly.prototype.getSpace = function</vh></v>
<v t="leo.20191210203441.3"><vh>Assembly.prototype.addSpace = function</vh></v>
<v t="leo.20191210203441.4"><vh>Assembly.prototype.getAllElement = function</vh></v>
<v t="leo.20191210203441.5"><vh>Assembly.prototype.addElement = function</vh></v>
<v t="leo.20191210203441.6"><vh>Assembly.prototype.removeElement = function</vh></v>
<v t="leo.20191210203441.7"><vh>Assembly.prototype.getAllConstraint = function</vh></v>
<v t="leo.20191210203441.8"><vh>Assembly.prototype.addConstraint = function</vh></v>
<v t="leo.20191210203441.9"><vh>Assembly.prototype.removeConstraint = function</vh></v>
<v t="leo.20191210203441.10"><vh>Assembly.prototype.removePointInConstraint = function</vh></v>
<v t="leo.20191210203441.11"><vh>Assembly.prototype.appendCoaxialConstraint = function</vh></v>
<v t="leo.20191210203441.12"><vh>Assembly.prototype.checkCoaxialConstraint = function</vh></v>
<v t="leo.20191210203441.13"><vh>Assembly.prototype.printConstraints = function</vh></v>
<v t="leo.20191210203441.14"><vh>Assembly.prototype.getAllActuator = function</vh></v>
<v t="leo.20191210203441.15"><vh>Assembly.prototype.addActuator = function</vh></v>
<v t="leo.20191210203441.16"><vh>Assembly.prototype.removeActuator = function</vh></v>
<v t="leo.20191210203441.17"><vh>Assembly.prototype.removeActuatorInConstraint = function</vh></v>
<v t="leo.20191210203441.18"><vh>Assembly.prototype.emptyUnspecified = function</vh></v>
<v t="leo.20191210203441.19"><vh>Assembly.prototype.getUnspecified = function</vh></v>
<v t="leo.20191210203441.20"><vh>Assembly.prototype.addUnspecified = function</vh></v>
<v t="leo.20191210203441.21"><vh>Assembly.prototype.getDOF = function</vh></v>
<v t="leo.20191210203441.22"><vh>Assembly.prototype.getGlobalPosition = function</vh></v>
<v t="leo.20191210203441.23"><vh>Assembly.prototype.getBelongedLink = function</vh></v>
<v t="leo.20191210203441.24"><vh>Assembly.prototype.savePositions = function</vh></v>
<v t="leo.20191210203441.25"><vh>Assembly.prototype.restorePositions = function</vh></v>
<v t="leo.20191210203441.26"><vh>Assembly.prototype.getLinkByName = function</vh></v>
<v t="leo.20191210203441.27"><vh>Assembly.prototype.getConstraintByName = function</vh></v>
</v>
<v t="leo.20191210203456.1"><vh>@clean LinkageGroup.js</vh>
<v t="leo.20191210203501.1"><vh>function LinkGroup</vh></v>
<v t="leo.20191210203501.2"><vh>LinkGroup.prototype.setRelativePosition = function</vh></v>
<v t="leo.20191210203501.3"><vh>LinkGroup.prototype.getRelativePosition = function</vh></v>
<v t="leo.20191210203501.4"><vh>LinkGroup.prototype.setRelativeAngle = function</vh></v>
<v t="leo.20191210203501.5"><vh>LinkGroup.prototype.getRelativeAngle = function</vh></v>
<v t="leo.20191210203501.6"><vh>LinkGroup.prototype.getLinkList = function</vh></v>
<v t="leo.20191210203501.7"><vh>LinkGroup.prototype.addLink = function</vh></v>
<v t="leo.20191210203501.8"><vh>LinkGroup.prototype.removeLink = function</vh></v>
<v t="leo.20191210203501.9"><vh>LinkGroup.prototype.findOutgoingCoaxialConstraint = function</vh></v>
<v t="leo.20191210203501.10"><vh>LinkGroup.prototype.findOutgoingSliderConstraint = function</vh></v>
<v t="leo.20191210203501.11"><vh>LinkGroup.prototype.findOutgoingAngularConstraint = function</vh></v>
<v t="leo.20191210203501.12"><vh>LinkGroup.prototype.getLocalPosition = function</vh></v>
<v t="leo.20191210203501.13"><vh>LinkGroup.prototype.getLocalAngle = function</vh></v>
<v t="leo.20191210203501.14"><vh>LinkGroup.prototype.merge = function</vh></v>
<v t="leo.20191210203501.15"><vh>LinkGroup.prototype.backToZero = function</vh></v>
<v t="leo.20191210203501.16"><vh>LinkGroup.prototype.zeroToPoint = function</vh></v>
<v t="leo.20191210203501.17"><vh>LinkGroup.prototype.isBaseGroup = function</vh></v>
<v t="leo.20191210203501.18"><vh>function CCI</vh></v>
<v t="leo.20191210203501.19"><vh>CCI.prototype.inverseCCI = function</vh></v>
<v t="leo.20191210203501.20"><vh>function ACI</vh></v>
<v t="leo.20191210203501.21"><vh>function LinkTriangle</vh></v>
<v t="leo.20191210203501.22"><vh>function LinkTriangle2</vh></v>
</v>
<v t="leo.20191210203515.1"><vh>@clean MechanismCalculator.js</vh>
<v t="leo.20191210203522.1"><vh>function MechanismCalculator</vh></v>
<v t="leo.20191210203522.2"><vh>MechanismCalculator.prototype.onStart = function</vh></v>
<v t="leo.20191210203522.3"><vh>MechanismCalculator.prototype.onEnd = function</vh></v>
<v t="leo.20191210203522.4"><vh>MechanismCalculator.prototype.calculateAssembly = function</vh></v>
<v t="leo.20191210203522.5"><vh>MechanismCalculator.prototype.getTriangleCost = function</vh></v>
<v t="leo.20191210203522.6"><vh>MechanismCalculator.prototype.buildLinkGroup = function</vh></v>
<v t="leo.20191210203522.7"><vh>MechanismCalculator.prototype.mapMu = function</vh></v>
<v t="leo.20191210203522.8"><vh>MechanismCalculator.prototype.getSliderMu = function</vh></v>
<v t="leo.20191210203522.9"><vh>MechanismCalculator.prototype.search_AC_Constraint = function</vh></v>
<v t="leo.20191210203522.10"><vh>MechanismCalculator.prototype.findXXXLinkTriangle = function</vh></v>
<v t="leo.20191210203522.11"><vh>MechanismCalculator.prototype.findXSXLinkTriangle = function</vh></v>
<v t="leo.20191210203522.12"><vh>MechanismCalculator.prototype.findGroupByLink = function</vh></v>
<v t="leo.20191210203522.13"><vh>MechanismCalculator.prototype.getPtoP = function</vh></v>
</v>
</v>
<v t="leo.20191210203553.1"><vh>@path core/elements</vh>
<v t="leo.20191210203617.1"><vh>@clean MechElement.js</vh>
<v t="leo.20191210203632.1"><vh>function MechElement</vh></v>
<v t="leo.20191210203632.2"><vh>MechElement.prototype.getOriginPoint = function</vh></v>
<v t="leo.20191210203632.3"><vh>MechElement.prototype.setOriginPoint = function</vh></v>
<v t="leo.20191210203632.4"><vh>MechElement.prototype.getName = function</vh></v>
<v t="leo.20191210203632.5"><vh>MechElement.prototype.setName = function</vh></v>
<v t="leo.20191210203632.6"><vh>MechElement.prototype.getDOF = function</vh></v>
<v t="leo.20191210203632.7"><vh>MechElement.prototype.savePosition = function</vh></v>
<v t="leo.20191210203632.8"><vh>MechElement.prototype.restorePosition = function</vh></v>
</v>
<v t="leo.20191210203646.1"><vh>@clean Link.js</vh>
<v t="leo.20191210203652.1"><vh>function Link</vh></v>
<v t="leo.20191210203652.2"><vh>Link.prototype.toString = function</vh></v>
<v t="leo.20191210203652.3"><vh>Link.prototype.getAngle = function</vh></v>
<v t="leo.20191210203652.4"><vh>Link.prototype.setAngle = function</vh></v>
<v t="leo.20191210203652.5"><vh>Link.prototype.getPointList = function</vh></v>
<v t="leo.20191210203652.6"><vh>Link.prototype.addGlobalPoint = function</vh></v>
<v t="leo.20191210203652.7"><vh>Link.prototype.addLocalPoint = function</vh></v>
<v t="leo.20191210203652.8"><vh>Link.prototype.removePoint = function</vh></v>
<v t="leo.20191210203652.9"><vh>Link.prototype.getVertex = function</vh></v>
<v t="leo.20191210203652.10"><vh>Link.prototype.getGlobalPosition = function</vh></v>
<v t="leo.20191210203652.11"><vh>Link.prototype.getLocalPosition = function</vh></v>
<v t="leo.20191210203652.12"><vh>Link.prototype.getGlobalVertex = function</vh></v>
<v t="leo.20191210203652.13"><vh>Link.prototype.savePosition = function</vh></v>
<v t="leo.20191210203652.14"><vh>Link.prototype.restorePosition = function</vh></v>
<v t="leo.20191210203652.15"><vh>Link.prototype.init = function</vh></v>
<v t="leo.20191210203652.16"><vh>Link.prototype.redefineVertex = function</vh></v>
<v t="leo.20191210203652.17"><vh>Link.prototype.getGlobalRoundedVertex = function</vh></v>
<v t="leo.20191210203652.18"><vh>Link.prototype.getGlobalPositionRotated = function</vh></v>
<v t="leo.20191210203652.19"><vh>Link.prototype.getLength = function</vh></v>
<v t="leo.20191210203652.20"><vh>Link.prototype.getLengths = function</vh></v>
<v t="leo.20191210203652.21"><vh>Link.prototype.distance = function</vh></v>
<v t="leo.20191210203652.22"><vh>Link.prototype.pushVertex = function</vh></v>
<v t="leo.20191210203652.23"><vh>Link.prototype.vertexIsChanged = function</vh></v>
<v t="leo.20191210203652.24"><vh>Link.prototype.pushPoint = function</vh></v>
<v t="leo.20191210203652.25"><vh>Link.prototype.pointIsChanged = function</vh></v>
<v t="leo.20191210203652.26"><vh>Link.prototype.setSlider = function</vh></v>
</v>
<v t="leo.20191210203712.1"><vh>@clean Space.js</vh>
<v t="leo.20191210203717.1"><vh>function Space</vh></v>
<v t="leo.20191210203717.2"><vh>Space.prototype.redefineVertex = function</vh></v>
</v>
<v t="leo.20191210203736.1"><vh>@clean JointActuator.js</vh>
<v t="leo.20191210203742.1"><vh>function JointActuator</vh></v>
<v t="leo.20191210203742.2"><vh>JointActuator.prototype.getName = function</vh></v>
<v t="leo.20191210203742.3"><vh>JointActuator.prototype.getValue = function</vh></v>
<v t="leo.20191210203742.4"><vh>JointActuator.prototype.setValue = function</vh></v>
<v t="leo.20191210203742.5"><vh>JointActuator.prototype.setCoaxialConstraint = function</vh></v>
<v t="leo.20191210203742.6"><vh>JointActuator.prototype.getCoaxialConstraint = function</vh></v>
<v t="leo.20191210203742.7"><vh>JointActuator.prototype.getBaseLink = function</vh></v>
<v t="leo.20191210203742.8"><vh>JointActuator.prototype.getTargetLink = function</vh></v>
<v t="leo.20191210203742.9"><vh>JointActuator.prototype.attach = function</vh></v>
<v t="leo.20191210203742.10"><vh>JointActuator.prototype.dettach = function</vh></v>
<v t="leo.20191210203742.11"><vh>JointActuator.prototype.savePosition = function</vh></v>
<v t="leo.20191210203742.12"><vh>JointActuator.prototype.restorePosition = function</vh></v>
<v t="leo.20191210203742.13"><vh>JointActuator.prototype.setPhase = function</vh></v>
<v t="leo.20191210203742.14"><vh>JointActuator.prototype.getPhase = function</vh></v>
<v t="leo.20191210203742.15"><vh>JointActuator.prototype.setSpeedMultiply = function</vh></v>
<v t="leo.20191210203742.16"><vh>JointActuator.prototype.getSpeedMultiply = function</vh></v>
<v t="leo.20191210203742.17"><vh>JointActuator.prototype.setReverse = function</vh></v>
<v t="leo.20191210203742.18"><vh>JointActuator.prototype.getReverse = function</vh></v>
<v t="leo.20191210203742.19"><vh>JointActuator.prototype.setStartAngle = function</vh></v>
<v t="leo.20191210203742.20"><vh>JointActuator.prototype.getStartAngle = function</vh></v>
<v t="leo.20191210203742.21"><vh>JointActuator.prototype.setEndAngle = function</vh></v>
<v t="leo.20191210203742.22"><vh>JointActuator.prototype.getEndAngle = function</vh></v>
<v t="leo.20191210203742.23"><vh>JointActuator.prototype.setInitAngle = function</vh></v>
<v t="leo.20191210203742.24"><vh>JointActuator.prototype.setServo = function</vh></v>
<v t="leo.20191210203742.25"><vh>JointActuator.prototype.setDC = function</vh></v>
</v>
<v t="leo.20191210203803.1"><vh>@clean Trajectory.js</vh>
<v t="leo.20191210203812.1"><vh>function Trajectory</vh></v>
<v t="leo.20191210203812.2"><vh>Trajectory.prototype.getPoint = function</vh></v>
<v t="leo.20191210203812.3"><vh>Trajectory.prototype.setPoint = function</vh></v>
<v t="leo.20191210203812.4"><vh>Trajectory.prototype.getTrajectory = function</vh></v>
<v t="leo.20191210203812.5"><vh>Trajectory.prototype.getTrajectoryOneCycle = function</vh></v>
<v t="leo.20191210203812.6"><vh>Trajectory.prototype.flush = function</vh></v>
<v t="leo.20191210203812.7"><vh>Trajectory.prototype.record = function</vh></v>
<v t="leo.20191210203812.8"><vh>Trajectory.prototype.init = function</vh></v>
</v>
<v t="leo.20191210203827.1"><vh>@clean Gear.js</vh>
<v t="leo.20191210203835.1"><vh>function Gear</vh></v>
<v t="leo.20191210203835.2"><vh>Gear.prototype.getPoint = function</vh></v>
<v t="leo.20191210203835.3"><vh>Gear.prototype.setPoint = function</vh></v>
<v t="leo.20191210203835.4"><vh>Gear.prototype.setRadius = function</vh></v>
<v t="leo.20191210203835.5"><vh>Gear.prototype.defineVertices = function</vh></v>
<v t="leo.20191210203835.6"><vh>Gear.prototype.getVertices = function</vh></v>
</v>
<v t="leo.20191210203851.1"><vh>@clean Load.js</vh>
<v t="leo.20191210203857.1"><vh>function Load</vh></v>
<v t="leo.20191210203857.2"><vh>Load.prototype.getPoint = function</vh></v>
<v t="leo.20191210203857.3"><vh>Load.prototype.init = function</vh></v>
<v t="leo.20191210203857.4"><vh>Load.prototype.getLoadX = function</vh></v>
<v t="leo.20191210203857.5"><vh>Load.prototype.getLoadY = function</vh></v>
<v t="leo.20191210203857.6"><vh>Load.prototype.setLoadX = function</vh></v>
<v t="leo.20191210203857.7"><vh>Load.prototype.setLoadY = function</vh></v>
<v t="leo.20191210203857.8"><vh>Load.prototype.getGlobalPosition = function</vh></v>
</v>
</v>
<v t="leo.20191210203938.1"><vh>@path core/threejs</vh>
<v t="leo.20191210204001.1"><vh>@clean AssemblyGroup.js</vh>
<v t="leo.20191210204008.1"><vh>function AssemblyGroup</vh></v>
<v t="leo.20191210204008.2"><vh>AssemblyGroup.prototype.init = function</vh></v>
<v t="leo.20191210204008.3"><vh>AssemblyGroup.prototype.remove = function</vh></v>
<v t="leo.20191210204008.4"><vh>AssemblyGroup.prototype.load = function</vh></v>
<v t="leo.20191210204008.5"><vh>AssemblyGroup.prototype.updateRender = function</vh></v>
<v t="leo.20191210204008.6"><vh>AssemblyGroup.prototype.update = function</vh></v>
<v t="leo.20191210204008.7"><vh>AssemblyGroup.prototype.onStart = function</vh></v>
<v t="leo.20191210204008.8"><vh>AssemblyGroup.prototype.onEnd = function</vh></v>
<v t="leo.20191210204008.9"><vh>AssemblyGroup.prototype.getAssembly = function</vh></v>
<v t="leo.20191210204008.10"><vh>AssemblyGroup.prototype.getSpace = function</vh></v>
<v t="leo.20191210204008.11"><vh>AssemblyGroup.prototype.getMousePlane = function</vh></v>
<v t="leo.20191210204008.12"><vh>AssemblyGroup.prototype.getPlane = function</vh></v>
<v t="leo.20191210204008.13"><vh>AssemblyGroup.prototype.getTrajectory = function</vh></v>
<v t="leo.20191210204008.14"><vh>AssemblyGroup.prototype.getSelection = function</vh></v>
<v t="leo.20191210204008.15"><vh>AssemblyGroup.prototype.drawPlane = function</vh></v>
<v t="leo.20191210204008.16"><vh>AssemblyGroup.prototype.drawSelection = function</vh></v>
<v t="leo.20191210204008.17"><vh>AssemblyGroup.prototype.showPlane = function</vh></v>
<v t="leo.20191210204008.18"><vh>AssemblyGroup.prototype.hidePlane = function</vh></v>
<v t="leo.20191210204008.19"><vh>AssemblyGroup.prototype.showGrid = function</vh></v>
<v t="leo.20191210204008.20"><vh>AssemblyGroup.prototype.hideGrid = function</vh></v>
<v t="leo.20191210204008.21"><vh>AssemblyGroup.prototype.showSBGrid = function</vh></v>
<v t="leo.20191210204008.22"><vh>AssemblyGroup.prototype.hideSBGrid = function</vh></v>
<v t="leo.20191210204008.23"><vh>AssemblyGroup.prototype.showCube = function</vh></v>
<v t="leo.20191210204008.24"><vh>AssemblyGroup.prototype.hideCube = function</vh></v>
<v t="leo.20191210204008.25"><vh>AssemblyGroup.prototype.showText = function</vh></v>
<v t="leo.20191210204008.26"><vh>AssemblyGroup.prototype.hideText = function</vh></v>
<v t="leo.20191210204008.27"><vh>AssemblyGroup.prototype.setSettings = function</vh></v>
<v t="leo.20191210204008.28"><vh>AssemblyGroup.prototype.setOpacity = function</vh></v>
<v t="leo.20191210204008.29"><vh>AssemblyGroup.prototype.setPlane = function</vh></v>
<v t="leo.20191210204008.30"><vh>AssemblyGroup.prototype.getPositionData = function</vh></v>
<v t="leo.20191210204008.31"><vh>AssemblyGroup.prototype.setPositionData = function</vh></v>
<v t="leo.20191210204008.32"><vh>AssemblyGroup.prototype.savePositions = function</vh></v>
<v t="leo.20191210204008.33"><vh>AssemblyGroup.prototype.restorePositions = function</vh></v>
<v t="leo.20191210204008.34"><vh>AssemblyGroup.prototype.calculateAssembly = function</vh></v>
<v t="leo.20191210204008.35"><vh>AssemblyGroup.prototype.actuateAll = function</vh></v>
<v t="leo.20191210204008.36"><vh>AssemblyGroup.prototype.setAllActuator = function</vh></v>
<v t="leo.20191210204008.37"><vh>AssemblyGroup.prototype.actuateByName = function</vh></v>
<v t="leo.20191210204008.38"><vh>AssemblyGroup.prototype.getAllActuator = function</vh></v>
<v t="leo.20191210204008.39"><vh>AssemblyGroup.prototype.recordTrajectories = function</vh></v>
<v t="leo.20191210204008.40"><vh>AssemblyGroup.prototype.flushTrajectories = function</vh></v>
<v t="leo.20191210204008.41"><vh>AssemblyGroup.prototype.initTrajectories = function</vh></v>
<v t="leo.20191210204008.42"><vh>AssemblyGroup.prototype.newTrajectory = function</vh></v>
<v t="leo.20191210204008.43"><vh>AssemblyGroup.prototype.newLoad = function</vh></v>
<v t="leo.20191210204008.44"><vh>AssemblyGroup.prototype.loadElements = function</vh></v>
<v t="leo.20191210204008.45"><vh>AssemblyGroup.prototype.updateElements = function</vh></v>
<v t="leo.20191210204008.46"><vh>AssemblyGroup.prototype.loadActuators = function</vh></v>
<v t="leo.20191210204008.47"><vh>AssemblyGroup.prototype.updateActuators = function</vh></v>
<v t="leo.20191210204008.48"><vh>AssemblyGroup.prototype.loadTrajectories = function</vh></v>
<v t="leo.20191210204008.49"><vh>AssemblyGroup.prototype.updateTrajectories = function</vh></v>
<v t="leo.20191210204008.50"><vh>AssemblyGroup.prototype.loadOptPath = function</vh></v>
<v t="leo.20191210204008.51"><vh>AssemblyGroup.prototype.updateOptPath = function</vh></v>
<v t="leo.20191210204008.52"><vh>AssemblyGroup.prototype.loadLoads = function</vh></v>
<v t="leo.20191210204008.53"><vh>AssemblyGroup.prototype.updateLoads = function</vh></v>
<v t="leo.20191210204008.54"><vh>AssemblyGroup.prototype.drawHoverSegment = function</vh></v>
<v t="leo.20191210204008.55"><vh>AssemblyGroup.prototype.updateSegmentHover = function</vh></v>
<v t="leo.20191210204008.56"><vh>AssemblyGroup.prototype.setSegmentSelected = function</vh></v>
<v t="leo.20191210204008.57"><vh>AssemblyGroup.prototype.removeSegmentSelected = function</vh></v>
<v t="leo.20191210204008.58"><vh>AssemblyGroup.prototype.getLinkVertex = function</vh></v>
<v t="leo.20191210204008.59"><vh>AssemblyGroup.prototype.findObjectFromElement = function</vh></v>
<v t="leo.20191210204008.60"><vh>AssemblyGroup.prototype.findActObjFromActuator = function</vh></v>
<v t="leo.20191210204008.61"><vh>AssemblyGroup.prototype.findTrgObjFromTrajectory = function</vh></v>
<v t="leo.20191210204008.62"><vh>AssemblyGroup.prototype.findLoadObjFromLoad = function</vh></v>
<v t="leo.20191210204008.63"><vh>AssemblyGroup.prototype.findLengthListFromElement = function</vh></v>
<v t="leo.20191210204008.64"><vh>AssemblyGroup.prototype.resetElements = function</vh></v>
<v t="leo.20191210204008.65"><vh>AssemblyGroup.prototype.try360 = function</vh></v>
<v t="leo.20191210204008.66"><vh>AssemblyGroup.prototype.makeGear = function</vh></v>
<v t="leo.20191210204008.67"><vh>AssemblyGroup.prototype.removeGear = function</vh></v>
<v t="leo.20191210204008.68"><vh>function Gear3D</vh></v>
<v t="leo.20191210204008.69"><vh>Gear3D.prototype.createShape = function</vh></v>
<v t="leo.20191210204008.70"><vh>Gear3D.prototype.remove = function</vh></v>
<v t="leo.20191210204008.71"><vh>AssemblyGroup.prototype.makeFrame = function</vh></v>
<v t="leo.20191210204008.72"><vh>AssemblyGroup.prototype.removeFrame = function</vh></v>
</v>
<v t="leo.20191210204023.1"><vh>@clean 3DElements.js</vh>
<v t="leo.20191210204028.1"><vh>function Link3D</vh></v>
<v t="leo.20191210204028.2"><vh>Link3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.3"><vh>Link3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.4"><vh>Link3D.prototype.setVertices = function</vh></v>
<v t="leo.20191210204028.5"><vh>Link3D.prototype.setColor = function</vh></v>
<v t="leo.20191210204028.6"><vh>Link3D.prototype.createShape = function</vh></v>
<v t="leo.20191210204028.7"><vh>Link3D.prototype.setStack = function</vh></v>
<v t="leo.20191210204028.8"><vh>Link3D.prototype.updateStack = function</vh></v>
<v t="leo.20191210204028.9"><vh>function Point3D</vh></v>
<v t="leo.20191210204028.10"><vh>Point3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.11"><vh>Point3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.12"><vh>Point3D.prototype.setPosition = function</vh></v>
<v t="leo.20191210204028.13"><vh>Point3D.prototype.setScale = function</vh></v>
<v t="leo.20191210204028.14"><vh>Point3D.prototype.setColor = function</vh></v>
<v t="leo.20191210204028.15"><vh>function Anchor3D</vh></v>
<v t="leo.20191210204028.16"><vh>Anchor3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.17"><vh>Anchor3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.18"><vh>Anchor3D.prototype.setPosition = function</vh></v>
<v t="leo.20191210204028.19"><vh>Anchor3D.prototype.setScale = function</vh></v>
<v t="leo.20191210204028.20"><vh>Anchor3D.prototype.setColor = function</vh></v>
<v t="leo.20191210204028.21"><vh>function Text3D</vh></v>
<v t="leo.20191210204028.22"><vh>Text3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.23"><vh>Text3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.24"><vh>Text3D.prototype.setPosition = function</vh></v>
<v t="leo.20191210204028.25"><vh>Text3D.prototype.setText = function</vh></v>
<v t="leo.20191210204028.26"><vh>Text3D.prototype.setOpacity = function</vh></v>
<v t="leo.20191210204028.27"><vh>function Actuator3D</vh></v>
<v t="leo.20191210204028.28"><vh>Actuator3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.29"><vh>Actuator3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.30"><vh>Actuator3D.prototype.setPosition = function</vh></v>
<v t="leo.20191210204028.31"><vh>Actuator3D.prototype.setAngle = function</vh></v>
<v t="leo.20191210204028.32"><vh>Actuator3D.prototype.setColor = function</vh></v>
<v t="leo.20191210204028.33"><vh>Actuator3D.prototype.setScale = function</vh></v>
<v t="leo.20191210204028.34"><vh>Actuator3D.prototype.setTextOpacity = function</vh></v>
<v t="leo.20191210204028.35"><vh>Actuator3D.prototype.showServoAngle = function</vh></v>
<v t="leo.20191210204028.36"><vh>function Trajectory3D</vh></v>
<v t="leo.20191210204028.37"><vh>Trajectory3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.38"><vh>Trajectory3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.39"><vh>Trajectory3D.prototype.setVertices = function</vh></v>
<v t="leo.20191210204028.40"><vh>Trajectory3D.prototype.setPosition = function</vh></v>
<v t="leo.20191210204028.41"><vh>Trajectory3D.prototype.setColor = function</vh></v>
<v t="leo.20191210204028.42"><vh>Trajectory3D.prototype.setDrawRange = function</vh></v>
<v t="leo.20191210204028.43"><vh>function Load3D</vh></v>
<v t="leo.20191210204028.44"><vh>Load3D.prototype.remove = function</vh></v>
<v t="leo.20191210204028.45"><vh>Load3D.prototype.findFromElement = function</vh></v>
<v t="leo.20191210204028.46"><vh>Load3D.prototype.setPosition = function</vh></v>
</v>
<v t="leo.20191210204042.1"><vh>@clean ThreeSetup.js</vh>
<v t="leo.20191210204048.1"><vh>function init</vh></v>
<v t="leo.20191210204048.2"><vh>function webglAvailable</vh></v>
</v>
</v>
<v t="leo.20191210204116.1"><vh>@path core/interface</vh>
<v t="leo.20191210204124.1"><vh>@clean EventHandlers.js</vh>
<v t="leo.20191210204148.1"><vh>function getMousePoints</vh></v>
<v t="leo.20191210204148.2"><vh>function getTargetPlane</vh></v>
<v t="leo.20191210204148.3"><vh>function onDocumentMouseMove</vh></v>
<v t="leo.20191210204148.4"><vh>function onDocumentMouseDown</vh></v>
<v t="leo.20191210204148.5"><vh>function onDocumentMouseUp</vh></v>
<v t="leo.20191210204148.6"><vh>function onDocumentMouseOut</vh></v>
<v t="leo.20191210204148.7"><vh>function onDocumentTouchDown</vh></v>
<v t="leo.20191210204148.8"><vh>function onDocumentTouchUp</vh></v>
<v t="leo.20191210204148.9"><vh>function onDocumentTouchMove</vh></v>
<v t="leo.20191210204148.10"><vh>function onDocumentKeyDown</vh></v>
<v t="leo.20191210204148.11"><vh>function onDocumentKeyUp</vh></v>
<v t="leo.20191210204148.12"><vh>function onWindowResize</vh></v>
<v t="leo.20191210204148.13"><vh>function onUpdatePlanePanel</vh></v>
</v>
<v t="leo.20191210204157.1"><vh>@clean ToolSelect.js</vh>
<v t="leo.20191210204203.1"><vh>function interfaceSelect</vh></v>
<v t="leo.20191210204203.2"><vh>function setTool</vh></v>
<v t="leo.20191210204203.3"><vh>$('#msketch_drawer_open').click function</vh></v>
<v t="leo.20191210204203.4"><vh>function closeDrawer</vh></v>
<v t="leo.20191210204203.5"><vh>function checkToolSet</vh></v>
<v t="leo.20191210204203.6"><vh>function setViewMode</vh></v>
</v>
<v t="leo.20191210204211.1"><vh>@clean MouseInterface.js</vh>
<v t="leo.20191210204217.1"><vh>function LinkInterface</vh></v>
<v t="leo.20191210204217.2"><vh>LinkInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.3"><vh>LinkInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.4"><vh>LinkInterface.prototype.mouseDownAndMoveFirst = function</vh></v>
<v t="leo.20191210204217.5"><vh>LinkInterface.prototype.mouseDownAndMove = function</vh></v>
<v t="leo.20191210204217.6"><vh>LinkInterface.prototype.mouseDownAndUp = function</vh></v>
<v t="leo.20191210204217.7"><vh>LinkInterface.prototype.mouseMoveAndUp = function</vh></v>
<v t="leo.20191210204217.8"><vh>function JAInterface</vh></v>
<v t="leo.20191210204217.9"><vh>JAInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.10"><vh>JAInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.11"><vh>function MarkInterface</vh></v>
<v t="leo.20191210204217.12"><vh>MarkInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.13"><vh>MarkInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.14"><vh>MarkInterface.prototype.mouseMoveAndUp = function</vh></v>
<v t="leo.20191210204217.15"><vh>function MoveInterface</vh></v>
<v t="leo.20191210204217.16"><vh>MoveInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.17"><vh>MoveInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.18"><vh>MoveInterface.prototype.mouseDownAndMoveFirst = function</vh></v>
<v t="leo.20191210204217.19"><vh>MoveInterface.prototype.mouseDownAndMove = function</vh></v>
<v t="leo.20191210204217.20"><vh>MoveInterface.prototype.mouseDownAndUp = function</vh></v>
<v t="leo.20191210204217.21"><vh>MoveInterface.prototype.mouseMoveAndUp = function</vh></v>
<v t="leo.20191210204217.22"><vh>function RemoveInterface</vh></v>
<v t="leo.20191210204217.23"><vh>RemoveInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.24"><vh>RemoveInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.25"><vh>function OptInterface</vh></v>
<v t="leo.20191210204217.26"><vh>OptInterface.prototype.mouseDownAndMoveFirst = function</vh></v>
<v t="leo.20191210204217.27"><vh>OptInterface.prototype.mouseDownAndMove = function</vh></v>
<v t="leo.20191210204217.28"><vh>OptInterface.prototype.mouseMoveAndUp = function</vh></v>
<v t="leo.20191210204217.29"><vh>function SliderInterface</vh></v>
<v t="leo.20191210204217.30"><vh>SliderInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.31"><vh>SliderInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.32"><vh>SliderInterface.prototype.mouseDownAndMoveFirst = function</vh></v>
<v t="leo.20191210204217.33"><vh>SliderInterface.prototype.mouseDownAndMove = function</vh></v>
<v t="leo.20191210204217.34"><vh>SliderInterface.prototype.mouseDownAndUp = function</vh></v>
<v t="leo.20191210204217.35"><vh>SliderInterface.prototype.mouseMoveAndUp = function</vh></v>
<v t="leo.20191210204217.36"><vh>function AddLoadInterface</vh></v>
<v t="leo.20191210204217.37"><vh>AddLoadInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.38"><vh>AddLoadInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.39"><vh>function EditLoadInterface</vh></v>
<v t="leo.20191210204217.40"><vh>EditLoadInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.41"><vh>EditLoadInterface.prototype.mouseDownAndUp = function</vh></v>
<v t="leo.20191210204217.42"><vh>function RemoveLoadInterface</vh></v>
<v t="leo.20191210204217.43"><vh>RemoveLoadInterface.prototype.mouseMove = function</vh></v>
<v t="leo.20191210204217.44"><vh>RemoveLoadInterface.prototype.mouseDown = function</vh></v>
<v t="leo.20191210204217.45"><vh>function getPointByPosition</vh></v>
<v t="leo.20191210204217.46"><vh>function getLinkByPosition</vh></v>
<v t="leo.20191210204217.47"><vh>function getAllLinkByPosition</vh></v>
<v t="leo.20191210204217.48"><vh>function getActuatorByPosition</vh></v>
<v t="leo.20191210204217.49"><vh>function isPointInPoly</vh></v>
<v t="leo.20191210204217.50"><vh>function try360forAssemblies</vh></v>
<v t="leo.20191210204217.51"><vh>function setLengthToLink</vh></v>
<v t="leo.20191210204217.52"><vh>function findPointPair</vh></v>
<v t="leo.20191210204217.53"><vh>function findSliderConstraint</vh></v>
</v>
<v t="leo.20191210204227.1"><vh>@clean UndoAndRedo.js</vh>
<v t="leo.20191210204232.1"><vh>function checkHistory</vh></v>
<v t="leo.20191210204232.2"><vh>function undo</vh></v>
<v t="leo.20191210204232.3"><vh>function redo</vh></v>
</v>
</v>
<v t="leo.20191210204255.1"><vh>@path core/io</vh>
<v t="leo.20191210204301.1"><vh>@clean FileIO.js</vh>
<v t="leo.20191210204310.1"><vh>function makeNewFile</vh></v>
<v t="leo.20191210204310.2"><vh>function loadMsketchInfo</vh></v>
<v t="leo.20191210204310.3"><vh>function importPlaneInfo</vh></v>
<v t="leo.20191210204310.4"><vh>function loadMsketchInfoForPlane</vh></v>
<v t="leo.20191210204310.5"><vh>function getMsketchInfo</vh></v>
<v t="leo.20191210204310.6"><vh>function getMsketchInfoForPlane</vh></v>
<v t="leo.20191210204310.7"><vh>function saveAssemblyPositions</vh></v>
<v t="leo.20191210204310.8"><vh>function restoreAssemblyPositions</vh></v>
<v t="leo.20191210204310.9"><vh>function saveAsText</vh></v>
</v>
<v t="leo.20191210204330.1"><vh>@clean ExportDrawing.js</vh>
<v t="leo.20191210204336.1"><vh>function exportDrawing</vh></v>
<v t="leo.20191210204336.2"><vh>function exportCameoDrawing</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20191210163956.1">@language html

&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;&lt; head &gt;&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class="msketch-titlebar"&gt;
        &lt;button class="msketch-titlebar-btn" id="msketch_drawer_open"&gt;&lt;i class="material-icons"&gt;menu&lt;/i&gt;&lt;/button&gt;
        &lt;span class="msketch-logo"&gt;M.SKETCH&lt;/span&gt;
        
        &lt;div class="msketch-titlebar-container"&gt;
        &lt;button class="msketch-titlebar-btn" id="btn_play" onclick="interfaceSelect(TOOL_RUN);" data-tooltip="Run"&gt;&lt;i class="material-icons"&gt;play_arrow&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-titlebar-btn" id="btn_save" onclick="showDialog(TOOL_SAVE)" data-tooltip="Save"&gt;&lt;i class="material-icons"&gt;save&lt;/i&gt;&lt;/button&gt;
        &lt;input id="msketch-titlebar-filename" value="Untitled Sketch"&gt;&lt;/input&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-titlebar-username"&gt;&lt;i class="material-icons"&gt;person_pin&lt;/i&gt;User Name&lt;/div&gt;
        
        &lt;/div&gt;
        &lt;div class="msketch-toolbar"&gt;
        &lt;div class="msketch-toolbar-container" id="msketch_toolbar"&gt;
        &lt;div class="msketch-toolbar-text"&gt;Drawing&lt;/div&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_link" onclick="interfaceSelect(TOOL_LINK);" data-tooltip="Add Link"&gt;&lt;img src="./public/res/icons/btnLink.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_ja" onclick="interfaceSelect(TOOL_JA);" data-tooltip="Add Motor"&gt;&lt;img src="./public/res/icons/btnJA.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_slider" onclick="interfaceSelect(TOOL_SLIDER);" data-tooltip="Set Slider"&gt;&lt;img src="./public/res/icons/btnSlider.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_mark" onclick="interfaceSelect(TOOL_MARK);" data-tooltip="Toggle Marker"&gt;&lt;img src="./public/res/icons/btnMark.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_move" onclick="interfaceSelect(TOOL_MOVE);" data-tooltip="Edit Link"&gt;&lt;img src="./public/res/icons/btnMove.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_remove" onclick="interfaceSelect(TOOL_REMOVE);" data-tooltip="Remove Part"&gt;&lt;i class="material-icons"&gt;delete_forever&lt;/i&gt;&lt;/button&gt;
        &lt;div class="msketch-toolbar-spacer"&gt;|&lt;/div&gt;
        &lt;div class="msketch-toolbar-text"&gt;Navigation&lt;/div&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_nav" onclick="interfaceSelect(TOOL_NAV);" data-tooltip="Toggle View Tumbling"&gt;&lt;i class="material-icons"&gt;3d_rotation&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_pcam" onclick="interfaceSelect(TOOL_PCAM);" data-tooltip="See Plane on Top"&gt;&lt;i class="material-icons"&gt;fullscreen&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_pcam" onclick="setViewMode(0);" data-tooltip="Schematic View"&gt;&lt;img src="./public/res/icons/btnSchematicView.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_pcam" onclick="setViewMode(1);" data-tooltip="Part View"&gt;&lt;img src="./public/res/icons/btnPartsView.png"&gt;&lt;/button&gt;
        &lt;div class="msketch-toolbar-spacer"&gt;|&lt;/div&gt;
        &lt;div class="msketch-toolbar-text"&gt;History&lt;/div&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_nav" onclick="undo();" data-tooltip="Undo"&gt;&lt;i class="material-icons"&gt;chevron_left&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_pcam" onclick="redo();" data-tooltip="Redo"&gt;&lt;i class="material-icons"&gt;chevron_right&lt;/i&gt;&lt;/button&gt;
        &lt;div class="msketch-toolbar-spacer"&gt;|&lt;/div&gt;
        &lt;div class="msketch-toolbar-text"&gt;Plane&lt;/div&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_padd" onclick="interfaceSelect(TOOL_PADD);" data-tooltip="Add Plane"&gt;&lt;img src="./public/res/icons/btnPAdd.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_premove" onclick="showDialog(TOOL_PREMOVE);" data-tooltip="Remove Plane"&gt;&lt;img src="./public/res/icons/btnPRemove.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_psel" onclick="interfaceSelect(TOOL_PSEL);" data-tooltip="Select Plane"&gt;&lt;img src="./public/res/icons/btnPSel.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_ptrans" onclick="interfaceSelect(TOOL_PTRANS);" data-tooltip="Plane Translation"&gt;&lt;img src="./public/res/icons/btnPTrans.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_prot" onclick="interfaceSelect(TOOL_PROT);" data-tooltip="Plane Rotation"&gt;&lt;img src="./public/res/icons/btnPRot.png"&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_prot" onclick="interfaceSelect(TOOL_PCOPY);" data-tooltip="Copy This Plane"&gt;&lt;img src="./public/res/icons/btnPCopy.png"&gt;&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;/div&gt;
        
        &lt;div class="msketch-drawer" id="msketch_drawer"&gt;
        &lt;button class="msketch-drawer-btn" onclick="showDialog(TOOL_NEWFILE);"&gt;&lt;i class="material-icons"&gt;insert_drive_file&lt;/i&gt;New&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="showDialog(TOOL_SAVE);"&gt;&lt;i class="material-icons"&gt;save&lt;/i&gt;Save&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="showDialog(TOOL_OPEN);"&gt;&lt;i class="material-icons"&gt;folder_open&lt;/i&gt;Open&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="interfaceSelect(TOOL_EXPORT);"&gt;&lt;i class="material-icons"&gt;file_download&lt;/i&gt;Export Plane&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="showDialog(TOOL_IMPORT);"&gt;&lt;i class="material-icons"&gt;file_upload&lt;/i&gt;Import Plane&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="interfaceSelect(TOOL_DRAWING);"&gt;&lt;i class="material-icons"&gt;picture_as_pdf&lt;/i&gt;Export Drawing&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="location.href='logout';"&gt;&lt;i class="material-icons"&gt;cloud_off&lt;/i&gt;Logout&lt;/button&gt;
        &lt;button class="msketch-drawer-btn" onclick="$('#msketch_about').show();"&gt;&lt;i class="material-icons"&gt;info_outline&lt;/i&gt;About&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-sidebar"&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_move" data-tooltip-side="Position Panel"&gt;&lt;i class="material-icons"&gt;open_with&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_plane" data-tooltip-side="Plane Panel"&gt;&lt;i class="material-icons"&gt;layers&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_motor" data-tooltip-side="Motor Panel"&gt;&lt;i class="material-icons"&gt;slow_motion_video&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_pattern" data-tooltip-side="Pattern Panel"&gt;&lt;i class="material-icons"&gt;filter_tilt_shift&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_analysis" data-tooltip-side="Walking Analysis Panel"&gt;&lt;i class="material-icons"&gt;multiline_chart&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_opt" data-tooltip-side="Path Optimization Panel"&gt;&lt;i class="material-icons"&gt;gesture&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_fab" data-tooltip-side="Fabrication Panel"&gt;&lt;i class="material-icons"&gt;build&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_gen" data-tooltip-side="Linkage Generation Panel"&gt;&lt;i class="material-icons"&gt;linear_scale&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_panel_load" data-tooltip-side="Load Panel"&gt;&lt;i class="material-icons"&gt;play_for_work&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="btn_settings" data-tooltip-side="Settings"&gt;&lt;i class="material-icons"&gt;settings&lt;/i&gt;&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-panel" id="msketch_panel"&gt;
        &lt;div class="msketch-panel-container" id="panel_move" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Point &amp;amp; Link&lt;br&gt;Position&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="x" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_move_x" disabled&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="y" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_move_y" disabled&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Length" style="width: 100%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_move_length" disabled&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;label class="form-switch"&gt;
        &lt;input type="checkbox" id="panel_move_sbGrid"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;ScienceBox Grid &amp;amp; Snap&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class="form-switch"&gt;
        &lt;input type="checkbox" id="panel_move_sbSnap"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;ScienceBox Unit Conversion&lt;/span&gt;
        &lt;/label&gt;
        &lt;/div&gt;
        
        &lt;button class="msketch-panel-btn-large" id="panel_move_apply"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Apply&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;&lt; position_panel_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_plane" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Plane Position&lt;br&gt;&amp;amp; Rotation&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="tx" style="width: 32%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_plane_tx"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="ty" style="width: 32%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_plane_ty"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="tz" style="width: 32%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_plane_tz"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="rx" style="width: 32%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_plane_rx"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="ry" style="width: 32%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_plane_ry"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="rz" style="width: 32%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_plane_rz"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;button class="msketch-panel-btn-large" id="panel_plane_apply"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Apply&lt;/button&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_plane_flipHor" style="width: 47%; display:inline-block; float: left"&gt;&lt;i class="material-icons"&gt;flip&lt;/i&gt;Flip Hor&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_plane_flipVert" style="width: 47%; display:inline-block; float: right"&gt;&lt;i class="material-icons" style="transform: rotate(90deg); padding-right: 0; height: 29px"&gt;flip&lt;/i&gt;Flip Vert&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;&lt; apply_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_motor" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Motor&lt;br&gt;Setting&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Unit Speed (deg/s)" style="width: 100%; vertical-align: bottom"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="motor_gspeed_txt" value="180" style="width: 20%;"&gt;
        &lt;input class="slider msketch-panel-slider" type="range" id="motor_gspeed_slider" min="0" max="720" value="180" style="width: 70%;"/&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Motor List" style="width: 100%;"&gt;
        &lt;select id="motor_list" class="form-select msketch-panel-select"&gt;
        &lt;/select&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label motor-both disableClick" data-label="Motor Type" style="width: 100%; vertical-align: bottom"&gt;
        &lt;label class="form-radio" style="width: 49%;"&gt;
        &lt;input type="radio" name="gender" id="motor_type_dc" checked&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;DC Motor&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class="form-radio" style="width: 49%;"&gt;
        &lt;input type="radio" name="gender" id="motor_type_servo" &gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;Servo Motor&lt;/span&gt;
        &lt;/label&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label motor-both disableClick" data-label="Motor Phase (deg)" style="width: 100%; vertical-align: bottom"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="motor_phase_txt" style="width: 20%;"&gt;
        &lt;input class="slider msketch-panel-slider" type="range" id="motor_phase_slider" min="0" max="360" value="0" style="width: 70%;"/&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label motor-both disableClick" data-label="Speed Multiply (%)" style="width: 100%; vertical-align: bottom"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="motor_speed_txt" style="width: 20%;"&gt;
        &lt;input class="slider msketch-panel-slider" type="range" id="motor_speed_slider" min="0" max="400" value="100" style="width: 70%;"/&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label motor-servo disableClick" data-label="Min Angle (deg)" style="width: 100%; vertical-align: bottom"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="motor_min_txt" style="width: 20%;"&gt;
        &lt;input class="slider msketch-panel-slider" type="range" id="motor_min_slider" min="0" max="360" value="0" style="width: 70%;"/&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label motor-servo disableClick" data-label="Max Angle (deg)" style="width: 100%; vertical-align: bottom"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="motor_max_txt" style="width: 20%;"&gt;
        &lt;input class="slider msketch-panel-slider" type="range" id="motor_max_slider" min="0" max="360" value="180" style="width: 70%;"/&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;label class="form-switch motor-dc disableClick"&gt;
        &lt;input type="checkbox" id="motor_reverse"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;Reverse Direction&lt;/span&gt;
        &lt;/label&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;style&gt;
        .msketch-panel-slider{
        display:inline-block;
        margin-left: 12px;
        vertical-align: middle;
        }
        .msketch-panel-input{
        vertical-align: middle;
        }
        &lt;/style&gt;
        
        &lt;&lt; motor_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_pattern" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Pattern&lt;br&gt;Generation&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Axis (World Coordinate)" style="width: 100%;"&gt;
        &lt;label class="form-radio" style="width: 32%;"&gt;
        &lt;input type="radio" name="gender" id="panel_pattern_x" checked&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;x&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class="form-radio" style="width: 32%;"&gt;
        &lt;input type="radio" name="gender" id="panel_pattern_y" &gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;y&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class="form-radio" style="width: 32%;"&gt;
        &lt;input type="radio" name="gender" id="panel_pattern_z"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;z&lt;/span&gt;
        &lt;/label&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Angle" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_pattern_angle"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="Amount" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_pattern_amount"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;button class="msketch-panel-btn-large" id="panel_pattern_apply"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Make&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;&lt; pattern_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_analysis" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Walking Path&lt;br&gt;Analysis&lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;img src="./public/res/desAnalysis.png" style="width: 100%; padding: 16px; background-color: #fff; border-radius: 5px"&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc"&gt;Analyze strides with marked points on designed mechanism. Movement for analysis is not affected by motor setting.&lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_analysis_run"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Run&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_analysis_stop"&gt;&lt;i class="material-icons"&gt;stop&lt;/i&gt;Stop&lt;/button&gt;
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="panel-analysis-result-container header"&gt;
        &lt;div class="msketch-panel-desc" style="width: 15%;"&gt;Color&lt;/div&gt;
        &lt;div class="msketch-panel-desc" style="width: 40%;"&gt;Ground Length&lt;/div&gt;
        &lt;div class="msketch-panel-desc" style="width: 40%;"&gt;Angle Coefficient&lt;/div&gt;
        &lt;/div&gt;
        &lt;div id="panel_analysis_result"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;style&gt;
        .panel-analysis-result-container &gt; div {
        display: inline-block;
        font-size: 13px;
        margin-bottom: 6px;
        vertical-align: middle;
        float: left;
        }
        .panel-analysis-result-container.header &gt; div{
        font-weight: 700;
        color: #555;
        }
        .panel-analysis-bullet{
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid #888;
        }
        &lt;/style&gt;
        
        &lt;&lt; analysis_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_opt" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Path&lt;br&gt;Optimization&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc"&gt;Optimize current mechanism's movement fitting to target drawing. Draw a movement that you want&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc" id="panel_opt_msg" style="font-style: italic;"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Marker List" style="width: 100%;"&gt;
        &lt;select id="panel_opt_markerIndex" class="form-select msketch-panel-select"&gt;
        &lt;/select&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_opt_draw"&gt;&lt;i class="material-icons"&gt;gesture&lt;/i&gt;Draw Target Path&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_opt_remove"&gt;&lt;i class="material-icons"&gt;delete&lt;/i&gt;Remove Target Path&lt;/button&gt;
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large disableClick" id="panel_opt_run"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Optimize&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large disableClick" id="panel_opt_stop"&gt;&lt;i class="material-icons"&gt;stop&lt;/i&gt;Stop&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;&lt; tool_javascript &gt;&gt;
        
        &lt;!-- Linkage generation panel
        made by yunwoo jeong --&gt;
        &lt;!-- yw_edited --&gt;
        
        &lt;div class="msketch-panel-container" id="panel_gen" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Linkage&lt;br&gt;Generation&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc"&gt;Generate the linkage mechanism. Draw a movement that you want&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc" id="panel_gen_msg" style="font-style: italic;"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_gen_draw"&gt;&lt;i class="material-icons"&gt;gesture&lt;/i&gt;Draw Target Path&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_gen_remove"&gt;&lt;i class="material-icons"&gt;delete&lt;/i&gt;Remove Target Path&lt;/button&gt;
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Mechanism Type" style="width: 100%;"&gt;
        &lt;label class="form-radio" style="width: 49%;"&gt;
        &lt;input type="radio" name="gender" id="panel_gen_4" checked&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;4-bar&lt;/span&gt;
        &lt;/label&gt;
        &lt;!-- &lt;label class="form-radio" style="width: 49%;"&gt;
        &lt;input type="radio" name="gender" id="panel_gen_6" &gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;6-bar&lt;/span&gt;
        &lt;/label&gt; --&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_gen_run"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Generate&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;&lt; linkage_generation_javascript &gt;&gt;
        
        &lt;!-- Linkage generation panel
        updated by yunwoo jeong --&gt;
        &lt;!-- yw_edited --&gt;
        
        &lt;div class="msketch-panel-container" id="panel_fab" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Fabrication&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc"&gt;Generate the 3D links and gears. Use 'Edit Link' tool to select a link&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc" style="font-weight: 700"&gt;3D Link Generation&lt;/div&gt;
        &lt;label class="form-switch"&gt;
        &lt;input type="checkbox" id="panel_fab_Show3DLink"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;Show 3D Link&lt;/span&gt;
        &lt;/label&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-btn-text"&gt;Stacking Order&lt;/div&gt;
        &lt;button class="msketch-panel-btn" id="btn_stackPlus"&gt;&lt;i class="material-icons"&gt;add_circle_outline&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-panel-btn" id="btn_stackMinus"&gt;&lt;i class="material-icons"&gt;remove_circle_outline&lt;/i&gt;&lt;/button&gt;
        &lt;/div&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_fab_downloadLink"&gt;&lt;i class="material-icons"&gt;file_download&lt;/i&gt;Download Links (OBJ)&lt;/button&gt;
        &lt;hr&gt;
        
        &lt;div class="msketch-panel-desc" style="font-weight: 700"&gt;Gear Generation&lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_fab_generateGear" style="width: 47%; display:inline-block; float: left"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Generate&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_fab_removeGear" style="width: 47%; display:inline-block; float: right"&gt;&lt;i class="material-icons"&gt;remove&lt;/i&gt;Remove&lt;/button&gt;
        &lt;/div&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_fab_downloadGear"&gt;&lt;i class="material-icons"&gt;file_download&lt;/i&gt;Download Gears (OBJ)&lt;/button&gt;
        
        &lt;/div&gt;
        
        &lt;&lt; link_3d_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_load" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Load&lt;br&gt;Setting&lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;button class="msketch-panel-btn" id="btn_addload" onclick="interfaceSelect(TOOL_ADDLOAD);" data-tooltip="Add Load"&gt;&lt;i class="material-icons"&gt;add_circle_outline&lt;/i&gt;&lt;/button&gt;
        &lt;div class="msketch-panel-btn-text"&gt;Add&lt;/div&gt;
        &lt;button class="msketch-panel-btn" id="btn_editload" onclick="interfaceSelect(TOOL_EDITLOAD);" data-tooltip="Edit Load"&gt;&lt;i class="material-icons"&gt;edit&lt;/i&gt;&lt;/button&gt;
        &lt;div class="msketch-panel-btn-text"&gt;Edit&lt;/div&gt;
        &lt;button class="msketch-panel-btn" id="btn_removeload" onclick="interfaceSelect(TOOL_REMOVELOAD);" data-tooltip="Remove Load"&gt;&lt;i class="material-icons"&gt;remove_circle_outline&lt;/i&gt;&lt;/button&gt;
        &lt;div class="msketch-panel-btn-text"&gt;Remove&lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Fx [N]" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_load_valueX" disabled&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="Fy [N]" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="panel_load_valueY" disabled&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;button class="msketch-panel-btn-large" id="panel_load_apply"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Apply&lt;/button&gt;
        &lt;button class="msketch-panel-btn-large" id="panel_load_download"&gt;&lt;i class="material-icons"&gt;file_download&lt;/i&gt;Download Load Data&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;&lt; load_panel_javascript &gt;&gt;
        
        &lt;div class="msketch-panel-container" id="panel_settings" style="display: none"&gt;
        &lt;div class="msketch-panel-title"&gt;Settings&lt;/div&gt;
        
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc" style="font-weight: 700"&gt;View&lt;/div&gt;
        &lt;label class="form-switch"&gt;
        &lt;input type="checkbox" id="setting_showGrid"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;Show Grid&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class="form-switch"&gt;
        &lt;input type="checkbox" id="setting_showText"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;Show Length Text&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class="form-switch"&gt;
        &lt;input type="checkbox" id="setting_showPlane"&gt;
        &lt;i class="form-icon"&gt;&lt;/i&gt; &lt;span class="msketch-panel-desc"&gt;Show Plane&lt;/span&gt;
        &lt;/label&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Grid Gap (mm)" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="setting_gridGap"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="Plane Size (mm)" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="setting_planeSize"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc" style="font-weight: 700"&gt;Part&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Hole Dia. (mm)" style="width: 100%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="setting_holeDiameter"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Link Width (mm)" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="setting_linkWidth"&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="Link Thickness (mm)" style="width: 49%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="setting_linkThickness"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-desc" style="font-weight: 700"&gt;System&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="msketch-panel-row"&gt;
        &lt;div class="msketch-panel-label" data-label="Max History Size" style="width: 100%;"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="setting_maxHistory"&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;button class="msketch-panel-btn-large" id="setting_apply"&gt;&lt;i class="material-icons"&gt;done&lt;/i&gt;Apply&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;&lt; setting_javascript &gt;&gt;
        
        &lt;div id="panel_close_btn"&gt;&lt;i class="material-icons"&gt;close&lt;/i&gt;&lt;/div&gt;
        &lt;/div&gt;
        
        &lt;&lt; panel_close_javascript &gt;&gt;
        
        &lt;div id="threejs_canvas"&gt;&lt;/div&gt;
        
        &lt;div class="msketch-message" id="msketch_message"&gt;&lt;/div&gt;
        
        &lt;&lt; show_message_javascript &gt;&gt;
        
        &lt;div class="msketch-dialog" id="dialog_newFile"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;New File&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;Remove all current assemblies and create new file.&lt;/div&gt;
        &lt;button class="msketch-dialog-btn" id="dialog_newFile_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_newFile').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_newFile"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;New File&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;Remove all current assemblies and create new file.&lt;/div&gt;
        &lt;button class="msketch-dialog-btn" id="dialog_newFile_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_newFile').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_openFile"&gt;
        &lt;div class="msketch-dialog-box" style="width: 600px"&gt;
        &lt;div class="msketch-dialog-header"&gt;Open File&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;Remove all assemblies and open existing file.&lt;/div&gt;
        &lt;div style="float: right;"&gt;
        &lt;button class="msketch-toolbar-btn" id="dialog_openFile_download" data-tooltip="Download"&gt;&lt;i class="material-icons"&gt;cloud_download&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="dialog_openFile_upload" data-tooltip="Upload"&gt;&lt;i class="material-icons"&gt;cloud_upload&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="dialog_openFile_rename" data-tooltip="Rename" style="display: none"&gt;&lt;i class="material-icons"&gt;title&lt;/i&gt;&lt;/button&gt;
        &lt;button class="msketch-toolbar-btn" id="dialog_openFile_delete" data-tooltip="Delete"&gt;&lt;i class="material-icons"&gt;delete&lt;/i&gt;&lt;/button&gt;
        &lt;/div&gt;
        
        &lt;select id="dialog_fileList" class="form-select msketch-dialog-select" name='files' size='10'&gt;
        &lt;/select&gt;
        
        &lt;button class="msketch-dialog-btn" id="dialog_openFile_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_openFile').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_uploadFile"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;Upload File&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;File Uploader&lt;/div&gt;
        
        &lt;input type=file id="dialog_uploadFile_file" class="form-input msketch-panel-input" /&gt;
        
        &lt;button class="msketch-dialog-btn" id="dialog_uploadFile_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_uploadFile').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_importPlane"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;Import Plane&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;Upload Plane File&lt;/div&gt;
        
        &lt;input type=file id="dialog_importPlane_file" class="form-input msketch-panel-input" /&gt;
        
        &lt;button class="msketch-dialog-btn" id="dialog_importPlane_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_importPlane').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_deleteFile"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;Delete File&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;File will be deleted: &lt;/div&gt;
        &lt;div class="msketch-dialog-text" id="dialog_deleteFile_fileName"&gt;Filename&lt;/div&gt;
        
        &lt;button class="msketch-dialog-btn" id="dialog_deleteFile_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_deleteFile').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_saveFile"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;Save File&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;Save file on M.Sketch server.&lt;/div&gt;
        &lt;div class="msketch-panel-label" data-label="File Name" style="width: 100%; margin-bottom: 12px"&gt;
        &lt;input class="form-input msketch-panel-input" type="text" id="dialog_save_filename"&gt;
        &lt;/div&gt;
        &lt;button class="msketch-dialog-btn" id="dialog_save_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_saveFile').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="msketch-dialog" id="dialog_pRemove"&gt;
        &lt;div class="msketch-dialog-box"&gt;
        &lt;div class="msketch-dialog-header"&gt;Remove Plane&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;Plane will be removed.&lt;/div&gt;
        
        &lt;button class="msketch-dialog-btn" id="dialog_pRemove_ok"&gt;OK&lt;/button&gt;
        &lt;button class="msketch-dialog-btn" onclick="$('#dialog_pRemove').hide();"&gt;Cancel&lt;/button&gt;
        &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div id="msketch_fileCache" style="display: none"&gt;&lt;/div&gt;
        
        &lt;&lt; dialog_javascript &gt;&gt;
        
        &lt;div class="msketch-dialog" id="msketch_about"&gt;
        &lt;div class="msketch-dialog-box" style="width: 600px"&gt;
        &lt;div class="msketch-login-logo"&gt;M.SKETCH&lt;/div&gt;
        &lt;div class="msketch-dialog-header" style="font-size: 18px"&gt;Version 3.0.180602 BETA&lt;/div&gt;
        &lt;div class="msketch-dialog-text"&gt;M.Sketch is a prototyping tool that supports non-experts to rapidly sketch, simulate a linkage-based mechanism, and transform it into a physical prototype. It provides intuitive interfaces for novice users without engineering knowledge and skills. M.Sketch has been developed as a Web-based computational design tool that is freely available on a public domain. It offers high device compatibility for PCs, tablets, and other mobile devices.&lt;/div&gt;
            &lt;div class="msketch-dialog-text" style="margin-bottom: 24px"&gt;&lt;b&gt;Authors&lt;/b&gt;&lt;br&gt;Han-Jong Kim, Yunwoo Jeong, Ju-Whan Kim, Tek-Jin Nam&lt;/div&gt;
                &lt;hr&gt;
                &lt;div class="msketch-dialog-text" style="font-size: 12px; font-style: italic"&gt;This research was supported by the EDISON Program through the National Research Foundation of Korea (NRF) funded by the Ministry of Science, ICT &amp; Future Planning (No.2014M3C1A6038802).&lt;/div&gt;
                &lt;button class="msketch-dialog-btn" onclick="$('#msketch_about').hide();"&gt;Close&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;&lt; included_javascript &gt;&gt;

    &lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="leo.20191210192811.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    #os.chdir("./../")
    server_address = ('localhost', 8445)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("8445 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
</t>
<t tx="leo.20191210194051.1">    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"&gt;
    
    &lt;title&gt;EDISON m.Sketch&lt;/title&gt;
    
    &lt;link rel="stylesheet" href="./public/style/spectre.css"&gt;
    &lt;link rel="stylesheet" href="./public/style/spectre-exp.css"&gt;
    &lt;link rel="stylesheet" href="./public/style/spectre-icons.css"&gt;
    
    &lt;link rel="stylesheet" href="./public/style/icon.css" /&gt;
    &lt;link rel="stylesheet" href="./public/style/style.css" type="text/css" /&gt;
    &lt;script src="./public/js/jquery.min.js"&gt;&lt;/script&gt;</t>
<t tx="leo.20191210194333.1">&lt;script src="./public/libs/three.min.85.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/OrbitControls.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/Projector.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/TransformControls.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/CanvasRenderer.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/jspdf.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/FileSaver.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/XMLWriter.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/csg.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/ThreeCSG.js"&gt;&lt;/script&gt;
&lt;script src="./public/libs/OBJExporter.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/common/subs.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/core/constraints/Constraint.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/constraints/AngularConstraint.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/constraints/CoaxialConstraint.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/constraints/SliderConstraint.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/core/assembly/Assembly.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/assembly/LinkageGroup.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/assembly/MechanismCalculator.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/core/elements/MechElement.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/elements/Link.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/elements/Space.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/elements/JointActuator.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/elements/Trajectory.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/elements/Gear.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/elements/Load.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/core/threejs/AssemblyGroup.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/threejs/3DElements.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/threejs/ThreeSetup.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/core/interface/EventHandlers.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/interface/ToolSelect.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/interface/MouseInterface.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/interface/UndoAndRedo.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/core/io/FileIO.js"&gt;&lt;/script&gt;
&lt;script src="./public/js/core/io/ExportDrawing.js"&gt;&lt;/script&gt;

&lt;script src="./public/js/main.js"&gt;&lt;/script&gt;
</t>
<t tx="leo.20191210194620.1">&lt;script&gt;
var firstSaved = false;
/* for dialog */
function showDialog(_id){
switch (_id) {
case TOOL_NEWFILE:
$('#dialog_newFile').show();
break;
case TOOL_PREMOVE:
$('#dialog_pRemove').show();
break;
case TOOL_SAVE:
if(!firstSaved){
$('#dialog_saveFile').show();
$('#dialog_save_filename').val( $('#msketch-titlebar-filename').val() );
}else{
saveFileIntoDB( $('#msketch-titlebar-filename').val() )
}
break;
case TOOL_OPEN:
$.ajax({
url: '/loadFile',
method: 'post',
data: {},
success: function (data) {
$('#dialog_fileList').empty();
$.each(data.list, function (i, item) {
        $('#dialog_fileList').append($('&lt;option&gt;', {
            value: item,
            text : item
        }));
    });
    //console.log(data.list);
},
error: function (err) {
    showMessage("File list load failed");
}
});
$('#dialog_openFile').show();
break;
case TOOL_IMPORT:
$('#dialog_importPlane').show();
break;
}
}

$('#dialog_newFile_ok').click(function(){
interfaceSelect(TOOL_NEWFILE);
$('#dialog_newFile').hide();
});

$('#dialog_pRemove_ok').click(function(){
interfaceSelect(TOOL_PREMOVE);
$('#dialog_pRemove').hide();
});

// OPEN DIALOG
$('#dialog_openFile_ok').click(function(){
console.log($('#dialog_fileList').val());
if($('#dialog_fileList').val()==null){
showMessage("No file selected.")
}else{
$.ajax({
url: '/openFile',
method: 'post',
data: {fileName: $('#dialog_fileList').val()},
success: function (data) {
if(isPlaying)	interfaceSelect(TOOL_RUN);
loadMsketchInfo(data.file, true);
$('#msketch-titlebar-filename').val(data.name.replace(".json", ""));
firstSaved = false;
closeDrawer();
},
error: function (err) {
showMessage("Open failed");
}
});
}

$('#dialog_openFile').hide();
});

$('#dialog_openFile_download').click(function(){
if($('#dialog_fileList').val()==null){
showMessage("No file selected.");
}else{
$.ajax({
url: '/openFile',
method: 'post',
data: {fileName: $('#dialog_fileList').val()},
success: function (data) {
saveAsText(data.name, data.file);
closeDrawer();
},
error: function (err) {
showMessage("Save failed");
}
});
}
});

$('#dialog_openFile_upload').click(function(){
$('#dialog_uploadFile').show();
});

$('#dialog_uploadFile_ok').click(function(){
var _file = $('#dialog_uploadFile_file')[0].files[0];
var _reader = new FileReader();
var _fileName = null;
_reader.addEventListener("load", function() {

$.ajax({
url: '/save',
method: 'post',
data: {
fileName: _fileName.replace(".json", ""),
file: _reader.result
},
success: function (data) {
showMessage("File was uploaded.");

$.ajax({
    url: '/loadFile',
    method: 'post',
    data: {},
    success: function (data) {
        $('#dialog_fileList').empty();
        $.each(data.list, function (i, item) {
                $('#dialog_fileList').append($('&lt;option&gt;', {
                    value: item,
                    text : item
                }));
            });
            //console.log(data.list);
        },
        error: function (err) {
            showMessage("File list load failed");
        }
    });
},
error: function (err) {
    showMessage("Save failed");
}
});


}, false);

if (_file) {
_fileName = _file.name;
_reader.readAsText(_file);
}

$('#dialog_uploadFile').hide();
});


$('#dialog_openFile_rename').click(function(){

});

$('#dialog_openFile_delete').click(function(){
if($('#dialog_fileList').val()==null){
showMessage("No file selected.")
}else{
$('#dialog_deleteFile').show();
$('#dialog_deleteFile_fileName').text( $('#dialog_fileList').val() )
}
});

$('#dialog_deleteFile_ok').click(function(){

$.ajax({
url: '/deleteFile',
method: 'post',
data: {fileName: $('#dialog_fileList').val()},
success: function (data) {
$('#dialog_fileList').empty();
$.each(data.list, function (i, item) {
        $('#dialog_fileList').append($('&lt;option&gt;', {
            value: item,
            text : item
        }));
    });
    $('#dialog_deleteFile').hide();
},
error: function (err) {
    showMessage("Delete failed");
}
});
});

$('#dialog_importPlane_ok').click(function(){
var _file = $('#dialog_importPlane_file')[0].files[0];
var _reader = new FileReader();

_reader.addEventListener("load", function() {
var _data = JSON.parse(_reader.result);

//check header
if(_data.app != "EDISON" || _data.type != "Sketch"){
    showMessage("Wrong File");
    return null;
}

loadMsketchInfoForPlane(_data.sketch, true);
}, false);

if (_file) {
_reader.readAsText(_file);
}

$('#dialog_importPlane').hide();
})

//SAVE DIALOG

$('#dialog_save_ok').click(function(){
$('#dialog_saveFile').hide();
saveFileIntoDB( $('#dialog_save_filename').val() );
});


function saveFileIntoDB(_fileName){
if(isPlaying)	interfaceSelect(TOOL_RUN);

var _fileData = getMsketchInfo();

$.ajax({
url: '/save',
method: 'post',
data: {
    fileName: _fileName,
    file: _fileData
},
success: function (data) {
    showMessage("File was saved.");
    firstSaved = true;
},
error: function (err) {
    showMessage("Save failed");
}
});

closeDrawer();
}
&lt;/script&gt;
</t>
<t tx="leo.20191210195941.1">&lt;script&gt;
// === Postion Panel ===
$('#panel_move_sbGrid').on('change', function(){
    if( $("#panel_move_sbGrid").prop("checked") ){
        isScienceBoxSanpOn = true;
        currentAssemblyGroup.showSBGrid();
    }else{
        isScienceBoxSanpOn = false;
        currentAssemblyGroup.hideSBGrid();
    }
});

$('#panel_move_sbSnap').on('change', function(){
    if( $("#panel_move_sbSnap").prop("checked") ){
        isScienceBoxLinkOn = true;
    }else{
        isScienceBoxLinkOn = false;
    }
});

$('#panel_move_apply').click( function(){
    applyMove();
    applyLength();
});

$('#panel_move').keyup(function(event){
    if (event.keyCode == 13) {
        applyMove();
        applyLength();
    }
});

var prevPosition 	= [];
var prevPointPair 	= null;

function getPointInfoToMovePanel(){
    if(!(toolState==TOOL_MOVE)) return;
    
    if(selectedPoint!=null){
        $('#panel_move_x').prop('disabled', false);
        $('#panel_move_y').prop('disabled', false);
        $('#panel_move_length').prop('disabled', true);

        $('#panel_move_x').val( (selectedPoint.x*SCALE_TRANS).toFixed(2) );
        $('#panel_move_y').val( (selectedPoint.y*SCALE_TRANS).toFixed(2) );
        $('#panel_move_length').val( null );

        prevPosition[0] = selectedPoint.x;
        prevPosition[1] = selectedPoint.y;
        selectedPoint = null;
        prevPointPair = null;
    }

    // for length
    if(selectedPointPair!=null &amp;&amp; prevPointPair!=selectedPointPair){
        $('#panel_move_x').prop('disabled', true);
        $('#panel_move_y').prop('disabled', true);
        $('#panel_move_length').prop('disabled', false);

        var _length = selectedPointPair[0].distance(selectedPointPair[1].getX(), selectedPointPair[1].getY());

        $('#panel_move_x').val( null );
        $('#panel_move_y').val( null );
        $('#panel_move_length').val( (_length*SCALE_TRANS).toFixed(2) );

        prevPointPair = selectedPointPair;
        selectedPoint = null;
        currentAssemblyGroup.setSegmentSelected(selectedLink, selectedPointPair);
    }

    if(selectedPointTg==null){
        prevPosition[0] = null;
        prevPosition[1] = null;
    }

    if(selectedPointPair==null){
        selectedLink = null;
        prevPointPair = null;
    }
} // function getPointInfoToMovePanel

function applyMove(){
    if(selectedPointTg==null) return;

    var newPosX = parseFloat($('#panel_move_x').val())/SCALE_TRANS;
    var newPosY = parseFloat($('#panel_move_y').val())/SCALE_TRANS;
    if(!isNaN(newPosX) &amp;&amp; !isNaN(newPosY)){
        currentInterface.mouseMove(prevPosition[0], prevPosition[1]);
        currentInterface.mouseDown(prevPosition[0], prevPosition[1]);
        currentInterface.mouseDownAndMoveFirst(prevPosition[0], prevPosition[1]);
        currentInterface.mouseDownAndMove(newPosX, newPosY);
        currentInterface.mouseMoveAndUp(newPosX, newPosY);
    }
} // function applyMove

function applyLength(){
    if(selectedLink==null || selectedPointPair==null) return;

    var newLength = parseFloat($('#panel_move_length').val())/SCALE_TRANS;

    setLengthToLink(selectedLink, selectedPointPair[0], selectedPointPair[1], newLength);
    currentAssemblyGroup.setSegmentSelected(selectedLink, selectedPointPair);
} // function applyLength

&lt;/script&gt;</t>
<t tx="leo.20191210200043.1">&lt;script&gt;
$('#panel_plane_apply').click( function(){
    applyPlane();
});

$('#panel_plane').keyup(function(event){
    if (event.keyCode == 13) {
        applyPlane();
    }
});

$('#panel_plane_flipHor').click( function(){
    planeData = currentAssemblyGroup.getPositionData();
    planeData.ry = planeData.ry + Math.PI;
    currentAssemblyGroup.setPositionData(planeData);
});
$('#panel_plane_flipVert').click( function(){
    planeData = currentAssemblyGroup.getPositionData();
    planeData.rx = planeData.rx + Math.PI;
    currentAssemblyGroup.setPositionData(planeData);
});

function getPlaneInfoToPlanePanel(){
    //if(!(toolState==TOOL_PTRANS || toolState==TOOL_PROT)) return;

    planeData = currentAssemblyGroup.getPositionData();

    $('#panel_plane_tx').val( (planeData.tx*SCALE_TRANS).toFixed(2) );
    $('#panel_plane_ty').val( (planeData.ty*SCALE_TRANS).toFixed(2) );
    $('#panel_plane_tz').val( (planeData.tz*SCALE_TRANS).toFixed(2) );
    $('#panel_plane_rx').val( Math.degrees(planeData.rx).toFixed(2) );
    $('#panel_plane_ry').val( Math.degrees(planeData.ry).toFixed(2) );
    $('#panel_plane_rz').val( Math.degrees(planeData.rz).toFixed(2) );
}

function applyPlane(){
    var tempData = {};
    tempData.tx = (parseFloat($('#panel_plane_tx').val())/SCALE_TRANS);
    tempData.ty = (parseFloat($('#panel_plane_ty').val())/SCALE_TRANS);
    tempData.tz = (parseFloat($('#panel_plane_tz').val())/SCALE_TRANS);
    tempData.rx = Math.radians(parseFloat($('#panel_plane_rx').val()));
    tempData.ry = Math.radians(parseFloat($('#panel_plane_ry').val()));
    tempData.rz = Math.radians(parseFloat($('#panel_plane_rz').val()));
    currentAssemblyGroup.setPositionData(tempData);
 }

&lt;/script&gt;</t>
<t tx="leo.20191210200159.1">&lt;script&gt;
$('#motor_gspeed_txt').on('change', function(){
    motorSpeed = Math.radians( parseInt( $(this).val() ) );
    $('#motor_gspeed_slider').val( $(this).val() );
});

$('#motor_gspeed_slider').on('input change', function(){
    motorSpeed = Math.radians( parseInt( $(this).val() ) );
    $('#motor_gspeed_txt').val( $(this).val() );
});

$('#motor_list').on('mousedown', function(){
    updateMotorList();
});

$('#motor_list').on('change', function(){
    updateMotorInfo();
});

$('#motor_type_dc').on('change', function(){
    if($(this).prop('checked')){
        pointedActuator.setDC();
        updateMotorInfo();
        try360forAssemblies();
    }
});

$('#motor_type_servo').on('change', function(){
    if($(this).prop('checked')){
        pointedActuator.setServo();
        updateMotorInfo();
        try360forAssemblies();
    }
});

$('#motor_phase_txt').on('change', function(){
    pointedActuator.setPhase(Math.radians(parseInt($(this).val())));
if(pointedActuator.isServo) applyActuator(pointedActuator, parseInt( $(this).val() ) + parseInt( $("#motor_min_txt").val() ));
    else applyActuator(pointedActuator, $(this).val());
    $('#motor_phase_slider').val( $(this).val() );
});

$('#motor_phase_slider').on('input change', function(){
    pointedActuator.setPhase(Math.radians(parseInt($(this).val())));
    if(pointedActuator.isServo) applyActuator(pointedActuator, parseInt( $(this).val() ) + parseInt( $("#motor_min_txt").val() ));
    else applyActuator(pointedActuator, $(this).val());
    $('#motor_phase_txt').val( $(this).val() );
});

$('#motor_speed_txt').on('change', function(){
    pointedActuator.setSpeedMultiply(parseInt( $(this).val() ) / 100);
$('#motor_speed_slider').val( $(this).val() );
});

$('#motor_speed_slider').on('input change', function(){
    pointedActuator.setSpeedMultiply(parseInt( $(this).val() ) / 100);
$('#motor_speed_txt').val( $(this).val() );
});

$('#motor_min_txt').on('change', function(){
    pointedActuator.setStartAngle(Math.radians(parseInt( $(this).val() )));
    applyActuator(pointedActuator, parseInt( $(this).val() ) + parseInt( $("#motor_phase_txt").val() ));
    $('#motor_min_slider').val( $(this).val() );
});

$('#motor_min_slider').on('input change', function(){
    pointedActuator.setStartAngle(Math.radians(parseInt( $(this).val() )));
    applyActuator(pointedActuator, parseInt( $(this).val() ) + parseInt( $("#motor_phase_txt").val() ));
$('#motor_min_txt').val( $(this).val() );
});

$('#motor_max_txt').on('change', function(){
    pointedActuator.setEndAngle(Math.radians(parseInt( $(this).val() )));
    applyActuator(pointedActuator, parseInt( $("#motor_min_txt").val() ) + parseInt( $("#motor_phase_txt").val() ));
$('#motor_max_slider').val( $(this).val() );
});

$('#motor_max_slider').on('input change', function(){
    pointedActuator.setEndAngle(Math.radians(parseInt( $(this).val() )));
    applyActuator(pointedActuator, parseInt( $("#motor_min_txt").val() ) + parseInt( $("#motor_phase_txt").val() ));
    $('#motor_max_txt').val( $(this).val() );
});


$('#motor_reverse').on('change', function(){
    pointedActuator.setReverse( $(this).prop('checked') );
})


function updateMotorList(){
    $('#motor_list').empty();
    $.each(getActuatorName(), function (i, item) {
        $('#motor_list').append($('&lt;option&gt;', {
            value: i,
            text : item
        }));
    });
    $('#motor_list').val(null);

    $('.motor-both').addClass('disableClick');
    $('.motor-servo').addClass('disableClick');
    $('.motor-dc').addClass('disableClick');
}

function updateMotorInfo(){
    var a = null;
    var _motorType = 0;
    
    var _selectedIndex = parseInt( $('#motor_list').val() );


    if (_selectedIndex != -1) {
        a = findJAfromName( $('#motor_list option:selected').text() );
    }

    if (a == null) {
        showMessage("Motor not found.")
        // close other panel
    return;
    } else {
    if (!a.isServo) _motorType = 0;
    else _motorType = 1;
    pointedActuator = a;
    }

    // Show motor selection
    $('.motor-both').removeClass('disableClick');

    // get motor type
    if(_motorType == 0){
        $('#motor_type_dc').prop('checked', true);
        $('#motor_type_servo').prop('checked', false);
        $('.motor-servo').addClass('disableClick')
        $('.motor-dc').removeClass('disableClick');
    }else{
        $('#motor_type_dc').prop('checked', false);
        $('#motor_type_servo').prop('checked', true);
        $('.motor-dc').addClass('disableClick')
        $('.motor-servo').removeClass('disableClick');
    }

    $('#motor_phase_txt').val( Math.round(Math.degrees(a.getPhase())) );
    $('#motor_speed_txt').val( Math.round(a.getSpeedMultiply() * 100) );
    $('#motor_min_txt').val( Math.round(Math.degrees(a.getStartAngle())) );
    $('#motor_max_txt').val( Math.round(Math.degrees(a.getEndAngle())) );

    if(a.getReverse()) $('#motor_reverse').prop('checked', true);
    else $('#motor_reverse').prop('checked', false);

    $('#motor_phase_slider').val( $('#motor_phase_txt').val() );
    $('#motor_speed_slider').val( $('#motor_speed_txt').val() );
    $('#motor_min_slider').val( $('#motor_min_txt').val() );
    $('#motor_max_slider').val( $('#motor_max_txt').val() );
}

function getActuatorName() {
    var returnValue = [];

for (i = 0; i &lt; AssemblyGroupList.length; i++) {
    var _actuatorList = AssemblyGroupList[i].assembly.getAllActuator();

    if (_actuatorList != null) {
        for (var ai in _actuatorList.array) {
            var a = _actuatorList.get(ai);
            if (a instanceof JointActuator) {
                returnValue.push(a.getName() + " on Plane" + i);
            }
        }
    }
}

    return returnValue;
}

function findJAfromName(_fullName) {
    if (_fullName == '' || _fullName == null) return null;
    
    _name = _fullName.split(" on Plane")[0]
    _index = parseInt(_fullName.split(" on Plane")[1]);
    
    var _actuatorList = AssemblyGroupList[_index].assembly.getAllActuator();

    if (_actuatorList != null) {
        for (var ai in _actuatorList.array) {
            var a = _actuatorList.get(ai);
            if (a instanceof JointActuator) {
                if (a.getName() == _name) return a;
            }
        }
    }

    return null;
}

function applyActuator(_a, _value) {
    _a.setValue(Math.radians(parseInt(_value)));
    for (var i = 0; i &lt; AssemblyGroupList.length; i++) {
        var _actuatorList = AssemblyGroupList[i].assembly.getAllActuator();
    
        if (_actuatorList.contains(_a)) {
            AssemblyGroupList[i].calculateAssembly();
        }
    }
    try360forAssemblies();
    currentAssemblyGroup.removeSegmentSelected();
}

&lt;/script&gt;</t>
<t tx="leo.20191210200305.1">&lt;script&gt;
$('#panel_pattern_apply').click( function(){
createPattern();
});
$('#panel_pattern_angle').on('change keyup paste', function(){
setPatternAmount();
})

function setPatternAmount(){
if( $('#panel_pattern_angle').val() == "" || $('#panel_pattern_angle').val() == null ){
$('#panel_pattern_amount').val( null );
}else{
$('#panel_pattern_amount').val( parseInt( 360/parseFloat( $('#panel_pattern_angle').val() ) ) );
}
}

function getSelectedAxis(){
if( $('#panel_pattern_x').prop('checked') ){
return 'x';
}
else if( $('#panel_pattern_y').prop('checked') ){
return 'y';
}
else if( $('#panel_pattern_z').prop('checked') ){
return 'z';
}

return null;
}


function createPattern(){

if( $('#panel_pattern_angle').val() == "" || $('#panel_pattern_angle').val() == null ||
$('#panel_pattern_amount').val() == "" || $('#panel_pattern_amount').val() == null ) return false;

if(isPlaying)	interfaceSelect(TOOL_RUN);

// get Axis
var selectedAxis = getSelectedAxis();


var patternAmount = parseInt( $('#panel_pattern_amount').val() );

var _data = getMsketchInfoForPlane();

for(var i=1; i&lt;patternAmount; i++){

var _dataJSON = JSON.parse(_data);

var _dist, _startAngle, _rotatedAngle;
var _x = parseFloat( _dataJSON.sketch.plane.translation.x ),
_y = parseFloat( _dataJSON.sketch.plane.translation.y ),
_z = parseFloat( _dataJSON.sketch.plane.translation.z ),
_rx = parseFloat( _dataJSON.sketch.plane.rotation.x ),
_ry = parseFloat( _dataJSON.sketch.plane.rotation.y ),
_rz = parseFloat( _dataJSON.sketch.plane.rotation.z );

var _stepAngle = Math.radians( parseFloat( $('#panel_pattern_angle').val() ) );

switch(selectedAxis){
case 'x':
_dist = Math.sqrt((_y)*(_y) + (_z)*(_z));
_startAngle = Math.atan2(_z, _y);
_rotatedAngle = rotateAroundWorldAxis(new THREE.Vector3(1,0,0), _stepAngle*i,
Math.radians(_rx), Math.radians(_ry), Math.radians(_rz));

_dataJSON.sketch.plane.translation.x = _x;
_dataJSON.sketch.plane.translation.y = _dist*Math.cos(_startAngle+_stepAngle*i);
_dataJSON.sketch.plane.translation.z = _dist*Math.sin(_startAngle+_stepAngle*i);
_dataJSON.sketch.plane.rotation.x = Math.degrees( _rotatedAngle[0] );
_dataJSON.sketch.plane.rotation.y = Math.degrees( _rotatedAngle[1] );
_dataJSON.sketch.plane.rotation.z = Math.degrees( _rotatedAngle[2] );

break;
case 'y':
_dist = Math.sqrt((_x)*(_x) + (_z)*(_z));
_startAngle = Math.atan2(_z, _x);
_rotatedAngle = rotateAroundWorldAxis(new THREE.Vector3(0,1,0), -_stepAngle*i,
Math.radians(_rx), Math.radians(_ry), Math.radians(_rz));

_dataJSON.sketch.plane.translation.x = _dist*Math.cos(_startAngle+_stepAngle*i);
_dataJSON.sketch.plane.translation.y = _y;
_dataJSON.sketch.plane.translation.z = _dist*Math.sin(_startAngle+_stepAngle*i);
_dataJSON.sketch.plane.rotation.x = Math.degrees( _rotatedAngle[0] );
_dataJSON.sketch.plane.rotation.y = Math.degrees( _rotatedAngle[1] );
_dataJSON.sketch.plane.rotation.z = Math.degrees( _rotatedAngle[2] );
break;
case 'z':
_dist = Math.sqrt((_x)*(_x) + (_y)*(_y));
_startAngle = Math.atan2(_y, _x);
_rotatedAngle = rotateAroundWorldAxis(new THREE.Vector3(0,0,1), _stepAngle*i,
Math.radians(_rx), Math.radians(_ry), Math.radians(_rz));
_dataJSON.sketch.plane.translation.x = _dist*Math.cos(_startAngle+_stepAngle*i);
_dataJSON.sketch.plane.translation.y = _dist*Math.sin(_startAngle+_stepAngle*i);
_dataJSON.sketch.plane.translation.z = _z;
_dataJSON.sketch.plane.rotation.x = Math.degrees( _rotatedAngle[0] );
_dataJSON.sketch.plane.rotation.y = Math.degrees( _rotatedAngle[1] );
_dataJSON.sketch.plane.rotation.z = Math.degrees( _rotatedAngle[2] );
break;
}
importPlaneInfo( JSON.stringify(_dataJSON) , true);
}
checkHistory();

}

function rotateAroundWorldAxis(axis, angle, _x, _y, _z) {
var object = new THREE.Object3D();
object.rotation.x = _x;
object.rotation.y = _y;
object.rotation.z = _z;

var q = new THREE.Quaternion();
q.setFromAxisAngle( axis, angle ); // axis must be normalized, angle in radians
object.quaternion.multiplyQuaternions( q, object.quaternion );
return [object.rotation.x, object.rotation.y, object.rotation.z];
}


&lt;/script&gt;</t>
<t tx="leo.20191210200440.1">&lt;script&gt;
var TRAJECTORY_COLORS = ['#671eac', '#E94F35', '#2ACA6B', '#F4C300', '#438CDE'];
var TRAJECTORY_COLORS_THREE = [0x671eac, 0xE94F35, 0x2ACA6B, 0xF4C300, 0x438CDE];

$('#panel_analysis_run').click( function(){
    runAnalysis();
    showMessage("Analysis started.");
});

$('#panel_analysis_stop').click( function(){
    stopAnalysis();
    showMessage("Analysis stopped.");
});


function getAnalysisInfo(){ // called in main.js actuate();
    if(!isAnalysisOn) return;
    
    var tCount = 0;
    
    $('#panel_analysis_result').empty();

for(i=0; i&lt;AssemblyGroupList.length; i++){
    var _trajectoryList = AssemblyGroupList[i].getTrajectory();
    if(_trajectoryList==null) return;
        for(var ti in _trajectoryList.array){
            var t = _trajectoryList.get(ti);
    
            AssemblyGroupList[i].trajectoryObjList[ti].setColor(TRAJECTORY_COLORS_THREE[tCount%TRAJECTORY_COLORS_THREE.length]);
    
            $('#panel_analysis_result').append('&lt;div class="panel-analysis-result-container"&gt;'
            + '&lt;div class="msketch-panel-desc" style="width: 15%;"&gt;&lt;div class="panel-analysis-bullet" style="background-color: ' + TRAJECTORY_COLORS[tCount%TRAJECTORY_COLORS.length] + '"&gt;&lt;/div&gt;&lt;/div&gt;'
            + '&lt;div class="msketch-panel-desc" style="width: 40%;"&gt;' + (parseFloat(groundInfo(t)[0])*SCALE_TRANS).toFixed(3)     + ' mm &lt;/div&gt;'
            + '&lt;div class="msketch-panel-desc" style="width: 40%;"&gt;' + parseFloat(groundInfo(t)[1]).toFixed(3)                   + '&lt;/div&gt;&lt;/div&gt;'
            )
    
            tCount++;
        }
    }
}

function runAnalysis(){
    if(isPlaying){
        interfaceSelect(TOOL_RUN);
    }
    isAnalysisOn = true;
    interfaceSelect(TOOL_RUN);
}

function stopAnalysis(){
    isAnalysisOn = false;
    if(isPlaying){
        interfaceSelect(TOOL_RUN);
    }
}


function groundInfo(_trajectoryObject){
    var groundLength;
    var groundAngleCo;
    var returnValue = new Array();
    
    var _tan 	= [];
    var _angle 	= [];
    var _x 		= [];
    var _y 		= [];
    //var _pm		= [];	//*	Not used in this version

    var inputTrajectory = _trajectoryObject.getTrajectoryOneCycle();
    //inputTrajectory.splice(0,1);
    
    //* Parsing "angle/x/y" from the Trajectory.trajectoryOneCycle [elements/Trajectory.js]
    for(var j=0; j&lt;inputTrajectory.length; j++){
        var res = inputTrajectory[j].split('/');
        _angle.push(res[0]);
        _x.push(res[1]);
        _y.push(res[2]);
    }

    var tempTan = (_y[2]-_y[1])/(_x[2]-_x[1]);

    for(var j=0; j&lt;inputTrajectory.length-1; j++){
        _tan.push((_y[j+1]-_y[j])/(_x[j+1]-_x[j]));
    
        if(tempTan &lt; ( (_y[j+1] - _y[j]) / (_x[j+1] - _x[j]) ) ){
            tempTan=(_y[j+1] - _y[j]) / (_x[j+1] - _x[j]);
        }
    }


    var tempno	= _tan.indexOf(tempTan);
    var tanup 	= _tan.slice(0,tempno);
    var tandown = _tan.slice(tempno,_tan.length+1);
    var newtan 	= tandown.concat(tanup);
    
    var aup 	= _angle.slice(0,tempno);
    var adown 	= _angle.slice(tempno,_angle.length+1);
    var newa 	= adown.concat(aup);
    
    var xup 	= _x.slice(0,tempno);
    var xdown 	= _x.slice(tempno,_x.length+1);
    var newx 	= xdown.concat(xup);

    var yup 	= _y.slice(0,tempno);
    var ydown 	= _y.slice(tempno,_y.length+1);
    var newy 	= ydown.concat(yup);

    /*	Not used in this version
    for(var j=0; j&lt;_tan.length-1; j++){
        _pm.push((_tan[j+1]-_tan[j])/(_x[j+2]-_x[j]));
    }
    */

    //var start;
    //var stop;
    var part	= [];
    var arrno	= 0;
    var countt	= 0;

    for(var j=1; j&lt;newtan.length-1; j++){
        if(Math.abs(newtan[j])&lt;0.2679){
            if(countt==0){
                var tt=[];
                part.push(tt);
                countt++;
            }
            part[arrno].push(j);
        }else{
            if(countt!=0){
                countt=0;
                arrno++;
            }
        }
    }

    var yval=[];

    for(var qq=0; qq&lt;part.length; qq++){
        var ytemp=newy[part[qq][0]];
        for(var pp=1; pp&lt;part[qq].length; pp++){
            if(ytemp&lt;newy[part[qq][pp]]){
                ytemp=newy[part[qq][pp]];
            }
        }
        yval.push(ytemp);
    }

    var minval		= Math.min.apply(null, yval);
    var minindex	= yval.indexOf(minval.toString());
    var lengthtemp	= 0.0;

    if(part[minindex]!=null){
        for(var c=0; c&lt;part[minindex].length-1; c++){
            var tempxx1	= newx[part[minindex][c]];
            tempxx1*=1;
        
            var tempxx2	= newx[part[minindex][c+1]];
            tempxx2*=1;
        
            var tempyy1 = newy[part[minindex][c]];
            tempyy1*=1;
        
            var tempyy2 = newy[part[minindex][c+1]];
            tempyy2*=1;
        
            var tempxx=(tempxx1-tempxx2);
            //var tempyy=(tempyy1-tempyy2);
            //var sum = (tempxx*tempxx)+(tempyy*tempyy);
            //sum = Math.sqrt(sum);
            lengthtemp+=tempxx;
        }
    }

    //======================== OUTPUT 1: Ground Length ===============================
    groundLength = Math.abs(lengthtemp); // groundLength = lengthtemp;
    //================================================================================
    
    var temp_angle=[];
    var angletemp=[];
    var temp_angleOut = 0;

    if(part[minindex]!=null){
        for(var d=0;d&lt;part[minindex].length;d++){
            var temp_angle1=newa[part[minindex][d]];
            temp_angle1*=1;
            temp_angle.push(temp_angle1);
        }
    }

    if(temp_angle.length&gt;0){
        temp_angleOut=(temp_angle[temp_angle.length-1]-temp_angle[0]);
    
        if(temp_angleOut&lt;0){
            temp_angleOut+=2*Math.PI;
        }
    }
    var angletemp=temp_angleOut/(2*Math.PI);

    //==================== OUTPUT 2: Ground Angle Coefficient ========================
    groundAngleCo=angletemp;
    //================================================================================
    
    returnValue.push(groundLength);
    returnValue.push(groundAngleCo);
    
    return returnValue;
}

&lt;/script&gt;</t>
<t tx="leo.20191210200603.1">&lt;script&gt;

    var baseTrjObject = null;
    var baseTrjInd = null;

$('#panel_opt_run').click( function(){
    startPathOptimize();
});

$('#panel_opt_stop').click( function(){
    stopPathOptimize();
});

$('#panel_opt_draw').click( function(){
    if(toolState!=TOOL_OPT){
        toolState = TOOL_OPT;
    }
    else if(toolState==TOOL_OPT){
    toolState = -1;
    }
    setTool(toolState);
    checkToolSet();
});

$('#panel_opt_remove').click( function(){
    currentAssemblyGroup.optimizedPath.flush();
    currentAssemblyGroup.load();
});

$('#panel_opt_markerIndex').on('mousedown', function(){
    $('#panel_opt_markerIndex').empty();
    $.each(currentAssemblyGroup.trajectoryObjList, function (i, item) {
        $('#panel_opt_markerIndex').append($('&lt;option&gt;', {
            value: i,
            text : "Trajectory " + i
        }));
    });
    $('#panel_opt_markerIndex').val(null);
});

$('#panel_opt_markerIndex').on('change', function(){
    checkBaseTrj(true);
});


function checkBaseTrj(_flag){
if($('#panel_opt_markerIndex').val()==null) return;

    baseTrjObject = currentAssemblyGroup.trajectoryObjList[parseInt( $('#panel_opt_markerIndex').val() )];
    baseTrjInd = parseInt( $('#panel_opt_markerIndex').val() );
if(baseTrjObject==null) return;

    for(var i=0; i&lt;currentAssemblyGroup.trajectoryObjList.length; i++){
        if(_flag &amp;&amp; baseTrjObject == currentAssemblyGroup.trajectoryObjList[i]){
            currentAssemblyGroup.trajectoryObjList[i].setColor(0x4bb7ba);
        }else{
            currentAssemblyGroup.trajectoryObjList[i].setColor(0x6a3fc4);
        }
    }
}

function flushAllTargetTrj(){
    for(var i=0; i&lt;AssemblyGroupList.length; i++){
        AssemblyGroupList[i].optimizedPath.flush();
    }
}

function startPathOptimize(){

if(baseTrjObject == null || baseTrjInd == null){
    showMessage("No base trajectory to optimize.");
    return;
}

if(currentAssemblyGroup.optimizedPath.getTrajectory() == null){
    showMessage("No base trajectory to optimize.");
    return;
}

for(var i=0; i&lt;AssemblyGroupList.length; i++){
    AssemblyGroupList[i].hideText();
}

    currentInterface.ind = baseTrjInd;
    currentInterface.Lambda = 5;
    currentInterface.targetTrj = resample(currentAssemblyGroup.optimizedPath.getTrajectory(), OptInterface.SAMPLE_SIZE);
    currentInterface.total_iter = 0;
    currentInterface.accumTime = 0;
    isPathOptimizing = true;

showMessage("Path optimization started.");
}

function stopPathOptimize(){
    if(isPathOptimizing) showMessage("Path optimization finished.");
    isPathOptimizing = false;
    //currentInterface.ind = -1;

    for(var i=0; i&lt;AssemblyGroupList.length; i++){
        AssemblyGroupList[i].showText();
    }
}

function showOptMsg(_msg){
    $('#panel_opt_msg').text(_msg);
}


// === OPT CORE ===

// for optimization
function optimize() {
    if (currentInterface.ind==-1) return;
    
    var iter=0;
    var isBroken = false;
    var preAvgGrd = Number.POSITIVE_INFINITY;
    
    var Epsilon = 0.001;
    //var Epsilon = 0.0005;

    var TIME_OUT = 20;
    
    var targetTrj = currentInterface.targetTrj;
    var cost=getDistScore(currentInterface.ind, targetTrj);
    var prevCost=cost*2;
    var STOP_COST_RATIO = 0.0001;

    // Point2D[] targetTrj = resample(t.getTrajectory(), SAMPLE_SIZE);
    
    var currentTime = new Date().getTime();
while ((currentTime+TIME_OUT &gt; (new Date().getTime()) &amp;&amp; !isBroken &amp;&amp; prevCost&gt;cost*STOP_COST_RATIO) || iter&lt;2) {
    var pointBackup = new ArrayList();
    var pointMap = new Object();

    // calc gradient //
    prevCost = cost;
    for (var i=0, _length = currentAssembly.getAllElement().length(); i&lt;_length; i++) {
        if (currentAssembly.getAllElement().get(i) instanceof Link ) { // &amp;&amp; !(assembly.getAllElement().get(i) instanceof Space //
            var l = currentAssembly.getAllElement().get(i);
        
            for (var j=0, _linkLength = l.getPointList().length(); j&lt;_linkLength; j++) {
                var pt = l.getPointList().get(j);
                var opt = new Point2D( pt.getX(), pt.getY() );
                pointBackup.add(opt);
            
                pt.setLocation(opt.getX()-Epsilon, opt.getY());
                var n_dist = getDistScore(currentInterface.ind, targetTrj);
                pt.setLocation(opt.getX()+Epsilon, opt.getY());
                var p_dist = getDistScore(currentInterface.ind, targetTrj);
            
                var deltaX = 0;
                if (n_dist+p_dist &lt; Number.POSITIVE_INFINITY) {
                    deltaX = (p_dist-n_dist)/2/Epsilon;
                }
            
                pt.setLocation(opt.getX(), opt.getY()-Epsilon);
                n_dist = getDistScore(currentInterface.ind, targetTrj);
                pt.setLocation(opt.getX(), opt.getY()+Epsilon);
                p_dist = getDistScore(currentInterface.ind, targetTrj);
            
                var deltaY = 0;
                if (n_dist+p_dist &lt; Number.POSITIVE_INFINITY) {
                    deltaY = (p_dist-n_dist)/2/Epsilon;
                }
            
                pt.setLocation(opt.getX(), opt.getY());
                
                pointMap[l.name+","+j] = new Point2D(deltaX, deltaY);
            
                //pt.setLocation(opt.getX()-deltaX*currentInterface.Lambda, opt.getY()-deltaY*currentInterface.Lambda);
            
            }
        }
    }

    // apply decent //
    for (var i=0, _length = currentAssembly.getAllElement().length(); i&lt;_length; i++) {
        if (currentAssembly.getAllElement().get(i) instanceof Link) { // &amp;&amp; !(assembly.getAllElement().get(i) instanceof Space) ){
            var l = currentAssembly.getAllElement().get(i);
        
            for (var j=0, _linkLength = l.getPointList().length(); j&lt;_linkLength; j++) {
                var pt = l.getPointList().get(j);
                var grd_pt = pointMap[l.name+","+j];
                
                if (grd_pt != null) {
                    pt.setLocation(pt.getX()-grd_pt.getX()*currentInterface.Lambda, pt.getY()-grd_pt.getY()*currentInterface.Lambda);
                }
            }
        }
    }

    cost = getDistScore(currentInterface.ind, targetTrj);
    if (cost &gt; prevCost) currentInterface.Lambda *= 0.80;
if ( cost == Number.POSITIVE_INFINITY) {
    //console.log("broken at #"+currentInterface.total_iter);
    isBroken = true;
    stopPathOptimize();
    showMessage("Broken at #"+currentInterface.total_iter);
    
    var cnt=0;
    for (var i=0, _length = currentAssembly.getAllElement().length(); i&lt;_length; i++) {
        if (currentAssembly.getAllElement().get(i) instanceof Link  ) { // &amp;&amp; !(assembly.getAllElement().get(i) instanceof Space //
            var l = currentAssembly.getAllElement().get(i);
        
            for (var j=0, _linkLength = l.getPointList().length(); j&lt;_linkLength; j++) {
                var pt = l.getPointList().get(j);
                var opt = pointBackup.get(cnt++);
            
                if (opt!=null) {
                    pt.setLocation(opt.getX(), opt.getY());
                }
            }
        }
    }

    break;
    } else {
        pointBackup = new ArrayList();
        currentAssemblyGroup.calculateAssembly();
    }

    iter++;
    currentInterface.total_iter++;
    this.msg="Iteration: "+currentInterface.total_iter + " / Cost: " + Math.abs((prevCost/cost)-1).toFixed(6);
    //console.log("Iteration #"+currentInterface.total_iter + " / " + Math.abs((prevCost/cost)-1).toFixed(10));
    showOptMsg(this.msg);
}

for (var i=0, _length = currentAssembly.getAllElement().length(); i&lt;_length; i++) {
    if (currentAssembly.getAllElement().get(i) instanceof Link &amp;&amp; !(currentAssembly.getAllElement().get(i) instanceof Space) ) {
        var l = currentAssembly.getAllElement().get(i);
        l.redefineVertex();
    }
}

if ( isBroken || Math.abs((prevCost/cost).toFixed(10)-1) &lt;= STOP_COST_RATIO ) {
    stopPathOptimize();
}

//render
if(currentInterface.total_iter%2==0){
    //render();
}
    //render();
}

function resample(pts, number){
    var I = pathLength( pts ) / (number-1);
    var D = 0;
    
    var returns = new Array(number);
    
    returns[0] = new Point2D( pts.get(0).getX(), pts.get(0).getY() );
    var cnt = 1;

for ( var idx=1, _length = pts.length(); idx&lt;_length; idx++ ) {
    var d = dist2D(pts.get(idx-1).getX(), pts.get(idx-1).getY(), pts.get(idx).getX(), pts.get(idx).getY());
    if ( D+d &gt;= I ) {
        var qx = pts.get(idx-1).getX() + ((I-D) / d) * (pts.get(idx).getX() - pts.get(idx-1).getX() );
        var qy = pts.get(idx-1).getY() + ((I-D) / d) * (pts.get(idx).getY() - pts.get(idx-1).getY() );
    
        if (cnt&lt;number) {
            returns[cnt++] = new Point2D( qx, qy );
        }
        pts.set(idx-1, new Point2D( qx, qy ));
        idx--;
        D = 0;
    } else {
        D += d;
    }
}

while ( cnt &lt; number ) {
    returns[cnt++] = pts.get(pts.length()-1);
}

    return returns;
}

function pathLength(pts) {
    var totalLen = 0;
    for (var i=0, _length = pts.length(); i&lt;_length-1; i++) {
        totalLen += dist2D( pts.get(i).getX(), pts.get(i).getY(), pts.get(i+1).getX(), pts.get(i+1).getY() );
    }
    return totalLen;
}

function dist2D(x1, y1, x2, y2) {
    var dx = x1-x2;
    var dy = y1-y2;
    return Math.sqrt(dx*dx + dy*dy);
}

function getDistScore(resultInd, targetTrjSample) {

    var cost = currentAssemblyGroup.try360();

    if ( cost &lt; Number.POSITIVE_INFINITY) {
        var selectedTrj = currentAssemblyGroup.getTrajectory().get(resultInd).getTrajectory();
        var resultTrj = resample(selectedTrj, OptInterface.SAMPLE_SIZE);
        return compareTrj(targetTrjSample, resultTrj)+cost;
    } else {
        return Number.POSITIVE_INFINITY;
    }
}

function compareTrj(t1, t2) {
    var totalLen = 0;
    for (var i=0, _length = t1.length; i&lt;_length; i++) {
        totalLen += dist2D(t1[i].getX(), t1[i].getY(), t2[i].getX(), t2[i].getY());
    }
        return totalLen/OptInterface.SAMPLE_SIZE;
    }


&lt;/script&gt;</t>
<t tx="leo.20191210200857.1">&lt;script&gt;

$('#panel_gen_draw').click( function(){
    if(toolState!=TOOL_OPT){
        toolState = TOOL_OPT;
    }
    else if(toolState==TOOL_OPT){
        toolState = -1;
    }
    setTool(toolState);
    checkToolSet();
});

$('#panel_gen_remove').click( function(){
    currentAssemblyGroup.optimizedPath.flush();
    currentAssemblyGroup.load();
});

$('#panel_gen_run').click( function(){
    if( $('#panel_gen_4').prop('checked') ){
        var t0 = performance.now();
        startFourbarGeneration();
        var t1 = performance.now();
        console.log("Call to startFourbarGeneration took " + (t1 - t0) + " milliseconds.")
    }
    // else if( $('#panel_gen_6').prop('checked') ){
    //     var t0 = performance.now();
    //     startWattGeneration();
    //     var t1 = performance.now();
    //     console.log("Call to startFourbarGeneration took " + (t1 - t0) + " milliseconds.")
    // }
});

    //var wattDataPath = "./public/res/WattDataSet";
    var wattDataPath = "./public/res/WattDataSet";
    //var fourbarDataPath = "./public/res/FourbarDataSet";
    var fourbarDataPath = "./public/res/FourbarDataSet";
    var WEIGHT_DIST = 10;
    var WEIGHT_ANGLE = 0.1;
    var WATT_SAMPLE_SIZE = 16;
    var FOURBAR_SAMPLE_SIZE = 16;
    var NUM_OF_WATT_DATASET = 5;
    var NUM_OF_FOURBAR_DATASET = 1;
    //var sampleWattTrj = loadWattSet();
    var sampleFourbarTrj = loadFourbarSet();

function startWattGeneration(){
    var targetPathData = currentAssemblyGroup.optimizedPath.getTrajectory();
    try360forAssemblies();
    var _sampleSize = WATT_SAMPLE_SIZE;
    var tempTrj = [];
    if(currentAssemblyGroup.optimizedPath.getTrajectory() == null){
        showSnackBar("No target trajectory to optimize", "No target trajectory to optimize");
        return;
    }
    var positionTrj = resample(currentAssemblyGroup.optimizedPath.getTrajectory(), _sampleSize);
    _trjData = normalizeTrj(positionTrj);
    tempTrj = _trjData.trajectory;
    
    getSimilarWatt(tempTrj, sampleWattTrj, targetPathData);

    //get optimized path
    currentAssemblyGroup.optimizedPath = new Trajectory();
    currentAssemblyGroup.optimizedPath.flush();

    for(var i in targetPathData.array){
        var a =targetPathData.get(i)
        currentAssemblyGroup.optimizedPath.getTrajectory().add(a);
        currentAssemblyGroup.load();
    }
}

function startFourbarGeneration(){
    var targetPathData = currentAssemblyGroup.optimizedPath.getTrajectory();
    try360forAssemblies();
    var _sampleSize = FOURBAR_SAMPLE_SIZE;
    var tempTrj = [];
if(currentAssemblyGroup.optimizedPath.getTrajectory() == null){
    showSnackBar("No target trajectory to optimize", "No target trajectory to optimize");
    return;
}

    var positionTrj = resample(currentAssemblyGroup.optimizedPath.getTrajectory(), _sampleSize);
    _trjData = normalizeTrj(positionTrj);
    tempTrj = _trjData.trajectory;

    getSimilarFourbar(tempTrj, sampleFourbarTrj, targetPathData);

    //get optimized path
    currentAssemblyGroup.optimizedPath = new Trajectory();
    currentAssemblyGroup.optimizedPath.flush();

    for(var i in targetPathData.array){
        var a =targetPathData.get(i)
        currentAssemblyGroup.optimizedPath.getTrajectory().add(a);
        currentAssemblyGroup.load();
    }
}

function loadWattSet(){
    var _returnData = [];
    for(var j=0; j&lt;NUM_OF_WATT_DATASET; j++){
        xmlhttp = new XMLHttpRequest();
        xmlhttp.open("GET", wattDataPath+"_"+j+".txt" ,false);
        xmlhttp.send(null);
        var _data = xmlhttp.responseText;
        // original for windows
        // var _lineData = _data.split("\r\n");
        var _lineData = _data.split("\n");
        for(i=0; i&lt;_lineData.length; i++){
            if(_lineData[i]!="") _returnData.push(JSON.parse(_lineData[i]));
        }
    }
    console.log("Loaded: " + _returnData.length);
    return _returnData;
}

function loadFourbarSet(){
    var _returnData = [];
for(var j=0; j&lt;NUM_OF_FOURBAR_DATASET; j++){
    xmlhttp = new XMLHttpRequest();
    //xmlhttp.open("GET", fourbarDataPath+"_"+j+".txt" ,false);
    xmlhttp.open("GET", fourbarDataPath+"_"+j+".txt", false);
    xmlhttp.send(null);
    var _data = xmlhttp.responseText;
    // original for windows
    //var _lineData = _data.split("\r\n");
    var _lineData = _data.split("\n");
    for(i=0; i&lt;_lineData.length; i++){
        if(_lineData[i]!="") _returnData.push(JSON.parse(_lineData[i]));
    }
}
    console.log("Loaded: " + _returnData.length);
    return _returnData;
}


function loadJSON(_dataJSON, _isNew){
    //check header
    if(_dataJSON.app != "EDISON" || _dataJSON.type != "Assembly"){
        showMessage("Wrong File");
        return null;
    }else{
        makeNewFile();
    }
    // generate planes
    for(var i=0; i&lt;_dataJSON.sketches.length; i++){
        loadMsketchInfoForPlane(_dataJSON.sketches[i], _isNew)
    }
    try360forAssemblies();
    updateMotorList();
    removeAssemblyGroup(0);
}

function getSimilarWatt(_trjArr, _dataset, _targetTrj){
    var _lowestDist = Number.POSITIVE_INFINITY;
    var _targetPoints = null;

    for(var i in _dataset){
        var dtwTrj = new DynamicTimeWarping(reOrderArray(_trjArr), reOrderArray(_dataset[i].trajectory), distFuncTrj);
        var distTrj = dtwTrj.getDistance()/(dtwTrj.getPath().length);
        
        var distAngle = 0
    
        var _totalDist = WEIGHT_DIST * distTrj + WEIGHT_ANGLE * distAngle/(2*Math.PI); // weight
        if(_totalDist &lt; _lowestDist){
            _lowestDist = _totalDist;
            _targetPoints = _dataset[i].points;
            _dir = _dataset[i].dir;
            _targetTrajectory = _dataset[i].trajectory
            console.log("[Calc] DistTRJ: " + distTrj + " / DistAngle: " + distAngle);
        }
    }
    console.log("LowestDist: " + _lowestDist);
    drawWatt(_targetPoints, _dir, 0, 0);

    //set trj poistion and motor phase
    //set motor phase
    var _optTrj = currentAssemblyGroup.getTrajectory().get(0).getTrajectory();
    var _centerTargetTrj = findCenterPosition(_targetTrj);
    var _centerOptTrj = findCenterPosition(_optTrj);

    var _ftX = _targetTrj.get(0).x *0.1;
    var _ftY = _targetTrj.get(0).y *0.1;
    var _targetPathFirstPointAngle = Math.atan2((_ftY-_centerTargetTrj.y*0.1),(_ftX-_centerTargetTrj.x*0.1));
    if(_targetPathFirstPointAngle&lt;0){
        _targetPathFirstPointAngle = 2*Math.PI + _targetPathFirstPointAngle;
    }

    var _foX = _optTrj.get(0).x *0.1;
    var _foY = _optTrj.get(0).y *0.1;
    var _optPathFirstPointAngle = Math.atan2((_foY-_centerOptTrj.y*0.1),(_foX-_centerOptTrj.x*0.1));
    if(_optPathFirstPointAngle&lt;0){
        _optPathFirstPointAngle = 2*Math.PI + _optPathFirstPointAngle;
    }

    var _motorPhase = (_optPathFirstPointAngle-_targetPathFirstPointAngle)*180/Math.PI;
    if(_motorPhase &lt;0){
        _motorPhase = 360 + _motorPhase;
    }

    //move trj
    var _dx = (_centerTargetTrj.x - _centerOptTrj.x) * 0.1;
    var _dy = (_centerTargetTrj.y - _centerOptTrj.y) * 0.1;
    
    for(i=0; i&lt;_targetPoints.length; i++){
        _targetPoints[i].x += _dx;
        _targetPoints[i].y += _dy;
    }

    //scale trj
    var _ratio = (findMaxY(_targetTrj)-findMinY(_targetTrj))/(findMaxY(_optTrj)-findMinY(_optTrj));
    for(var i=0; i&lt;_targetPoints.length; i++){
        _targetPoints[i] = scaleFromPoint(_targetPoints[i], _ratio, _centerTargetTrj.x * 0.1, _centerTargetTrj.y * 0.1);
    }

    drawWatt(_targetPoints, _dir, 0, _motorPhase);
}

function getSimilarFourbar(_trjArr, _dataset, _targetTrj){
    var _lowestDist = Number.POSITIVE_INFINITY;
    var _targetPoints = null;

    for(var i in _dataset){
        var dtwTrj = new DynamicTimeWarping(reOrderArray(_trjArr), reOrderArray(_dataset[i].trajectory), distFuncTrj);
        var distTrj = dtwTrj.getDistance()/(dtwTrj.getPath().length);
        
        var distAngle = 0
    
        var _totalDist = WEIGHT_DIST * distTrj + WEIGHT_ANGLE * distAngle/(2*Math.PI); // weight
        if(_totalDist &lt; _lowestDist){
            _lowestDist = _totalDist;
            _targetPoints = _dataset[i].points;
            _dir = _dataset[i].dir;
            _targetTrajectory = _dataset[i].trajectory
            console.log("[Calc] DistTRJ: " + distTrj + " / DistAngle: " + distAngle);
        }
    }
    console.log("LowestDist: " + _lowestDist);
    drawFourbar(_targetPoints, _dir, 0, 0);
    
    //set trj poistion and motor phase
    //set motor phase
    var _optTrj = currentAssemblyGroup.getTrajectory().get(0).getTrajectory();
    var _centerTargetTrj = findCenterPosition(_targetTrj);
    var _centerOptTrj = findCenterPosition(_optTrj);

    var _ftX = _targetTrj.get(0).x *0.1;
    var _ftY = _targetTrj.get(0).y *0.1;
    var _targetPathFirstPointAngle = Math.atan2((_ftY-_centerTargetTrj.y*0.1),(_ftX-_centerTargetTrj.x*0.1));
    if(_targetPathFirstPointAngle&lt;0){
        _targetPathFirstPointAngle = 2*Math.PI + _targetPathFirstPointAngle;
    }

    var _foX = _optTrj.get(0).x *0.1;
    var _foY = _optTrj.get(0).y *0.1;
    var _optPathFirstPointAngle = Math.atan2((_foY-_centerOptTrj.y*0.1),(_foX-_centerOptTrj.x*0.1));
    if(_optPathFirstPointAngle&lt;0){
        _optPathFirstPointAngle = 2*Math.PI + _optPathFirstPointAngle;
    }

    var _motorPhase = (_optPathFirstPointAngle-_targetPathFirstPointAngle)*180/Math.PI;
    if(_motorPhase &lt;0){
        _motorPhase = 360 + _motorPhase;
    }

    //move trj
    var _dx = (_centerTargetTrj.x - _centerOptTrj.x) * 0.1;
    var _dy = (_centerTargetTrj.y - _centerOptTrj.y) * 0.1;

    for(i=0; i&lt;_targetPoints.length; i++){
        _targetPoints[i].x += _dx;
        _targetPoints[i].y += _dy;
    }

    //scale trj
    var _ratio = (findMaxY(_targetTrj)-findMinY(_targetTrj))/(findMaxY(_optTrj)-findMinY(_optTrj));
    for(var i=0; i&lt;_targetPoints.length; i++){
        _targetPoints[i] = scaleFromPoint(_targetPoints[i], _ratio, _centerTargetTrj.x * 0.1, _centerTargetTrj.y * 0.1);
    }

    drawFourbar(_targetPoints, _dir, 0, _motorPhase);
}

function scaleFromPoint(_p, _ratio, _x, _y){ // (_p{x: , y: }, ratio, x, y)
    var _qx = _p.x - (_p.x-_x)*(1-_ratio);
    var _qy = _p.y - (_p.y-_y)*(1-_ratio);
    return {x: _qx, y: _qy};
}

function findMaxY(_trj){  //find maximum y value of trj point
    var _yMax = Number.NEGATIVE_INFINITY;
    for(var i in _trj.array){
        if(_trj.get(i).y &gt; _yMax){
            _yMax = _trj.get(i).y;
        }
    }
    return _yMax;
}

function findMinY(_trj){ //find minimum y value of trj point
    var _yMin = Number.POSITIVE_INFINITY;
    for(var i in _trj.array){
        if(_trj.get(i).y &lt; _yMin){
            _yMin = _trj.get(i).y;
        }
    }
    return _yMin;
}

function drawWatt(_parr, _dir, _angle, _motorPhase){

    var tempWattObject = {"app":"EDISON","type":"Assembly","fileVersion":"2.0","description":"Saved From M.Sketch v3.0","sketches":[{"plane":{"name":"Plane0","translation":{"x":"0.00","y":"0.00","z":"0.00"},"rotation":{"x":"0.00","y":"0.00","z":"0.00"}},"anchor":{"points":[{"x":"0.00","y":"0.00","z":"0.00"},{"x":"100.00","y":"0.00","z":"0.00"}]},"links":[{"name":"Crank","points":[{"x":"0.00","y":"0.00","z":"0.00"},{"x":"0.00","y":"40.00","z":"0.00"}]},{"name":"Rocker","points":[{"x":"100.00","y":"0.00","z":"0.00"},{"x":"100.00","y":"50.00","z":"0.00"},{"x":"100.00","y":"25.00","z":"0.00"}]},{"name":"Coupler1","points":[{"x":"0.00","y":"40.00","z":"0.00"},{"x":"100.00","y":"50.00","z":"0.00"}]},{"name":"Coupler2","points":[{"x":"-0.00","y":"40.00","z":"0.00"},{"x":"35.86","y":"74.96","z":"0.00"}]},{"name":"Coupler3","points":[{"x":"35.86","y":"74.96","z":"0.00"},{"x":"100.00","y":"50.00","z":"0.00"}]},{"name":"WattCoupler","points":[{"x":"100.00","y":"25.00","z":"0.00"},{"x":"132.75","y":"109.40","z":"0.00"}]},{"name":"TargetLink","points":[{"x":"132.75","y":"109.40","z":"0.00"},{"x":"35.86","y":"74.96","z":"0.00"},{"x":"85.27","y":"92.72","z":"0.00"}]}],"constraints":[{"name":"CoaxialConstraint1","points":[{"targetLink":"Crank","targetIndex":0},{"targetLink":"Anchor","targetIndex":0}]},{"name":"CoaxialConstraint2","points":[{"targetLink":"Rocker","targetIndex":0},{"targetLink":"Anchor","targetIndex":1}]},{"name":"CoaxialConstraint3","points":[{"targetLink":"Coupler2","targetIndex":0},{"targetLink":"Crank","targetIndex":1},{"targetLink":"Coupler1","targetIndex":0}]},{"name":"CoaxialConstraint4","points":[{"targetLink":"Rocker","targetIndex":1},{"targetLink":"Coupler3","targetIndex":1},{"targetLink":"Coupler1","targetIndex":1}]},{"name":"CoaxialConstraint5","points":[{"targetLink":"WattCoupler","targetIndex":0},{"targetLink":"Rocker","targetIndex":2}]},{"name":"CoaxialConstraint6","points":[{"targetLink":"TargetLink","targetIndex":0},{"targetLink":"WattCoupler","targetIndex":1}]},{"name":"CoaxialConstraint7","points":[{"targetLink":"Coupler2","targetIndex":1},{"targetLink":"TargetLink","targetIndex":1},{"targetLink":"Coupler3","targetIndex":0}]}],"sliders":[],"markers":[{"targetLink":"TargetLink","targetIndex":2}],"motors":[{"name":"Motor1","targetConstraint":"CoaxialConstraint1","targetLink1":"Crank","targetLink2":"Anchor","type":"DC","direction":0,"speed":100,"phase":0,"range":"0-180"}]}]}
    
    //anchor
    tempWattObject.sketches[0].anchor.points[0].x = _parr[0].x; //a1
    tempWattObject.sketches[0].anchor.points[0].y = _parr[0].y;
    tempWattObject.sketches[0].anchor.points[1].x = _parr[1].x; //a2
    tempWattObject.sketches[0].anchor.points[1].y = _parr[1].y;
    
    //crank
    tempWattObject.sketches[0].links[0].points[0].x = _parr[0].x; //a1
    tempWattObject.sketches[0].links[0].points[0].y = _parr[0].y;
    tempWattObject.sketches[0].links[0].points[1].x = _parr[2].x; //a2
    tempWattObject.sketches[0].links[0].points[1].y = _parr[2].y;
    
    //Rocker
    tempWattObject.sketches[0].links[1].points[0].x = _parr[1].x; //a1
    tempWattObject.sketches[0].links[1].points[0].y = _parr[1].y;
    tempWattObject.sketches[0].links[1].points[1].x = _parr[3].x; //a2
    tempWattObject.sketches[0].links[1].points[1].y = _parr[3].y;
    tempWattObject.sketches[0].links[1].points[2].x = _parr[5].x; //a2
    tempWattObject.sketches[0].links[1].points[2].y = _parr[5].y;
    
    //Coupler1
    tempWattObject.sketches[0].links[2].points[0].x = _parr[2].x; //p1
    tempWattObject.sketches[0].links[2].points[0].y = _parr[2].y;
    tempWattObject.sketches[0].links[2].points[1].x = _parr[3].x; //p2
    tempWattObject.sketches[0].links[2].points[1].y = _parr[3].y;
    
    //Coupler2
    tempWattObject.sketches[0].links[3].points[0].x = _parr[2].x; //p1
    tempWattObject.sketches[0].links[3].points[0].y = _parr[2].y;
    tempWattObject.sketches[0].links[3].points[1].x = _parr[4].x; //p3
    tempWattObject.sketches[0].links[3].points[1].y = _parr[4].y;
    
    //Coupler3
    tempWattObject.sketches[0].links[4].points[0].x = _parr[4].x; //p3
    tempWattObject.sketches[0].links[4].points[0].y = _parr[4].y;
    tempWattObject.sketches[0].links[4].points[1].x = _parr[3].x; //p2
    tempWattObject.sketches[0].links[4].points[1].y = _parr[3].y;
    
    //WattCoupler
    tempWattObject.sketches[0].links[5].points[0].x = _parr[5].x; //c1
    tempWattObject.sketches[0].links[5].points[0].y = _parr[5].y;
    tempWattObject.sketches[0].links[5].points[1].x = _parr[6].x; //c2
    tempWattObject.sketches[0].links[5].points[1].y = _parr[6].y;
    
    //TargetLink
    var _target_center_x = (_parr[4].x + _parr[6].x)/2;
    var _target_center_y = (_parr[4].y + _parr[6].y)/2;
    tempWattObject.sketches[0].links[6].points[0].x = _parr[6].x; //c2
    tempWattObject.sketches[0].links[6].points[0].y = _parr[6].y;
    tempWattObject.sketches[0].links[6].points[1].x = _parr[4].x; //p3
    tempWattObject.sketches[0].links[6].points[1].y = _parr[4].y;
    tempWattObject.sketches[0].links[6].points[2].x = _target_center_x; //(c2+p3)/2
    tempWattObject.sketches[0].links[6].points[2].y = _target_center_y;
    
    tempWattObject.sketches[0].motors[0].phase = _motorPhase;
    tempWattObject.sketches[0].motors[0].direction = _dir;
    
    loadJSON(tempWattObject, true);
}

/////drawWatt function for generateWatt
function drawWatt_generate(_parr, _dir, _angle, _motorPhase){

    var tempWattObject = {"app":"EDISON","type":"Assembly","fileVersion":"2.0","description":"Saved From M.Sketch v3.0","sketches":[{"plane":{"name":"Plane0","translation":{"x":"0.00","y":"0.00","z":"0.00"},"rotation":{"x":"0.00","y":"0.00","z":"0.00"}},"anchor":{"points":[{"x":"0.00","y":"0.00","z":"0.00"},{"x":"100.00","y":"0.00","z":"0.00"}]},"links":[{"name":"Crank","points":[{"x":"0.00","y":"0.00","z":"0.00"},{"x":"0.00","y":"40.00","z":"0.00"}]},{"name":"Rocker","points":[{"x":"100.00","y":"0.00","z":"0.00"},{"x":"100.00","y":"50.00","z":"0.00"},{"x":"100.00","y":"25.00","z":"0.00"}]},{"name":"Coupler1","points":[{"x":"0.00","y":"40.00","z":"0.00"},{"x":"100.00","y":"50.00","z":"0.00"}]},{"name":"Coupler2","points":[{"x":"-0.00","y":"40.00","z":"0.00"},{"x":"35.86","y":"74.96","z":"0.00"}]},{"name":"Coupler3","points":[{"x":"35.86","y":"74.96","z":"0.00"},{"x":"100.00","y":"50.00","z":"0.00"}]},{"name":"WattCoupler","points":[{"x":"100.00","y":"25.00","z":"0.00"},{"x":"132.75","y":"109.40","z":"0.00"}]},{"name":"TargetLink","points":[{"x":"132.75","y":"109.40","z":"0.00"},{"x":"35.86","y":"74.96","z":"0.00"},{"x":"85.27","y":"92.72","z":"0.00"}]}],"constraints":[{"name":"CoaxialConstraint1","points":[{"targetLink":"Crank","targetIndex":0},{"targetLink":"Anchor","targetIndex":0}]},{"name":"CoaxialConstraint2","points":[{"targetLink":"Rocker","targetIndex":0},{"targetLink":"Anchor","targetIndex":1}]},{"name":"CoaxialConstraint3","points":[{"targetLink":"Coupler2","targetIndex":0},{"targetLink":"Crank","targetIndex":1},{"targetLink":"Coupler1","targetIndex":0}]},{"name":"CoaxialConstraint4","points":[{"targetLink":"Rocker","targetIndex":1},{"targetLink":"Coupler3","targetIndex":1},{"targetLink":"Coupler1","targetIndex":1}]},{"name":"CoaxialConstraint5","points":[{"targetLink":"WattCoupler","targetIndex":0},{"targetLink":"Rocker","targetIndex":2}]},{"name":"CoaxialConstraint6","points":[{"targetLink":"TargetLink","targetIndex":0},{"targetLink":"WattCoupler","targetIndex":1}]},{"name":"CoaxialConstraint7","points":[{"targetLink":"Coupler2","targetIndex":1},{"targetLink":"TargetLink","targetIndex":1},{"targetLink":"Coupler3","targetIndex":0}]}],"sliders":[],"markers":[{"targetLink":"Coupler2","targetIndex":1},{"targetLink":"TargetLink","targetIndex":2},{"targetLink":"WattCoupler","targetIndex":1}],"motors":[{"name":"Motor1","targetConstraint":"CoaxialConstraint1","targetLink1":"Crank","targetLink2":"Anchor","type":"DC","direction":0,"speed":100,"phase":0,"range":"0-180"}]}]}
    
    
    //anchor
    tempWattObject.sketches[0].anchor.points[0].x = _parr[0].x; //a1
    tempWattObject.sketches[0].anchor.points[0].y = _parr[0].y;
    tempWattObject.sketches[0].anchor.points[1].x = _parr[1].x; //a2
    tempWattObject.sketches[0].anchor.points[1].y = _parr[1].y;
    
    //crank
    tempWattObject.sketches[0].links[0].points[0].x = _parr[0].x; //a1
    tempWattObject.sketches[0].links[0].points[0].y = _parr[0].y;
    tempWattObject.sketches[0].links[0].points[1].x = _parr[2].x; //a2
    tempWattObject.sketches[0].links[0].points[1].y = _parr[2].y;
    
    //Rocker
    tempWattObject.sketches[0].links[1].points[0].x = _parr[1].x; //a1
    tempWattObject.sketches[0].links[1].points[0].y = _parr[1].y;
    tempWattObject.sketches[0].links[1].points[1].x = _parr[3].x; //a2
    tempWattObject.sketches[0].links[1].points[1].y = _parr[3].y;
    tempWattObject.sketches[0].links[1].points[2].x = _parr[5].x; //a2
    tempWattObject.sketches[0].links[1].points[2].y = _parr[5].y;
    
    //Coupler1
    tempWattObject.sketches[0].links[2].points[0].x = _parr[2].x; //p1
    tempWattObject.sketches[0].links[2].points[0].y = _parr[2].y;
    tempWattObject.sketches[0].links[2].points[1].x = _parr[3].x; //p2
    tempWattObject.sketches[0].links[2].points[1].y = _parr[3].y;
    
    //Coupler2
    tempWattObject.sketches[0].links[3].points[0].x = _parr[2].x; //p1
    tempWattObject.sketches[0].links[3].points[0].y = _parr[2].y;
    tempWattObject.sketches[0].links[3].points[1].x = _parr[4].x; //p3
    tempWattObject.sketches[0].links[3].points[1].y = _parr[4].y;
    
    //Coupler3
    tempWattObject.sketches[0].links[4].points[0].x = _parr[4].x; //p3
    tempWattObject.sketches[0].links[4].points[0].y = _parr[4].y;
    tempWattObject.sketches[0].links[4].points[1].x = _parr[3].x; //p2
    tempWattObject.sketches[0].links[4].points[1].y = _parr[3].y;
    
    //WattCoupler
    tempWattObject.sketches[0].links[5].points[0].x = _parr[5].x; //c1
    tempWattObject.sketches[0].links[5].points[0].y = _parr[5].y;
    tempWattObject.sketches[0].links[5].points[1].x = _parr[6].x; //c2
    tempWattObject.sketches[0].links[5].points[1].y = _parr[6].y;
    
    //TargetLink
    var _target_center_x = (_parr[4].x + _parr[6].x)/2;
    var _target_center_y = (_parr[4].y + _parr[6].y)/2;
    tempWattObject.sketches[0].links[6].points[0].x = _parr[6].x; //c2
    tempWattObject.sketches[0].links[6].points[0].y = _parr[6].y;
    tempWattObject.sketches[0].links[6].points[1].x = _parr[4].x; //p3
    tempWattObject.sketches[0].links[6].points[1].y = _parr[4].y;
    tempWattObject.sketches[0].links[6].points[2].x = _target_center_x; //(c2+p3)/2
    tempWattObject.sketches[0].links[6].points[2].y = _target_center_y;
    
    tempWattObject.sketches[0].motors[0].phase = _motorPhase;
    tempWattObject.sketches[0].motors[0].direction = _dir;
    
    loadJSON(tempWattObject, true);
}

function drawFourbar(_parr, _dir, _angle, _motorPhase){
    var tempFourbarObject = {"app":"EDISON","type":"Assembly","fileVersion":"2.0","description":"Saved From M.Sketch v3.0","sketches":[{"plane":{"name":"Plane0","translation":{"x":"0.00","y":"0.00","z":"0.00"},"rotation":{"x":"0.00","y":"0.00","z":"0.00"}},"anchor":{"points":[{"x":"0.00","y":"0.00","z":"0.00"},{"x":"50.00","y":"0.00","z":"0.00"}]},"links":[{"name":"Crank","points":[{"x":"0.00","y":"0.00","z":"0.00"},{"x":"0.00","y":"25.00","z":"0.00"}]},{"name":"Rocker","points":[{"x":"50.00","y":"0.00","z":"0.00"},{"x":"50.00","y":"50.00","z":"0.00"}]},{"name":"Coupler1","points":[{"x":"0.00","y":"25.00","z":"0.00"},{"x":"50.00","y":"50.00","z":"0.00"}]},{"name":"Coupler2","points":[{"x":"-0.00","y":"25.00","z":"0.00"},{"x":"-0.00","y":"50.00","z":"0.00"}]},{"name":"Coupler3","points":[{"x":"-0.00","y":"50.00","z":"0.00"},{"x":"50.00","y":"50.00","z":"0.00"}]}],"constraints":[{"name":"CoaxialConstraint1","points":[{"targetLink":"Crank","targetIndex":0},{"targetLink":"Anchor","targetIndex":0}]},{"name":"CoaxialConstraint2","points":[{"targetLink":"Rocker","targetIndex":0},{"targetLink":"Anchor","targetIndex":1}]},{"name":"CoaxialConstraint5","points":[{"targetLink":"Coupler2","targetIndex":0},{"targetLink":"Crank","targetIndex":1},{"targetLink":"Coupler1","targetIndex":0}]},{"name":"CoaxialConstraint6","points":[{"targetLink":"Coupler3","targetIndex":0},{"targetLink":"Coupler2","targetIndex":1}]},{"name":"CoaxialConstraint7","points":[{"targetLink":"Rocker","targetIndex":1},{"targetLink":"Coupler3","targetIndex":1},{"targetLink":"Coupler1","targetIndex":1}]}],"sliders":[],"markers":[{"targetLink":"Coupler2","targetIndex":1}],"motors":[{"name":"Motor1","targetConstraint":"CoaxialConstraint1","targetLink1":"Crank","targetLink2":"Anchor","type":"DC","direction":0,"speed":100,"phase":0,"range":"0-180"}]}]}
    //anchor
    tempFourbarObject.sketches[0].anchor.points[0].x = _parr[0].x; //a1
    tempFourbarObject.sketches[0].anchor.points[0].y = _parr[0].y;
    tempFourbarObject.sketches[0].anchor.points[1].x = _parr[1].x; //a2
    tempFourbarObject.sketches[0].anchor.points[1].y = _parr[1].y;
    
    //crank
    tempFourbarObject.sketches[0].links[0].points[0].x = _parr[0].x; //a1
    tempFourbarObject.sketches[0].links[0].points[0].y = _parr[0].y;
    tempFourbarObject.sketches[0].links[0].points[1].x = _parr[2].x; //a2
    tempFourbarObject.sketches[0].links[0].points[1].y = _parr[2].y;
    
    //Rocker
    tempFourbarObject.sketches[0].links[1].points[0].x = _parr[1].x; //a1
    tempFourbarObject.sketches[0].links[1].points[0].y = _parr[1].y;
    tempFourbarObject.sketches[0].links[1].points[1].x = _parr[3].x; //a2
    tempFourbarObject.sketches[0].links[1].points[1].y = _parr[3].y;
    
    //Coupler1
    tempFourbarObject.sketches[0].links[2].points[0].x = _parr[2].x; //p1
    tempFourbarObject.sketches[0].links[2].points[0].y = _parr[2].y;
    tempFourbarObject.sketches[0].links[2].points[1].x = _parr[3].x; //p2
    tempFourbarObject.sketches[0].links[2].points[1].y = _parr[3].y;
    
    //Coupler2
    tempFourbarObject.sketches[0].links[3].points[0].x = _parr[2].x; //p1
    tempFourbarObject.sketches[0].links[3].points[0].y = _parr[2].y;
    tempFourbarObject.sketches[0].links[3].points[1].x = _parr[4].x; //p3
    tempFourbarObject.sketches[0].links[3].points[1].y = _parr[4].y;
    
    //Coupler3
    tempFourbarObject.sketches[0].links[4].points[0].x = _parr[4].x; //p3
    tempFourbarObject.sketches[0].links[4].points[0].y = _parr[4].y;
    tempFourbarObject.sketches[0].links[4].points[1].x = _parr[3].x; //p2
    tempFourbarObject.sketches[0].links[4].points[1].y = _parr[3].y;
    
    tempFourbarObject.sketches[0].motors[0].phase = _motorPhase;
    tempFourbarObject.sketches[0].motors[0].direction = _dir;
    
    loadJSON(tempFourbarObject, true);
}

function getTrj(){
    try360forAssemblies();
    var _sampleSize = WATT_SAMPLE_SIZE;

    if(currentAssemblyGroup.optimizedPath.getTrajectory() == null){
        showSnackBar("최적화 목적 궤적 없음", "No target trajectory to optimize");
        return;
    }

    //var positionTrj = resample(currentAssemblyGroup.getTrajectory().get(0).getTrajectory(), _sampleSize); // base position
    var positionTrj = resample(currentAssemblyGroup.optimizedPath.getTrajectory(), _sampleSize); // base position
    _trjData = normalizeTrj(positionTrj);
    tempTrj = _trjData.trajectory;
    
    console.log(JSON.stringify(tempTrj));
}

function findCenterPosition(_trj){
    var _xMean = 0;
    var _yMean = 0;

    for (var i in _trj.array){
        _xMean = _xMean + _trj.get(i).x;
        _yMean = _yMean + _trj.get(i).y;
    }
    _xMean = _xMean / _trj.length();
    _yMean = _yMean / _trj.length();
    
    return {x: _xMean, y: _yMean};
}

function reOrderArray(_arr){
    var _returnArray = [];
    
    var _yMax = 0;
    var _maxIndex = -1;
    for(var i=0; i&lt;_arr.length; i++){
        if(_arr[i].y &gt; _yMax){
            _yMax = _arr[i].y;
            _maxIndex = i;
        }
    }

    if(_maxIndex == 0){
        _returnArray = _arr;
    }
    else{
    var _arrFront = _arr.slice(0, _maxIndex);
    var _arrEnd = _arr.slice(_maxIndex, _arr.length);
    
    _returnArray = _arrEnd.concat(_arrFront);
   }

    return _returnArray;
}


var emptyWattTrj = [];
function makeWattSet(_start, _end){
    var START_COUNT_FILE = _start;
    var END_COUNT_FILE = _end;
    
    console.log("START FROM: " + START_COUNT_FILE);
    console.log("END AT: " + END_COUNT_FILE);

    // array of a1, a2, p1, p2, p3, r1, r2
    // sample
    //_parr = [{x: 0.00, y: 0.00}, {x: 101.60, y: 0.00}, {x: 0.00, y: 38.10}, {x: 101.60, y: 76.20}, {x: 50.80, y: 50.80}, {x: 101.60, y: 0.00}, {x: 76.20, y: 25.40}]
    
    // starting point
    var _a1 = {x: 0, y: 0};
    var _a2 = {x: 50, y: 0};
    var _p1 = {x: 0, y: 25};
    var _p2 = {x: 50, y: 50};
    var _p3 = {x: 25, y: 25};
    var _c1 = {x: 50, y: 0};
    var _c2 = {x: 40, y: 15};
    
    var _count=0;
    
    // p1.y
    for(var p1y=0; p1y&lt;=10; p1y+=10){
        // c1.y
        //for(var c1y=-_ANGLE_MAX; c1y&lt;_ANGLE_MAX; c1y+=_STEP*2){
        // p3.x, p3.y
        for(var _r=30; _r&lt;=50; _r+=10){
            for(var _angle=0; _angle&lt;(2*Math.PI); _angle+=(Math.PI/16)){
                var p3x = _r*Math.cos(_angle);
                var p3y = _r*Math.sin(_angle);
                // c2.x
                for(var _r2=60; _r2&lt;=80; _r2+=10){
                    for(var _angle2=0; _angle2&lt;(2*Math.PI); _angle2+=(Math.PI/16)){
                        var c2x = _r2*Math.cos(_angle2);
                        var c2y = _r2*Math.sin(_angle2);
                    
                        _a1t = {x: _a1.x,           y: _a1.y       };
                        _a2t = {x: _a2.x,           y: _a2.y       };
                        _p1t = {x: _p1.x,           y: _p1.y + p1y };
                        _p2t = {x: _a2t.x,          y: _p2.y       };
                        _c1t = {x: _a2t.x,          y: _c1.y       };
                    
                        _p3t = {x: (_p1t.x+_p2t.x)/2 + p3x,   y: (_p1t.y+_p2t.y)/2 + p3y};
                        _c2t = {x: (_c1t.x+_p3t.x)/2 + c2x,   y: (_c1t.y+_p3t.y)/2 + c2y};
                        
                        _parr = [_a1t, _a2t, _p1t, _p2t, _p3t, _c1t, _c2t];
                    
                        for(var i=0; i&lt;8; i++){
                        
                            // ================== EDITED
                        
                            if(_count&gt;=START_COUNT_FILE &amp;&amp; _count&lt;END_COUNT_FILE){
                                generateWatt(emptyWattTrj, _parr, 0, ((2*Math.PI)/8)*i);
                                generateWatt(emptyWattTrj, _parr, 1, ((2*Math.PI)/8)*i); //reverse
                            }
                            _count++;
                            }
                        
                            if(_count&gt;=START_COUNT_FILE &amp;&amp; _count&lt;END_COUNT_FILE){
                                var _text = "[";
                                for(var i=START_COUNT_FILE; i&lt;END_COUNT_FILE; i+=((END_COUNT_FILE-START_COUNT_FILE)/20)){
                                    if(i&lt;_count){
                                        _text += "■";
                                    }else{
                                        _text += "□";
                                    }
                                }
                                _text += "] " + parseInt(((_count-START_COUNT_FILE)/(END_COUNT_FILE-START_COUNT_FILE))*100) +"%";
                                console.log(_text);
                            }
                            //console.log("Training: " + emptyWattTrj.length);
                        }
                    }
                }
            }
        //}
    }


    console.log("total Count: " + _count);
    console.log("Generated Samples: " + emptyWattTrj.length);

    var _generatedData = "";
    for(i=0; i&lt;emptyWattTrj.length; i++){
        _generatedData += JSON.stringify(emptyWattTrj[i]) + "\r\n";
    }
    saveAsText("WattDataSet"+START_COUNT_FILE+"_"+END_COUNT_FILE+"_"+(emptyWattTrj.length)+".txt", _generatedData);

    makeNewFile();
}

// generate and save watt;
function generateWatt(_dataSet, _parr, _dir, _angle){
    //a1: anchor point for crank (driver)
    //a2: anchor point for rocker
    //p1: end point of crank
    //p2: end point of rocker
    //p3: end point of coupler (triangle)
    //r1: end point of watt rocker
    //r2: link point between r1 and p3
    //actual movement: link between r2 and p3

    // array of a1, a2, p1, p2, p3, r1, r2
    // sample
    //_parr = [{x: 0.00, y: 0.00}, {x: 101.60, y: 0.00}, {x: 0.00, y: 38.10}, {x: 101.60, y: 76.20}, {x: 50.80, y: 50.80}, {x: 101.60, y: 0.00}, {x: 76.20, y: 25.40}]

    if(_angle!=0){
        var _rotatedPArr = [];
        for(var i=0; i&lt;_parr.length; i++){
            _rotatedPArr.push(rotateFromOrigin(_parr[i], _angle));
        }
        _parr = _rotatedPArr;
    }

    drawWatt_generate(_parr, _dir, _angle, 0);

    // break test
    var isBroken = false;
    if(currentAssemblyGroup.try360() == Number.POSITIVE_INFINITY){
        isBroken = true;
        return false; // stop here for broken linkages
    }
    if(currentAssemblyGroup.assembly.getUnspecified().length()&gt;0) return false;

    // get trajectories
    var _sampleSize = WATT_SAMPLE_SIZE;
    var positionTrj = resample(currentAssemblyGroup.getTrajectory().get(0).getTrajectory(), _sampleSize); // base position
    var handleTrj = resample(currentAssemblyGroup.getTrajectory().get(1).getTrajectory(), _sampleSize); // handle position
    var targetTrj = resample(currentAssemblyGroup.getTrajectory().get(2).getTrajectory(), _sampleSize); // target position

    if(isNaN(handleTrj[0].x)) return false;

    var _trjData = normalizeTrj(targetTrj);

    // get angles
    var angleArrays = getAngleVariation(positionTrj, handleTrj);
    var _angleData = normalizeAngle(angleArrays);
    
    _dataSet.push({points: _parr,
    trajectory: _trjData.trajectory,
    angle: _angleData.angle,
    width: _trjData.width,
    dx: _trjData.dx,
    dy: _trjData.dy,
    da: _angleData.da,
    dir: _dir
    });
}

    var emptyFourbarTrj = [];
function makeFourbarSet(_start, _end){
    var START_COUNT_FILE = _start;
    var END_COUNT_FILE = _end;
    
    console.log("START FROM: " + START_COUNT_FILE);
    console.log("END AT: " + END_COUNT_FILE);
    
    // array of a1, a2, p1, p2, p3
    // sample
    //_parr = [{x: 0.00, y: 0.00}, {x: 101.60, y: 0.00}, {x: 0.00, y: 38.10}, {x: 101.60, y: 76.20}, {x: 50.80, y: 50.80}]
    
    // starting point
    var _a1 = {x: 0, y: 0};
    var _a2 = {x: 50, y: 0};
    var _p1 = {x: 0, y: 25};
    var _p2 = {x: 50, y: 50};
    var _p3 = {x: 25, y: 25};
    
    var _count=0;
    // p3.x, p3.y
for(var _r=30; _r&lt;=50; _r+=20){
for(var _angle=0; _angle&lt;(2*Math.PI); _angle+=(Math.PI/16)){
    var p3x = _r*Math.cos(_angle);
    var p3y = _r*Math.sin(_angle);
    
    _a1t = {x: _a1.x,           y: _a1.y       };
    _a2t = {x: _a2.x,           y: _a2.y       };
    _p1t = {x: _p1.x,           y: _p1.y       };
    _p2t = {x: _a2t.x,          y: _p2.y       };
    _p3t = {x: (_p1t.x+_p2t.x)/2 + p3x,   y: (_p1t.y+_p2t.y)/2 + p3y};
    
    _parr = [_a1t, _a2t, _p1t, _p2t, _p3t];

    for(var i=0; i&lt;8; i++){
    
        if(_count&gt;=START_COUNT_FILE &amp;&amp; _count&lt;END_COUNT_FILE){
            generateFourbar(emptyFourbarTrj, _parr, 0, ((2*Math.PI)/8)*i);
            generateFourbar(emptyFourbarTrj, _parr, 1, ((2*Math.PI)/8)*i); //reverse
        }
        _count++;
    }

    if(_count&gt;=START_COUNT_FILE &amp;&amp; _count&lt;END_COUNT_FILE){
        var _text = "[";
        for(var i=START_COUNT_FILE; i&lt;END_COUNT_FILE; i+=((END_COUNT_FILE-START_COUNT_FILE)/20)){
            if(i&lt;_count){
                _text += "■";
            }else{
                _text += "□";
            }
        }
        _text += "] " + parseInt(((_count-START_COUNT_FILE)/(END_COUNT_FILE-START_COUNT_FILE))*100) +"%";
        console.log(_text);
    }
    //console.log("Training: " + emptyFourbarTrj.length);
    }
}

    console.log("total Count: " + _count);
    console.log("Generated Samples: " + emptyFourbarTrj.length);
    
    var _generatedData = "";
    for(i=0; i&lt;emptyFourbarTrj.length; i++){
        _generatedData += JSON.stringify(emptyFourbarTrj[i]) + "\r\n";
    }
        saveAsText("FourbarDataSet"+START_COUNT_FILE+"_"+END_COUNT_FILE+"_"+(emptyFourbarTrj.length)+".txt", _generatedData);
    
    makeNewFile();
}

// generate and save watt;
function generateFourbar(_dataSet, _parr, _dir, _angle){
    //a1: anchor point for crank (driver)
    //a2: anchor point for rocker
    //p1: end point of crank
    //p2: end point of rocker
    //p3: end point of coupler (triangle)
    
    // array of a1, a2, p1, p2, p3,
    // sample
    //_parr = [{x: 0.00, y: 0.00}, {x: 101.60, y: 0.00}, {x: 0.00, y: 38.10}, {x: 101.60, y: 76.20}, {x: 50.80, y: 50.80},]

    if(_angle!=0){
        var _rotatedPArr = [];
        for(var i=0; i&lt;_parr.length; i++){
            _rotatedPArr.push(rotateFromOrigin(_parr[i], _angle));
        }
        _parr = _rotatedPArr;
    }

    drawFourbar(_parr, _dir, _angle, 0);

    // break test
    var isBroken = false;
    if(currentAssemblyGroup.try360() == Number.POSITIVE_INFINITY){
        isBroken = true;
        return false; // stop here for broken linkages
    }
    if(currentAssemblyGroup.assembly.getUnspecified().length()&gt;0) return false;

    // get trajectories
    var _sampleSize = FOURBAR_SAMPLE_SIZE;
    var positionTrj = resample(currentAssemblyGroup.getTrajectory().get(0).getTrajectory(), _sampleSize); // base position
    
    var _trjData = normalizeTrj(positionTrj);
    
    _dataSet.push({points: _parr,
    trajectory: _trjData.trajectory,
    //angle: _angleData.angle,
    width: _trjData.width,
    dx: _trjData.dx,
    dy: _trjData.dy,
    //da: _angleData.da,
    dir: _dir
    });
}

function rotateFromOrigin(_p, _theta){
    var _qx = _p.x * Math.cos(_theta) - _p.y * Math.sin(_theta);
    var _qy = _p.x * Math.sin(_theta) + _p.y * Math.cos(_theta);
    
    return {x: _qx, y: _qy};
}

// function for get angle array between two points
function getAngleVariation(_ptrj, _htrj){
    var _returnAngles = [];

    for(var i=0; i&lt;_ptrj.length; i++){
        var _angle = Math.atan2(_htrj[i].y-_ptrj[i].y, _htrj[i].x-_ptrj[i].x);
    
        if(_angle &lt; 0)  _angle += (2 * Math.PI);
            _angle = _angle%(2*Math.PI);
            
            _returnAngles.push(_angle);
        }
        return _returnAngles;
    }

// DTW Prepare
function normalizeTrj(_data) {
    // normalize trj with max width 1
    
    var _returnTrj = [];
    
    var _xMean = 0;
    var _yMean = 0;
    var _xMax = Number.NEGATIVE_INFINITY;
    var _xMin = Number.POSITIVE_INFINITY;

    for (var i = 0; i &lt; _data.length; i++) {
        _xMean = _xMean + _data[i].x;
        _yMean = _yMean + _data[i].y;
        if(_data[i].x &gt; _xMax) _xMax = _data[i].x;
        if(_data[i].x &lt; _xMin) _xMin = _data[i].x;
    }
    _xMean = _xMean / _data.length;
    _yMean = _yMean / _data.length;
    
    var _width = _xMax - _xMin;

    for (var i = 0; i &lt; _data.length; i++) {
        _returnTrj.push({x: ((_data[i].x - _xMean)/_width).toFixed(4), y: ((_data[i].y - _yMean)/_width).toFixed(4)});
    }
    return {trajectory: _returnTrj, width: _width, dx: _xMean, dy: _yMean};
}

function normalizeAngle(_data) {
    var _returnAngle = [];
    
    var _aMean = 0;

    for (var i = 0; i &lt; _data.length; i++) {
        _aMean = _aMean + _data[i]
    }
    _aMean = _aMean / _data.length;

    /*
    for (var i = 0; i &lt; _data.length; i++) {
        _returnAngle.push(_data[i] - _aMean);
    }
    */

    for (var i = 0; i &lt; _data.length; i++) {
        _returnAngle.push( (_data[i] - _data[0]).toFixed(4) ); // starting from 0
    }

    return {angle: _returnAngle, da: _aMean};
}

// distance function
function distFuncTrj( a, b ) {
    var xdiff = a.x - b.x;
    var ydiff = a.y - b.y;
    
    var diff = Math.sqrt(xdiff*xdiff + ydiff*ydiff);
    return diff;
}
function distFuncAngle( a, b ) {
    var adiff = a - b;
    
    var diff = Math.abs(adiff);
    return diff;
}

// DTW library
( function() {
"use strict";
function DynamicTimeWarping ( ts1, ts2, distanceFunction ) {
    var ser1 = ts1;
    var ser2 = ts2;
    var distFunc = distanceFunction;
    var distance;
    var matrix;
    var path;

var getDistance = function() {
    if ( distance !== undefined ) {
        return distance;
    }
;
    //console.log(ser1)
    //console.log(ser1.length)
    //console.log(ser2)
    //console.log(ser2.length)
    matrix = [];
for ( var i = 0; i &lt; ser1.length; i++ ) {
    matrix[ i ] = [];
for ( var j = 0; j &lt; ser2.length; j++ ) {
    var cost = Infinity;
    if ( i &gt; 0 ) {
        cost = Math.min( cost, matrix[ i - 1 ][ j ] );
        if ( j &gt; 0 ) {
        cost = Math.min( cost, matrix[ i - 1 ][ j - 1 ] );
        cost = Math.min( cost, matrix[ i ][ j - 1 ] );
      }
    } else {
        if ( j &gt; 0 ) {
            cost = Math.min( cost, matrix[ i ][ j - 1 ] );
        } else {
            cost = 0;
        }
    }
    matrix[ i ][ j ] = cost + distFunc( ser1[ i ], ser2[ j ] );
    }
}

    return matrix[ ser1.length - 1 ][ ser2.length - 1 ];
};

    this.getDistance = getDistance;

var getPath = function() {
    if ( path !== undefined ) {
        return path;
    }
    if ( matrix === undefined ) {
        getDistance();
    }
    var i = ser1.length - 1;
    var j = ser2.length - 1;
    path = [ [ i, j ] ];
while ( i &gt; 0 || j &gt; 0 ) {
if ( i &gt; 0 ) {
    if ( j &gt; 0 ) {
        if ( matrix[ i - 1 ][ j ] &lt; matrix[ i - 1 ][ j - 1 ] ) {
            if ( matrix[ i - 1 ][ j ] &lt; matrix[ i ][ j - 1 ] ) {
                path.push( [ i - 1, j ] );
                i--;
            } else {
                path.push( [ i, j - 1 ] );
                j--;
            }
        } else {
        if ( matrix[ i - 1 ][ j - 1 ] &lt; matrix[ i ][ j - 1 ] ) {
            path.push( [ i - 1, j - 1 ] );
            i--;
            j--;
        } else {
            path.push( [ i, j - 1 ] );
            j--;
        }
    }
    } else {
        path.push( [ i - 1, j ] );
        i--;
}
} else {
    path.push( [ i, j - 1 ] );
    j--;
}
}
    path = path.reverse();

    return path;
};

this.getPath = getPath;
}

var root = typeof self === "object" &amp;&amp; self.self === self &amp;&amp; self ||
typeof global === "object" &amp;&amp; global.global === global &amp;&amp; global ||
this;

if ( typeof exports !== "undefined" &amp;&amp; !exports.nodeType ) {
if ( typeof module !== "undefined" &amp;&amp; !module.nodeType &amp;&amp; module.exports ) {
    exports = module.exports = DynamicTimeWarping;
}
    exports.DynamicTimeWarping = DynamicTimeWarping;
} else {
    root.DynamicTimeWarping = DynamicTimeWarping;
}

if ( typeof define === "function" &amp;&amp; define.amd ) {
    define( "dynamic-time-warping", [], function() {
    return DynamicTimeWarping;
} );
}
}() );


&lt;/script&gt;</t>
<t tx="leo.20191210200953.1">&lt;script&gt;
    $('#panel_fab_Show3DLink').on('change', function(){
        show3Dlinks( $(this).prop('checked') );
    })

    $('#btn_stackPlus').click(function(){
      if(selectedLink==null) return false;
        var _link = currentAssemblyGroup.findObjectFromElement(selectedLink);
        if(_link != null){
            selectedLink.stack++;
            _link.updateStack();
        }
    });

    $('#btn_stackMinus').click(function(){
      if(selectedLink==null) return false;
        var _link = currentAssemblyGroup.findObjectFromElement(selectedLink);
        if(_link != null){
            selectedLink.stack--;
            _link.updateStack();
        }
    });

    $('#panel_fab_downloadLink').click(function(){
      var exporter = new THREE.OBJExporter();
      for(var i in currentAssemblyGroup.objectList){
          if(currentAssemblyGroup.objectList[i] instanceof Link3D){
            var _mesh = currentAssemblyGroup.objectList[i].link3DObject
            _mesh.geometry.scale(SCALE_TRANS, SCALE_TRANS, SCALE_TRANS);
            var result = exporter.parse( _mesh );
            _mesh.geometry.scale(1/SCALE_TRANS, 1/SCALE_TRANS, 1/SCALE_TRANS);

            saveAsText('mSketchLink'+i+'.obj', result);
          }
      }
    });

    $('#panel_fab_generateGear').click(function(){
      currentAssemblyGroup.makeGear();
    });

    $('#panel_fab_removeGear').click(function(){
      currentAssemblyGroup.removeGear();
    });

    $('#panel_fab_downloadGear').click(function(){
      var exporter = new THREE.OBJExporter();
      for(var i in currentAssemblyGroup.gearObjList){
          if(currentAssemblyGroup.gearObjList[i] instanceof Gear3D){
              var _mesh = currentAssemblyGroup.gearObjList[i].gearObject;
              _mesh.geometry.scale(SCALE_TRANS, SCALE_TRANS, SCALE_TRANS);
              var result = exporter.parse( _mesh );
              _mesh.geometry.scale(1/SCALE_TRANS, 1/SCALE_TRANS, 1/SCALE_TRANS);

              saveAsText('mSketchGear'+i+'.obj', result);
          }
      }
    });

    function show3Dlinks(_flag){
        Link3D.SHOW_3D = _flag;

        for(var i in AssemblyGroupList){
            AssemblyGroupList[i].updateRender();
            AssemblyGroupList[i].update();
        }
    }

&lt;/script&gt;</t>
<t tx="leo.20191210201039.1">&lt;script&gt;
// === Load Panel ===
$('#btn_addload').click(function(){
$('#panel_load_valueX').prop('disabled', true);
$('#panel_load_valueY').prop('disabled', true);
});
$('#btn_removeload').click(function(){
$('#panel_load_valueX').prop('disabled', true);
$('#panel_load_valueY').prop('disabled', true);
});

$('#panel_load_apply').click( function(){
applyLoad();
});

$('#panel_load').keyup(function(event){
if (event.keyCode == 13) {
applyLoad();
}
});

$('#panel_load_download').click( function(){
downloadLoadData();
});



var prevPosition 	= [];
var prevPointPair 	= null;

function getLoadInfoToLoadPanel(_valueX , _valueY){
if(!(toolState==TOOL_EDITLOAD)) return;
$('#panel_load_valueX').prop('disabled', false);
$('#panel_load_valueX').val(_valueX);
$('#panel_load_valueY').prop('disabled', false);
$('#panel_load_valueY').val(_valueY);
}

function applyLoad(){
if(!(toolState==TOOL_EDITLOAD)) return;
var newLoadValX = parseFloat($('#panel_load_valueX').val());
var newLoadValY = parseFloat($('#panel_load_valueY').val());
currentAssemblyGroup.loadList.get(loadIndex).setLoadX(newLoadValX);
currentAssemblyGroup.loadList.get(loadIndex).setLoadY(newLoadValY);
currentAssemblyGroup.load();
try360forAssemblies();
}

function downloadLoadData(){
var dataOut = JSON.parse(getMsketchInfoForPlane());

var loadData = [];
for(var i=0; i&lt;currentAssemblyGroup.loadList.length(); i++){
var tempLoads = {};
tempLoads.x = (currentAssemblyGroup.loadList.get(i).getGlobalPosition().x*SCALE_TRANS).toFixed(2);
tempLoads.y = (currentAssemblyGroup.loadList.get(i).getGlobalPosition().y*SCALE_TRANS).toFixed(2);
tempLoads.loadX = currentAssemblyGroup.loadList.get(i).getLoadX();
tempLoads.loadY = currentAssemblyGroup.loadList.get(i).getLoadY();
loadData.push(tempLoads);
}

dataOut.sketch.loads =  loadData;

dataOut = JSON.stringify(dataOut, null, '\t');

saveAsText($('#msketch-titlebar-filename').val()+"_Load"+findCurrentAssemblyNum()+".json", dataOut);
}

&lt;/script&gt;</t>
<t tx="leo.20191210201136.1">&lt;script&gt;

$('#setting_apply').click( function(){
applySettings();
});

function loadSettings(){
$('#setting_showGrid').prop('checked', msketchSettings.showGrid);
$('#setting_showText').prop('checked', msketchSettings.showText);
$('#setting_showPlane').prop('checked', msketchSettings.showPlane);

$('#setting_gridGap').val( msketchSettings.gridGap );
$('#setting_planeSize').val( msketchSettings.planeSize );

$('#setting_holeDiameter').val( msketchSettings.holeDiameter );
$('#setting_linkWidth').val( msketchSettings.linkWidth );
$('#setting_linkThickness').val( msketchSettings.linkThickness );

$('#setting_maxHistory').val( msketchSettings.MaxHistorySize );
}

function initSettings(){
$.ajax({
url: '/loadSettings',
method: 'post',
    success: function (data) {
        msketchSettings = JSON.parse(data.settings);
    
    // apply settings
    MAX_HISTORY = parseInt( msketchSettings.MaxHistorySize );

    for(var i=0; i&lt;AssemblyGroupList.length; i++){
        AssemblyGroupList[i].setSettings(msketchSettings);
        AssemblyGroupList[i].needsUpdate = true;
        AssemblyGroupList[i].load();
    }
},
    error: function (err) {
        showMessage("Setting Load failed");
    }
});
}

function applySettings(){
    msketchSettings.showGrid = $("#setting_showGrid").prop("checked");
    msketchSettings.showText = $("#setting_showText").prop("checked");
    msketchSettings.showPlane = $("#setting_showPlane").prop("checked");
    
    msketchSettings.gridGap = parseFloat( $('#setting_gridGap').val() );
    msketchSettings.planeSize = parseFloat( $('#setting_planeSize').val() );
    
    msketchSettings.holeDiameter = parseFloat( $('#setting_holeDiameter').val() );
    msketchSettings.linkWidth = parseFloat( $('#setting_linkWidth').val() );
    msketchSettings.linkThickness = parseFloat( $('#setting_linkThickness').val() );

//apply setting to 3D link (yw_edited)
Link3D.HEIGHT = msketchSettings.linkThickness;
Link3D.EXTRUDE_SET.amount = msketchSettings.linkThickness;
Link3D.HOLE_SIZE = (msketchSettings.holeDiameter/SCALE_TRANS)/2;

msketchSettings.MaxHistorySize = parseInt( $('#setting_maxHistory').val() );

$.ajax({
    url: '/saveSettings',
    method: 'post',
    data: {
    settings: JSON.stringify(msketchSettings, null, '\t')
},
success: function (data) {
    showMessage("Setting was applied.");
    initSettings();
},
    error: function (err) {
        showMessage("Setting save failed");
    }
});

}

&lt;/script&gt;</t>
<t tx="leo.20191210201840.1">&lt;script&gt;
$('#panel_close_btn').click(function(){
$('#msketch_panel').removeClass('expand');
removePanelActiveClass();
});

$('#btn_panel_move').click(function(){
removePanelActiveClass();
$('#btn_panel_move').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_move').show();
});

$('#btn_panel_plane').click(function(){
removePanelActiveClass();
$('#btn_panel_plane').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_plane').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_motor').click(function(){
removePanelActiveClass();
$('#btn_panel_motor').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_motor').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_pattern').click(function(){
removePanelActiveClass();
$('#btn_panel_pattern').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_pattern').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_analysis').click(function(){
removePanelActiveClass();
$('#btn_panel_analysis').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_analysis').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_opt').click(function(){
removePanelActiveClass();
$('#btn_panel_opt').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_opt').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_gen').click(function(){
removePanelActiveClass();
$('#btn_panel_gen').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_gen').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_fab').click(function(){
removePanelActiveClass();
$('#btn_panel_fab').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_fab').show();
getPlaneInfoToPlanePanel();
});

$('#btn_panel_load').click(function(){
removePanelActiveClass();
$('#btn_panel_load').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_load').show();
getPlaneInfoToPlanePanel();
});

$('#btn_settings').click(function(){
removePanelActiveClass();
$('#btn_settings').addClass('active');
$('#msketch_panel').addClass('expand');
$('#panel_settings').show();
getPlaneInfoToPlanePanel();

loadSettings();
});

function removePanelActiveClass(){
$('.msketch-sidebar').children().removeClass('active');
$('#msketch_panel').children().hide();
$('#panel_close_btn').show();
};
&lt;/script&gt;</t>
<t tx="leo.20191210201926.1">&lt;script&gt;
function showMessage(_msg){
$('#msketch_message').text(_msg);
//$('#msketch_message').animate({bottom: "0"}, 300)
$('#msketch_message').css('bottom', 0);

setTimeout(function(){
$('#msketch_message').css('bottom', '-48px');
},2000);
}
&lt;/script&gt;</t>
<t tx="leo.20191210202921.1"></t>
<t tx="leo.20191210202937.1"></t>
<t tx="leo.20191210202950.1">//--------------------
// Point2D
//--------------------
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203004.1">function Point2D(_x, _y){
    this.x = _x;
    this.y = _y;
}
</t>
<t tx="leo.20191210203004.10">this.get = function (_index){
    return this.array[_index];
};
</t>
<t tx="leo.20191210203004.11">this.addAll = function (obj){
    if (obj instanceof Array){
        for (var i=0;i&lt;obj.length;i++){
            this.add(obj[i]);
        }
    } else if (obj instanceof ArrayList){
        for (var i=0;i&lt;obj.length();i++){
            this.add(obj.get(i));
        }
    }
    return true;
};
</t>
<t tx="leo.20191210203004.12">this.remove = function (obj){
    if (!(obj instanceof ArrayList)){
        var _index = this.array.indexOf(obj);
        if(_index != -1){
            this.array.splice(_index, 1);
            return true;
        }
        else{
            return false;
        }
    }
    else if(obj instanceof ArrayList){
        for(var _e in obj.array){
            this.remove(obj.get(_e));
        }
    }

};
</t>
<t tx="leo.20191210203004.13">this.removeOf = function (_index){
    this.array.splice(_index, 1);
};
</t>
<t tx="leo.20191210203004.14">this.clear = function (obj){
    this.array = [];
};
</t>
<t tx="leo.20191210203004.15">this.isEmpty = function (obj){
    var _isEmpty = false;
    if(this.array.length==0){
        _isEmpty = true;
    }
    else{
        _isEmpty = false;
    }
    return _isEmpty;
};
</t>
<t tx="leo.20191210203004.16">this.contains = function(obj){
    var _index = this.array.indexOf(obj);
    var returnValue = false;
    if(_index != -1){
        returnValue = true;
    }
    return returnValue;
}
</t>
<t tx="leo.20191210203004.17">this.containsAll = function(obj){
    if(obj instanceof ArrayList){
        for(var _e in obj.array){
            if(!this.contains(obj.get(_e))){
                return false;
            }
        }
    }
    return true;
}
</t>
<t tx="leo.20191210203004.18">this.set = function(_index, obj){
    this.array[_index] = obj;
}
</t>
<t tx="leo.20191210203004.19">this.indexOf = function(obj){
    return this.array.indexOf(obj);
}
</t>
<t tx="leo.20191210203004.2">Point2D.prototype.getX = function(){
    return this.x;
}
</t>
<t tx="leo.20191210203004.20">MMath.distToLine = function(_p, _v, _w) {
    return Math.sqrt(MMath.distToLineSquared(_p, _v, _w));
  }

</t>
<t tx="leo.20191210203004.21">MMath.distToLineSquared = function(_p, _v, _w) {
    var t = MMath.getNearestTfromALine(_p, _v, _w);
    var _nearestP = new Point2D(_v.getX()*(1-t)+_w.getX()*t, _v.getY()*(1-t)+_w.getY()*t);
    return MMath.dist2(_p, _nearestP);
  }

</t>
<t tx="leo.20191210203004.22">MMath.distToSegment = function(_p, _v, _w) {
    return Math.sqrt(MMath.distToSegmentSquared(_p, _v, _w));
}
</t>
<t tx="leo.20191210203004.23">MMath.distToSegmentSquared = function(_p, _v, _w) {
    var t = Math.max(0, Math.min(1, MMath.getNearestTfromALine(_p, _v, _w)));
    var _nearestP = new Point2D(_v.getX()*(1-t)+_w.getX()*t, _v.getY()*(1-t)+_w.getY()*t);
    return MMath.dist2(_p, _nearestP);
}

</t>
<t tx="leo.20191210203004.24">MMath.getNearestTfromALine = function(_p, _v, _w) {
    var l2 = MMath.dist2(_v, _w);
    if (l2==0) return 0;

    var t = ((_p.getX()-_v.getX()) * (_w.getX() - _v.getX()) + (_p.getY() - _v.getY()) * (_w.getY() - _v.getY())) / l2;
    return t;
}

</t>
<t tx="leo.20191210203004.25">MMath.dist2 = function(_v, _w) {
    return (_v.getX()-_w.getX())*(_v.getX()-_w.getX()) + (_v.getY()-_w.getY())*(_v.getY()-_w.getY());
}

</t>
<t tx="leo.20191210203004.26">MMath.dist = function(_v, _w) {
    return Math.sqrt(MMath.dist2(_v, _w));
}


//--------------------
// Rad/Deg Conversion
//--------------------

</t>
<t tx="leo.20191210203004.27">Math.radians = function(degrees) {
  return degrees * Math.PI / 180;
};

</t>
<t tx="leo.20191210203004.28">Math.degrees = function(radians) {
  return radians * 180 / Math.PI;
};
</t>
<t tx="leo.20191210203004.29">Math.map = function(value, low1, high1, low2, high2) {
    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
}


//--------------------
// TimeStamp
//--------------------

</t>
<t tx="leo.20191210203004.3">Point2D.prototype.getY = function(){
    return this.y;
}
</t>
<t tx="leo.20191210203004.30">function getTimeStamp() {
  var d = new Date();
  var s =
    leadingZeros(d.getFullYear(), 4) +
    leadingZeros(d.getMonth() + 1, 2) +
    leadingZeros(d.getDate(), 2) + "_" +

    leadingZeros(d.getHours(), 2) +
    leadingZeros(d.getMinutes(), 2);
    //leadingZeros(d.getSeconds(), 2);

  return s;
}

</t>
<t tx="leo.20191210203004.31">function leadingZeros(n, digits) {
  var zero = '';
  n = n.toString();

  if (n.length &lt; digits) {
    for (i = 0; i &lt; digits - n.length; i++)
      zero += '0';
  }
  return zero + n;
}
</t>
<t tx="leo.20191210203004.4">Point2D.prototype.setLocation = function(arg1, arg2){
    if(arguments.length == 1 ){
        this.x = arg1.x;
        this.y = arg1.y;
    }
    else if(arguments.length == 2){
        this.x = arg1;
        this.y = arg2;
    }
}
</t>
<t tx="leo.20191210203004.5">Point2D.prototype.distance = function(_x, _y){
    var d = Math.sqrt((this.x-_x)*(this.x-_x) + (this.y-_y)*(this.y-_y));
    return d;
}

//--------------------
// ArrayList Implementation Class
//--------------------

</t>
<t tx="leo.20191210203004.6">function ArrayList(){
    this.array = new Array();
    @others
}


//--------------------
// MMATH Class
//--------------------
function MMath(){}

</t>
<t tx="leo.20191210203004.7">this.add = function(obj){
    this.array.push(obj);
    return true;
};
</t>
<t tx="leo.20191210203004.8">this.addIn = function(_index, obj){
    this.array.splice(_index, 0, obj);
};
</t>
<t tx="leo.20191210203004.9">this.length = function (){
    return this.array.length;
};
</t>
<t tx="leo.20191210203049.1"></t>
<t tx="leo.20191210203119.1">/**
 * @author juwhan kim
 * @author hanjong kim
 * last modified: 2016.06.30
 */

// ==========================================================================================
//						Constraint Class
// ==========================================================================================

// === Constructor ===
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203154.1">function Constraint() {
    this.name;
    this.link = new ArrayList();
    this.DOF = 0;
    this.BASE = 0;
    this.TARGET = 1;
}

// === IO ===
</t>
<t tx="leo.20191210203154.2">Constraint.prototype.getAllLink = function() {
    return this.link;
}
</t>
<t tx="leo.20191210203154.3">Constraint.prototype.getLink = function(_index) {
    if (this.link.length() &gt;= _index + 1) {
        return this.link.get(_index);
    } else {
        return null;
    }

}
</t>
<t tx="leo.20191210203154.4">Constraint.prototype.setLink = function(_index, _link) {
    if (this.link.length() &gt;= _index + 1) {
        this.link.set(_index, _link);
    } else {
        while (this.link.length() &lt; _index) {
            this.link.add(null);
        }
        this.link.add(_link);
    }
}
</t>
<t tx="leo.20191210203154.5">Constraint.prototype.getDOF = function() {
    return MechConstraint.DOF;
}
</t>
<t tx="leo.20191210203240.1">/**
 * @author juwhan kim
 * @author hanjong kim
 * last modified: 2016.06.30
 */

// ==========================================================================================
//						AngularConstraint Class
// ==========================================================================================

/**
    AngularConstraint
    defines a relative angle from the baseLink to the targetLink.
*/

// === Constructor ===
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203247.1">function AngularConstraint(arg1, arg2) {
    Constraint.apply(this, arguments);
    this.DOF = -1;
    this.angle;
    if (arguments.length &gt; 0) {
        this.setLink(this.BASE, arg1);
        this.setLink(this.TARGET, arg2);
        this.angle = arg2.getAngle() - arg1.getAngle();
    }

    this.name = "AngularConstraint" + AngularConstraint.COUNTER++;
}
AngularConstraint.COUNTER = 1;
AngularConstraint.prototype = new Constraint();
AngularConstraint.prototype.constructor = AngularConstraint;

// === IO ===
</t>
<t tx="leo.20191210203247.2">AngularConstraint.prototype.setAngle = function(_angle) {
    while (_angle &gt; 2 * Math.PI) {
        _angle -= 2 * Math.PI;
    }
    while (_angle &lt; 0) {
        _angle += 2 * Math.PI;
    }
    this.angle = _angle;
}
</t>
<t tx="leo.20191210203247.3">AngularConstraint.prototype.getAngle = function() {
    return this.angle;
}
</t>
<t tx="leo.20191210203303.1">/**
 * @author juwhan kim
 * @author hanjong kim
 * last modified: 2016.06.30
 */

// ==========================================================================================
//						CoaxialConstraint Class
// ==========================================================================================

/**
    CoaxialConstraint
    defines xy coordiante constraint about two points
*/

// === Constructor ===
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203308.1">function CoaxialConstraint(arg1, arg2, arg3, arg4, arg5) {
    Constraint.apply(this, arguments);
    this.point = new ArrayList();
    this.DOF = -2;

    switch(arguments.length){
        case 1: // name
            this.name = arg1;
            break;
        case 4: // Link _baseLink, Point2D _basePoint, Link _targetLink, Point2D _targetPoint
            if(arg1.getPointList().contains(arg2) &amp;&amp; arg3.getPointList().contains(arg4)){
                this.link.add(arg1);
                this.point.add(arg2);
                this.link.add(arg3);
                this.point.add(arg4);
            }
            this.name = "CoaxialConstraint" + CoaxialConstraint.COUNTER++;
            break;
        case 5: // String _name, Link _baseLink, Point2D _basePoint, Link _targetLink, Point2D _targetPoint
            if(arg2.getPointList().contains(arg3) &amp;&amp; arg4.getPointList().contains(arg5)){
                this.link.add(arg2);
                this.point.add(arg3);
                this.link.add(arg4);
                this.point.add(arg5);
            }
            this.name = arg1;
            break;

    }
}
CoaxialConstraint.COUNTER = 1;
CoaxialConstraint.prototype = new Constraint();
CoaxialConstraint.prototype.constructor = CoaxialConstraint;


// === IO ===
</t>
<t tx="leo.20191210203308.2">CoaxialConstraint.prototype.toString = function() {
    var returnValue = "";

    for (var i = 0; i &lt; this.point.length(); i++) {
        returnValue += "[";
        returnValue += this.getLink(i);
        returnValue += "(";
        var _num = this.getPoint(i).getX();
        returnValue += _num.toFixed(2);

        returnValue += ", ";
        var _num = this.getPoint(i).getY();
        returnValue += _num.toFixed(2);

        returnValue += ")]\t";
    }
    return returnValue;
}
</t>
<t tx="leo.20191210203308.3">CoaxialConstraint.prototype.addPoint = function(_link, _point) {
    this.link.add(_link);
    this.point.add(_point);
}
</t>
<t tx="leo.20191210203308.4">CoaxialConstraint.prototype.removePoint = function(_point) {
    if (this.point.contains(_point)) {
        this.link.removeOf(this.point.indexOf(_point));
        this.point.remove(_point);

    }
}
</t>
<t tx="leo.20191210203308.5">CoaxialConstraint.prototype.getAllPoint = function() {
    return this.point;
}
</t>
<t tx="leo.20191210203308.6">CoaxialConstraint.prototype.getPoint = function(_index) {
    if (this.point.length() &gt; _index) {
        return this.point.get(_index);
    }
    return null;
}
</t>
<t tx="leo.20191210203325.1">/**
 * @author juwhan kim
 * @author hanjong kim
 * last modified: 2017.11.07
 */

// ==========================================================================================
//						Slider Constraint Class
// ==========================================================================================
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203332.1">function SliderConstraint(_baseLink, _targetLink, _p1, _p2) {
    Constraint.apply(this, arguments);

    this.p1 = new Point2D(null, null);
    this.p2 = new Point2D(null, null);
    this.DOF = -2;
    this.name = "SliderConstraint" + SliderConstraint.COUNTER++;

    if(arguments.length&gt;0){
        this.setLink(this.BASE, _baseLink);
        this.setLink(this.TARGET, _targetLink);
        this.setPoints([_p1, _p2]);
    }

    
}
SliderConstraint.COUNTER = 1;
SliderConstraint.prototype = new Constraint();
SliderConstraint.prototype.constructor = SliderConstraint;

</t>
<t tx="leo.20191210203332.2">SliderConstraint.prototype.toString = function() {
    return this.name;
}
</t>
<t tx="leo.20191210203332.3">SliderConstraint.prototype.getPoint1 = function(){
  return this.p1;
}
</t>
<t tx="leo.20191210203332.4">SliderConstraint.prototype.setPoint1 = function(_p1){
  this.p1 = _p1;
}
</t>
<t tx="leo.20191210203332.5">SliderConstraint.prototype.getPoint2 = function(){
  return this.p2;
}
</t>
<t tx="leo.20191210203332.6">SliderConstraint.prototype.setPoint2 = function(_p2){
  this.p2 = _p2;
}
</t>
<t tx="leo.20191210203332.7">SliderConstraint.prototype.getPoints = function(){
  return [this.p1, this.p2];
}
</t>
<t tx="leo.20191210203332.8">SliderConstraint.prototype.setPoints = function(_pts){
  if(_pts!=null &amp;&amp; _pts.length==2){
    this.p1 = _pts[0];
    this.p2 = _pts[1];
    return true;
  } else {
    return false;
  }
}

</t>
<t tx="leo.20191210203332.9">SliderConstraint.prototype.getAngle = function(){
    return Math.atan2(this.p2.getY()-this.p1.getY(), this.p2.getX()-this.p1.getX());
}
</t>
<t tx="leo.20191210203414.1"></t>
<t tx="leo.20191210203432.1">// =============================================================================
// 								Assembly Class
// =============================================================================
// from m.sketch 2.4 java
// updated on 2015.11.02

/**
* The basic unit of calculating mechanism.
*/


@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203441.1">function Assembly(){
    this.allElement = new ArrayList();
    this.allConstraint = new ArrayList();
    this.allActuator = new ArrayList();
    this.unspecifiedElementList = new ArrayList();
    this.space;
}

// ============================ Space (fixed points) =================================
</t>
<t tx="leo.20191210203441.10">Assembly.prototype.removePointInConstraint = function(_point){
    for(var i=0; i&lt;this.allConstraint.length(); i++){
        if(this.allConstraint.get(i) instanceof CoaxialConstraint){
            var cc = this.allConstraint.get(i);
            for(var j = cc.getAllPoint().length()-1; j&gt;=0; j--){
                if(cc.getPoint(j) == _point){
                    cc.removePoint(_point);
                    this.removeActuatorInConstraint(cc);
                }
            }
        }
    }

    this.checkCoaxialConstraint();
}
</t>
<t tx="leo.20191210203441.11">Assembly.prototype.appendCoaxialConstraint = function(_baseLink, _basePoint, _targetLink, _targetPoint){
    var links = [_baseLink, _targetLink];
    var pts = [_basePoint, _targetPoint];

    var cc = new CoaxialConstraint(_baseLink, _basePoint, _targetLink, _targetPoint);
    this.addConstraint(cc);

    this.checkCoaxialConstraint();
}
//** This function is to merge constrains with more than 3 links.
//** It will not be necessary for creating pre-defined Jansen Mech.
</t>
<t tx="leo.20191210203441.12">Assembly.prototype.checkCoaxialConstraint = function(){
    for(var i=this.allConstraint.length()-1; i&gt;0; i--){
        if(this.allConstraint.get(i) instanceof CoaxialConstraint){
            var cc = this.allConstraint.get(i);

            // to merge duplicate CoaxialConstraint //
            for(var p=0; p&lt;cc.getAllPoint().length(); p++){
                var pt = cc.getAllPoint().get(p);

                for(var j=i-1; j&gt;=0; j--){
                    if(this.allConstraint.get(j) instanceof CoaxialConstraint){
                        var cc2 = this.allConstraint.get(j);
                        var isDuplicated = false;

                        for(var t=0; t&lt;cc2.getAllPoint().length(); t++){
                            if(cc2.getPoint(t)==pt){
                              // found a duplicate Coaxialconstraint //
                              isDuplicated = true;
                              break;
                            }
                        }

                        if(isDuplicated){
                            for(var t=0; t&lt;cc2.getAllPoint().length(); t++){
                              var checker = false;
                              for(var m=0; m&lt;cc.getAllPoint().length(); m++){
                                if(cc2.getPoint(t)==cc.getPoint(m)){
                                  checker = true;
                                }
                              }
                              if( !checker ){
                                cc.addPoint(cc2.getLink(t), cc2.getPoint(t));
                              }
                            }
                            //check JA
                            for(var k=0; k&lt;this.allActuator.length(); k++){
                                if(this.allActuator.get(k).getCoaxialConstraint() == cc2){
                                    this.allActuator.get(k).setCoaxialConstraint(cc);
                                }
                            }

                            this.allConstraint.remove(cc2);

                            i--;
                        }
                    }
                }
            }
        }
    }

    for(var i=this.allConstraint.length()-1; i&gt;=0; i--){
      if(this.allConstraint.get(i) instanceof CoaxialConstraint){
        var cc = this.allConstraint.get(i);
        if(cc.getAllPoint().length()&lt;=1){
          this.allConstraint.remove(cc);
        }
      }
    }
}
</t>
<t tx="leo.20191210203441.13">Assembly.prototype.printConstraints = function(){
    for(var i=0; i&lt;allConstraint.length(); i++){
      console.log(i+". ");
      console.log(allConstraint.get(i));
    }
}

// ============================ Actuators  =================================
</t>
<t tx="leo.20191210203441.14">Assembly.prototype.getAllActuator = function(){
    return this.allActuator;
}
</t>
<t tx="leo.20191210203441.15">Assembly.prototype.addActuator = function(_actuator){
    if(this.allActuator.contains(_actuator)) return false;
    var returnValue = this.allActuator.add(_actuator);
    if(returnValue){
      _actuator.attach(this);
    }
    return returnValue;
}
</t>
<t tx="leo.20191210203441.16">Assembly.prototype.removeActuator = function(_actuator){
    var returnValue = this.allActuator.remove(_actuator);
    if(returnValue){
      _actuator.dettach(this);
    }
    return returnValue;
}
</t>
<t tx="leo.20191210203441.17">Assembly.prototype.removeActuatorInConstraint = function(_cc){
    for(var i=0; i&lt;this.allActuator.length(); i++){

        if(this.allActuator.get(i) instanceof JointActuator){
            var ja = this.allActuator.get(i);
            if(ja.coaxialConstraint == _cc){
                this.removeActuator(ja)
            }
        }
    }

    this.checkCoaxialConstraint();
}

// ============================ Check DOF  =================================
</t>
<t tx="leo.20191210203441.18">Assembly.prototype.emptyUnspecified = function(){
    this.unspecifiedElementList.clear();
    return this.unspecifiedElementList.isEmpty();
}
</t>
<t tx="leo.20191210203441.19">Assembly.prototype.getUnspecified = function(){
    return this.unspecifiedElementList;
}
</t>
<t tx="leo.20191210203441.2">Assembly.prototype.getSpace = function(){
    return this.space;
}
</t>
<t tx="leo.20191210203441.20">Assembly.prototype.addUnspecified = function(_element){
    if(!(_element instanceof ArrayList)){
        return this.unspecifiedElementList.add(_element);
    }
    else{
        return this.unspecifiedElementList.addAll(_element);
    }
}
</t>
<t tx="leo.20191210203441.21">Assembly.prototype.getDOF = function(){
    var returnValue = 0;

    for(var ei in this.allElement.array){
        var e = this.allElement.get(ei);
        returnValue += e.getDOF();
    }
    for(var ci in this.allConstraint.array){
        var c = this.allElement.get(ci);
        returnValue += c.getDOF();
    }
    return returnValue;
}

// ============================ Interfacing  =================================
</t>
<t tx="leo.20191210203441.22">Assembly.prototype.getGlobalPosition = function(_p){
    var belongedLink = this.getBelongedLink(_p);
    if(belongedLink!=null){
        return belongedLink.getGlobalPosition(_p);
    } else {
        return null;
    }
}
</t>
<t tx="leo.20191210203441.23">Assembly.prototype.getBelongedLink = function(_p){
    for(var ei in this.allElement.array){
        var e = this.allElement.get(ei);
        if(e instanceof Link){
            var _pointList = e.getPointList();

            for(pi in _pointList.array){
                var p = _pointList.get(pi);
                if(p == _p ){
                    return e;
                }
            }
        }
    }
    return null;
}
</t>
<t tx="leo.20191210203441.24">Assembly.prototype.savePositions = function(){
    for(var ei in this.allElement.array){
      var e = this.allElement.get(ei);
      e.savePosition();
    }
    for(var ai in this.allActuator.array){
        var a = this.allActuator.get(ai);

        if(a instanceof JointActuator){
            a.savePosition();
        }
    }
}
</t>
<t tx="leo.20191210203441.25">Assembly.prototype.restorePositions = function(){
    for(var ei in this.allElement.array){
        var e = this.allElement.get(ei);
        e.restorePosition();
    }
    for(var ai in this.allActuator.array){
        var a = this.allActuator.get(ai);

        if(a instanceof JointActuator){
            a.restorePosition();
        }
    }
}

// Get Element by name
</t>
<t tx="leo.20191210203441.26">Assembly.prototype.getLinkByName = function(_name){
    var elementList = this.getAllElement();

    for(var ei in elementList.array){
        var e = elementList.get(ei);
        if(e instanceof Space || e instanceof Link){
            if(e.name==_name){
                return e;
            }
        }
    }
    return null;
}
</t>
<t tx="leo.20191210203441.27">Assembly.prototype.getConstraintByName = function(_name){
    var constraintList = this.getAllConstraint();

    for(var ci in constraintList.array){
        var c = constraintList.get(ci);
        if(c instanceof CoaxialConstraint){
            if(c.name==_name){
                return c;
            }
        }
    }
    return null;
}
</t>
<t tx="leo.20191210203441.3">Assembly.prototype.addSpace = function(_space){
    if(_space != null){
        this.space = _space;
    }
    return this.addElement(_space);
}

// ============================ Elements (both Link and Space) =================================
</t>
<t tx="leo.20191210203441.4">Assembly.prototype.getAllElement = function(){
    return this.allElement;
}
</t>
<t tx="leo.20191210203441.5">Assembly.prototype.addElement = function(_element){
    if(!(_element instanceof ArrayList)){
        if(this.allElement.contains(_element)) return false;
        return this.allElement.add(_element);
    }
    else{
        var returnValue = false;
        for(var ei in _element.array){
            e = _element.get(ei);
            returnValue = returnValue || this.addElement(e);
        }
        return returnValue;
    }
}

</t>
<t tx="leo.20191210203441.6">Assembly.prototype.removeElement = function(_element){
    if(!(_element instanceof ArrayList)){
        if(_element instanceof Link){
            for(var i=0; i&lt;this.allActuator.length(); i++){
                if(this.allActuator.get(i) instanceof JointActuator){
                    var ja = this.allActuator.get(i);
                    if(ja.getBaseLink() == _element || ja.getTargetLink() == _element){
                        this.allActuator.remove(ja);
                    }
                }
            }
            for(var i=0; i&lt;this.allConstraint.length(); i++){
                if(this.allConstraint.get(i) instanceof SliderConstraint){
                    var sc = this.allConstraint.get(i);
                    if(sc == _element.baseSC){
                        this.allConstraint.remove(sc);
                    }
                }
            }
        }
        return this.allElement.remove(_element);
    }
    else{
        var returnValue = false;
        for(var ei in _element.array){
            e = _element.get(ei);
            console.log(this.removeElement(e));
            returnValue = returnValue || this.removeElement(e);
        }
        return this.allElement.remove(_element);
    }
}

// ============================ Constraint  =================================
</t>
<t tx="leo.20191210203441.7">Assembly.prototype.getAllConstraint = function(){
    return this.allConstraint;
}
</t>
<t tx="leo.20191210203441.8">Assembly.prototype.addConstraint = function(_constraint){
    if(this.allConstraint.contains(_constraint)) return false;
    return this.allConstraint.add(_constraint);
}
</t>
<t tx="leo.20191210203441.9">Assembly.prototype.removeConstraint = function(_constraint){
    return this.allConstraint.remove(_constraint);
}
</t>
<t tx="leo.20191210203456.1">//-------------------
// Linkage Group Class
//-------------------
// from m.sketch 2.4 java
// updated on 2015.11.02

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203501.1">function LinkGroup(_link){
    this.linkList = new ArrayList();
    this.relativePosition;
    this.relativeAngle;
    this.positionRelativeTo = null;
    this.angleRelativeTo = null;

    var arg_num = arguments.length;
    switch(arg_num){
        case 0:
            this.relativePosition = new Point2D(0,0);
            this.relativeAngle = 0;
            break;
        case 1:
            this.relativePosition = new Point2D(0,0);
            this.relativeAngle = 0;
            this.linkList.add(_link);
            break;
    }

}

</t>
<t tx="leo.20191210203501.10">LinkGroup.prototype.findOutgoingSliderConstraint = function(_constraintList) {
  var returnValue = new ArrayList();

  for (var ci=0; ci&lt; _constraintList.array.length; ci++) {
      var c = _constraintList.array[ci];

    if (c instanceof SliderConstraint) {
      var sc = c;
      var base = sc.getLink(sc.BASE);
      var target = sc.getLink(sc.TARGET);

      if (base!=null &amp;&amp; target!=null) {
        if (this.linkList.contains(base) &amp;&amp; !this.linkList.contains(target)) {
          returnValue.add(sc);
        }
        //for(Link l:linkList){
        //  if(base == l &amp;&amp; ){

        //  }
        //}
      }
    }
  }
  return returnValue;
}

</t>
<t tx="leo.20191210203501.11">LinkGroup.prototype.findOutgoingAngularConstraint = function(_constraintList){
    //console.log("[LinkGroup.findOutgoingAngularConstraint] " + _constraintList.array[0].constructor.name);
    var returnValue = new ArrayList();
    for(var ci=0; ci&lt; _constraintList.array.length; ci++){
        var c = _constraintList.array[ci];
        if(c instanceof AngularConstraint){
            for(var i=0; i&lt;2; i++){
                if(this.linkList.contains(c.getLink(i)) &amp;&amp; !this.linkList.contains(c.getLink(1-i))){
                    returnValue.add(new ACI(c, 1-i));
                }
            }
        }
    }
    return returnValue;

}
</t>
<t tx="leo.20191210203501.12">LinkGroup.prototype.getLocalPosition = function(_l, _p){
    var x = _l.getOriginPoint().getX() + _p.getX()*Math.cos(_l.getAngle()) - _p.getY()*Math.sin(_l.getAngle());
    var y = _l.getOriginPoint().getY() + _p.getX()*Math.sin(_l.getAngle()) + _p.getY()*Math.cos(_l.getAngle());
    return new Point2D(x, y);
}
</t>
<t tx="leo.20191210203501.13">LinkGroup.prototype.getLocalAngle = function(_l, _p){
    var localPosition = this.getLocalPosition(_l, _p);
    return Math.atan2(localPosition.getY(), localPosition.getX());
}
</t>
<t tx="leo.20191210203501.14">LinkGroup.prototype.merge = function(_targetLG, _groupList){
    for(var li=0; li&lt; _targetLG.getLinkList().array.length; li++){
        l = _targetLG.getLinkList().array[li];

        var ox=l.getOriginPoint().getX();
        var oy=l.getOriginPoint().getY();

        var rx=ox*Math.cos(+_targetLG.getRelativeAngle())-oy*Math.sin(+_targetLG.getRelativeAngle())+_targetLG.relativePosition.getX();
        var ry=ox*Math.sin(+_targetLG.getRelativeAngle())+oy*Math.cos(+_targetLG.getRelativeAngle())+_targetLG.relativePosition.getY();

        l.setOriginPoint(rx,ry);
        l.setAngle( l.getAngle() + _targetLG.getRelativeAngle() );
        this.linkList.add(l);
    }

    _groupList.remove(_targetLG);
}
</t>
<t tx="leo.20191210203501.15">LinkGroup.prototype.backToZero = function(){
    var space = null;
    for (var li=0; li&lt; this.linkList.array.length; li++) {
        var l = this.linkList.array[li];

      if(l instanceof Space){
        space = l;
      }
    }

    // ************************************************************
    if(space!=null){
      var zeroP = new Point2D(  JSON.parse(JSON.stringify(space.getOriginPoint().getX()) ),
                                JSON.parse(JSON.stringify(space.getOriginPoint().getY()) ) );
      var zeroA = space.getAngle();

      for (var li=0; li&lt; this.linkList.array.length; li++) {
        var l = this.linkList.array[li];
         var ox=l.getOriginPoint().getX() - zeroP.getX();
         var oy=l.getOriginPoint().getY() - zeroP.getY();

         var rx=ox*Math.cos(-zeroA)-oy*Math.sin(-zeroA);
         var ry=ox*Math.sin(-zeroA)+oy*Math.cos(-zeroA);

         l.setOriginPoint(rx, ry);
         l.setAngle( l.getAngle() - zeroA );
      }
    }
}

</t>
<t tx="leo.20191210203501.16">LinkGroup.prototype.zeroToPoint = function(_newOrigon){
    for(var li=0; li&lt; this.getLinkList().array.length; li++){
        var l = this.getLinkList().array[li];
        var x=l.getOriginPoint().getX()-_newOrigon.getX();
        var y=l.getOriginPoint().getY()-_newOrigon.getY();
        l.setOriginPoint(x, y);
    }
}
</t>
<t tx="leo.20191210203501.17">LinkGroup.prototype.isBaseGroup = function(){
    for(var li = 0; li&lt; this.linkList.array.length; li++){
        if(this.linkList.array[li] instanceof Space){
          return true;
        }
    }
    return false;
}


</t>
<t tx="leo.20191210203501.18">function CCI(_constraint, _base, _target){
    this.constraint = _constraint;
    this.target = _target;
    this.base = _base;
}
</t>
<t tx="leo.20191210203501.19">CCI.prototype.inverseCCI = function(){
    return new CCI(this.constraint, this.target, this.base);
}

</t>
<t tx="leo.20191210203501.2">LinkGroup.prototype.setRelativePosition = function(_point){
    this.relativePosition = _point;
}
</t>
<t tx="leo.20191210203501.20">function ACI(_constraint, _target){
    this.constraint = _constraint;
    this.target = _target;
    this.base = 1-this.target;

    //console.log("[New ACI] " + this.constraint);
}

</t>
<t tx="leo.20191210203501.21">function LinkTriangle(_base, _floating, _output, _b2f, _b2o, _f2o){
    this.base = _base;
    this.floating=_floating;
    this.output=_output;
    this.b2f=_b2f;
    this.b2o=_b2o;
    this.f2o=_f2o;
}

</t>
<t tx="leo.20191210203501.22">function LinkTriangle2(_a, _b, _c, _a2b, _b2c, _a2c) {
    this.a=_a;
    this.b=_b;
    this.c=_c;
    this.a2b=_a2b;
    this.b2c=_b2c;
    this.a2c=_a2c;
}
</t>
<t tx="leo.20191210203501.3">LinkGroup.prototype.getRelativePosition = function(){
    return this.relativePosition;
}
</t>
<t tx="leo.20191210203501.4">LinkGroup.prototype.setRelativeAngle = function(_angle){
    this.relativeAngle = _angle;
}
</t>
<t tx="leo.20191210203501.5">LinkGroup.prototype.getRelativeAngle = function(){
    return this.relativeAngle;
}
</t>
<t tx="leo.20191210203501.6">LinkGroup.prototype.getLinkList = function(){
    return this.linkList;
}
</t>
<t tx="leo.20191210203501.7">LinkGroup.prototype.addLink = function(_link){
    if(_element instanceof Link){
        var  returnValue = this.linkList.add(_link);
        return returnValue;
    }
    else if(_element instanceof ArrayList){
        var  returnValue = this.linkList.addAll(_link);
        return returnValue;
    }
}
</t>
<t tx="leo.20191210203501.8">LinkGroup.prototype.removeLink = function(_link){
    var  returnValue = this.linkList.remove(_link);
    return returnValue;

}
</t>
<t tx="leo.20191210203501.9">LinkGroup.prototype.findOutgoingCoaxialConstraint = function(_constraintList, _listGroup){
    var returnValue = new ArrayList();

    for(var ci = 0; ci&lt;_constraintList.array.length; ci++){
        // find_in_a_cc:
        var c = _constraintList.array[ci];
        if(c instanceof CoaxialConstraint){
            var cc = c;
            var addedLG = new ArrayList();

            for(var i=0; i&lt;cc.getAllPoint().length(); i++){
                if(this.linkList.contains(cc.getLink(i))){
                    for(var j=0; j&lt;cc.getAllPoint().length(); j++){
                        if(i!=j &amp;&amp; !this.linkList.contains(cc.getLink(j)) &amp;&amp; !addedLG.contains(cc.getLink(j))){
                            returnValue.add(new CCI(cc, i, j));

                            for(var lgi = 0; lgi &lt; _listGroup.array.length; lgi++){
                                lg = _listGroup.array[lgi];
                                if(lg.getLinkList().contains(cc.getLink(j))){
                                    addedLG.add(lg);
                                }
                            }
                        }
                    }
                    break;
                }
            }
        }
    }
    return returnValue;
}

</t>
<t tx="leo.20191210203515.1">//-------------------
// MechanismCalculator Class
//-------------------
// from m.sketch 2.4 java
// updated on 2015.11.02

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203522.1">function MechanismCalculator(){
    this.mapsOfMu;
    this.sliderMu;
}


</t>
<t tx="leo.20191210203522.10">MechanismCalculator.prototype.findXXXLinkTriangle = function(_assembly, _groupList, _baseGroup, _outgoingCoaxialConstraint){
    // find all linkGroups that are connected to the baseGroup only once
    var connectedLGList = new ArrayList();
    var duplicateLGList = new ArrayList();

    for(var ccii in _outgoingCoaxialConstraint.array){
        var cci = _outgoingCoaxialConstraint.get(ccii);
        if(cci instanceof CCI){
            var lg = this.findGroupByLink(_groupList, cci.constraint.getLink(cci.target));
            //console.log(lg);

            if(!duplicateLGList.contains(lg)){
                if(!connectedLGList.contains(lg)){
                    connectedLGList.add(lg);
                }else{
                    duplicateLGList.add(lg);
                    connectedLGList.remove(lg);
                }
            }
        }
    }
    if(connectedLGList.length()&lt;=1) return null;
    //console.log(connectedLGList.array);

    // find a pair of inter-connected link groups //
    for(var targetIndex1=0; targetIndex1&lt;connectedLGList.length()-1; targetIndex1++){
        var floating = connectedLGList.get(targetIndex1);


        //if(floating.isBaseGroup()) break;
        var floatingToOutCoaxialConstraint = floating.findOutgoingCoaxialConstraint(_assembly.getAllConstraint(), _groupList);

        for(var targetIndex2=targetIndex1+1; targetIndex2&lt;connectedLGList.length(); targetIndex2++){
            var output = connectedLGList.get(targetIndex2);


            //if(output.isBaseGroup()) break;
            var f2o=null;
            var b2f=null;
            var b2o=null;
            var count = 0;

            for(var tci in floatingToOutCoaxialConstraint.array){
                var tc = floatingToOutCoaxialConstraint.get(tci);
                if(output.getLinkList().contains(tc.constraint.getLink(tc.target))){ // if mton is targetting n //
                    // if f2o is targetting output //
                    f2o = tc;
                    count++;
                }
            }

            if(count==1){

                for(var tci in _outgoingCoaxialConstraint.array){
                    var tc = _outgoingCoaxialConstraint.get(tci);
                    if(floating.getLinkList().contains(tc.constraint.getLink(tc.target))){
                        b2f = tc;
                    }
                else if(output.getLinkList().contains(tc.constraint.getLink(tc.target))){
                        b2o = tc;
                    }
                }

                if(b2f.constraint!=b2o.constraint &amp;&amp; b2f.constraint!=f2o.constraint &amp;&amp; b2o.constraint!=f2o.constraint) {

                    if(floating.isBaseGroup()){
                      var temp = _baseGroup;
                      _baseGroup = floating;
                      floating = temp;
                      b2f = b2f.inverseCCI();
                      var temp2 = b2o;
                      b2o = f2o;
                      f2o = temp2;
                    }else if(output.isBaseGroup()){
                      var temp = _baseGroup;
                      _baseGroup = output;
                      output = temp;
                      b2o = b2o.inverseCCI();

                      //var temp2 = b2f;
                      //b2f = b2o;
                      //b2o = temp2;

                      /**
                      Error Fixed by Ju-Whan
                      */

                        var temp2 = f2o;
                        f2o = b2f.inverseCCI();
                        b2f = temp2.inverseCCI();
                    }
                    return new LinkTriangle(_baseGroup, floating, output, b2f, b2o, f2o);
                }
            }

        } //for(int targetIndex2=targetIndex1+1; targetIndex2&lt;connectedLGList.size(); targetIndex2++)
    } //for(targetIndex1=0; targetIndex1&lt;connectedLGList.size(); targetIndex1++)

    return null;
}

</t>
<t tx="leo.20191210203522.11">MechanismCalculator.prototype.findXSXLinkTriangle = function(_assembly, _groupList, _baseGroup, _outgoingCoaxialConstraint){
    // find all linkGroups that are connected to the baseGroup only once
    var connectedLGList = new ArrayList();
    var duplicateLGList = new ArrayList();

    for(var ccii in _outgoingCoaxialConstraint.array){
        var cci = _outgoingCoaxialConstraint.get(ccii);
        if(cci instanceof CCI){
            var lg = this.findGroupByLink(_groupList, cci.constraint.getLink(cci.target));

            if(!duplicateLGList.contains(lg)){
                if(!connectedLGList.contains(lg)){
                    connectedLGList.add(lg);
                }else{
                    duplicateLGList.add(lg);
                    connectedLGList.remove(lg);
                }
            }
        }
    }
    if(connectedLGList.length()&lt;=1) return null;

    // find a pair of inter-connected link groups //
    for(var targetIndex1=0; targetIndex1&lt;connectedLGList.length(); targetIndex1++){
        var floating = connectedLGList.get(targetIndex1);

        //if(floating.isBaseGroup()) break;
        var floatingToOutgoingSliderConstraint = floating.findOutgoingSliderConstraint(_assembly.getAllConstraint());

        if(floatingToOutgoingSliderConstraint.length() &gt; 0){
            for(var targetIndex2=0; targetIndex2&lt;connectedLGList.length(); targetIndex2++){

                if(targetIndex1!=targetIndex2){
                    var output = connectedLGList.get(targetIndex2);

                    b2c = null;
                    a2b = null;
                    a2c = null;

                    var count = 0;

                    for (var sci in floatingToOutgoingSliderConstraint.array) {
                        var sc = floatingToOutgoingSliderConstraint.get(sci);

                      if (output.getLinkList().contains(sc.getLink(sc.TARGET))) {
                        b2c = sc;
                        count++;
                      }
                    }



                    if(count == 1){
                        for (var tci in _outgoingCoaxialConstraint.array) {
                            var tc = _outgoingCoaxialConstraint.get(tci);

                          if (floating.getLinkList().contains(tc.constraint.getLink(tc.target))) {
                            a2b = tc;
                          } else if (output.getLinkList().contains(tc.constraint.getLink(tc.target))) {
                            a2c = tc;
                          }
                        }

                        if (a2c!=null &amp;&amp; a2b!=null &amp; a2b.constraint!=a2c.constraint) { // &amp;&amp; !floating.isBaseGroup() &amp;&amp; !output.isBaseGroup()) {
                          return new LinkTriangle2(_baseGroup, floating, output, a2b, b2c, a2c);
                        }
                    }
                } // if(targetIndex1!=targetIndex2){
            } //for(int targetIndex2=0; targetIndex2&lt;connectedLGList.size(); targetIndex2++)
        }
    } //for(targetIndex1=0; targetIndex1&lt;connectedLGList.size(); targetIndex1++)

    return null;
}

</t>
<t tx="leo.20191210203522.12">MechanismCalculator.prototype.findGroupByLink = function(_groupList, _link){
    for(var li in _groupList.array){
        var lg = _groupList.get(li);
        if(lg.linkList.contains(_link)){
            return lg;
        }
    }
   return null;
}

</t>
<t tx="leo.20191210203522.13">MechanismCalculator.prototype.getPtoP = function(_p1, _p2){
    return new Point2D(_p2.getX()-_p1.getX(), _p2.getY()-_p1.getY());
}
</t>
<t tx="leo.20191210203522.2">MechanismCalculator.prototype.onStart = function(_assembly){
    this.mapsOfMu = this.mapMu(_assembly);
    this.sliderMu = new Object();
}
</t>
<t tx="leo.20191210203522.3">MechanismCalculator.prototype.onEnd = function(_assembly){

}
</t>
<t tx="leo.20191210203522.4">MechanismCalculator.prototype.calculateAssembly = function(_assembly){
    var noError = true;
    var maxCost = 0;

    var groupList = this.buildLinkGroup(_assembly);
    _assembly.emptyUnspecified();

    var lastNOfGroup = groupList.length()+1;

    while(groupList.length()&gt;1 &amp;&amp; lastNOfGroup&gt;groupList.length()){
        lastNOfGroup = groupList.length();

        var baseGroupIndex = 0;
        while(baseGroupIndex&lt;groupList.length()){
            var baseLG = groupList.get(baseGroupIndex);
            var outgoingCoaxialConstraint = baseLG.findOutgoingCoaxialConstraint( _assembly.getAllConstraint() , groupList);
            var outgoingAngularConstraint = baseLG.findOutgoingAngularConstraint( _assembly.getAllConstraint() );

            /**
             find a pair of linkGroups that share both coaxialConstraint and a angularConstraint (e.g. LinkointActuator)
            */

            var targetIndex = baseGroupIndex+1;
            while(targetIndex&lt;groupList.length()){
                var targetLG = groupList.get(targetIndex);

                var ac_constraint = this.search_AC_Constraint(targetLG, outgoingAngularConstraint, outgoingCoaxialConstraint);
                if(ac_constraint[0].length()==1 &amp;&amp; ac_constraint[1].length()==1){
                    var ac = ac_constraint[0].get(0);
                    var cc = ac_constraint[1].get(0);

                    targetLG.zeroToPoint(targetLG.getLocalPosition(cc.constraint.getLink(cc.target), cc.constraint.getPoint(cc.target)));
                    targetLG.setRelativePosition(  baseLG.getLocalPosition(cc.constraint.getLink(cc.base),   cc.constraint.getPoint(cc.base)) );
                    var angleSign = (ac.target==Constraint.target) ?+1 : -1; // javascript does it work?

                    targetLG.setRelativeAngle( ac.constraint.getLink(ac.base).getAngle() - ac.constraint.getLink(ac.target).getAngle() + angleSign*ac.constraint.getAngle());

                    baseLG.merge(targetLG, groupList);

                    // need to re-collect information
                    outgoingCoaxialConstraint = baseLG.findOutgoingCoaxialConstraint( _assembly.getAllConstraint() , groupList );
                    outgoingAngularConstraint = baseLG.findOutgoingAngularConstraint( _assembly.getAllConstraint() );
                }else{
                    if(ac_constraint[0].length()+ac_constraint[1].length()&gt;=2){
                      // over-constraint
                    }
                    targetIndex++;
                }
            }

            /**
             find three linkGroup that are connected by three coaxial constraints
            */
            var needToFindMore = true;

            while(needToFindMore){
              needToFindMore = false;

              /// XXX constraint ///
              var triangle = this.findXXXLinkTriangle(_assembly, groupList, baseLG, outgoingCoaxialConstraint);
              if( triangle != null ){
                var 	b    = triangle.base;
                var 	f    = triangle.floating;
                var 	o    = triangle.output;
                var     b2f  = triangle.b2f;
                var     b2o  = triangle.b2o;
                var     f2o  = triangle.f2o;


                var R1   = this.getPtoP( b.getLocalPosition(b2f.constraint.getLink(b2f.base), 	b2f.constraint.getPoint(b2f.base)  ), b.getLocalPosition(b2o.constraint.getLink(b2o.base  ), b2o.constraint.getPoint(b2o.base  )) );
                var R2   = this.getPtoP( f.getLocalPosition(b2f.constraint.getLink(b2f.target), b2f.constraint.getPoint(b2f.target)), f.getLocalPosition(f2o.constraint.getLink(f2o.base  ), f2o.constraint.getPoint(f2o.base  )) );
                var R3   = this.getPtoP( o.getLocalPosition(b2o.constraint.getLink(b2o.target), b2o.constraint.getPoint(b2o.target)), o.getLocalPosition(f2o.constraint.getLink(f2o.target), f2o.constraint.getPoint(f2o.target)) );

                var dr1 = R1.distance(0,0);
                var dr2 = R2.distance(0,0);
                var dr3 = R3.distance(0,0);

                // +++++
                var angle1 = 0;
                var angle2 = 0;

                if( dr1==0 || dr1&gt;dr2+dr3 || dr2&gt;dr1+dr3 || dr3&gt;dr1+dr2){
                  noError = false;
                  maxCost = Number.POSITIVE_INFINITY;

                  if ( dr1&gt;dr2+dr3 ) {
                    angle1=0;
                    angle2=0;
                  } else if ( dr2&gt;dr1+dr3 ) {
                    angle1=0;
                    angle2=Math.PI;
                  } else if ( dr3&gt;dr1+dr2 ) {
                    angle1=Math.PI;
                    angle2=0;
                  }
                  // break;
                } else {
                  angle1  = Math.acos((dr1*dr1+dr2*dr2-dr3*dr3)/(2*dr1*dr2));
                  angle2  = Math.acos((dr1*dr1+dr3*dr3-dr2*dr2)/(2*dr1*dr3));

                  var cost = this.getTriangleCost(dr1, dr2, dr3);
                  if(maxCost &lt; cost) maxCost = cost;
                }

                  var mu = ((this.mapsOfMu[(b2f.constraint)])[(b2o.constraint)])[(f2o.constraint)];
                  angle1  = Math.atan2(R1.getY(), R1.getX()) - Math.atan2(R2.getY(), R2.getX()) - mu*angle1;
                  angle2  = Math.atan2(-R1.getY(), -R1.getX()) - Math.atan2(R3.getY(), R3.getX()) + mu*angle2;

                  f.zeroToPoint( f.getLocalPosition(b2f.constraint.getLink(b2f.target), b2f.constraint.getPoint(b2f.target)) );
                  f.setRelativePosition( b.getLocalPosition(b2f.constraint.getLink(b2f.base), b2f.constraint.getPoint(b2f.base)) );
                  f.setRelativeAngle( angle1 );
                  o.zeroToPoint( o.getLocalPosition(b2o.constraint.getLink(b2o.target), b2o.constraint.getPoint(b2o.target)) );
                  o.setRelativePosition( b.getLocalPosition(b2o.constraint.getLink(b2o.base), b2o.constraint.getPoint(b2o.base)) );

                  o.setRelativeAngle( angle2 );

                  b.merge(f, groupList);
                  b.merge(o, groupList);

                  outgoingCoaxialConstraint = baseLG.findOutgoingCoaxialConstraint( _assembly.getAllConstraint(), groupList );
                  outgoingAngularConstraint = baseLG.findOutgoingAngularConstraint( _assembly.getAllConstraint() );

                  needToFindMore = true;
                }


                /// XSX constraint ///
                var triangle2 = this.findXSXLinkTriangle(_assembly, groupList, baseLG, outgoingCoaxialConstraint);

                if ( triangle2 != null ) {
                  var       a   = triangle2.a;
                  var       b   = triangle2.b;
                  var       c   = triangle2.c;
                  var       a2b = triangle2.a2b;
                  var  		b2c = triangle2.b2c;
                  var       a2c = triangle2.a2c;

                  // Point2D pointA = a2b.getLink(Constraint.BASE).getGlobalPosition(a2b.constraint.getPoint(a2b.

                  var VP   = this.getPtoP( a.getLocalPosition(a2b.constraint.getLink(a2b.base), a2b.constraint.getPoint(a2b.base)), a.getLocalPosition(a2c.constraint.getLink(a2c.base), a2c.constraint.getPoint(a2c.base) ) );
                  var L2   = VP.getX()*VP.getX() + VP.getY()*VP.getY();

                  var VA   = this.getPtoP( b.getLocalPosition(a2b.constraint.getLink(a2b.target), a2b.constraint.getPoint(a2b.target)), b.getLocalPosition(b2c.getLink(b2c.BASE), b2c.getPoint1() ) );
                  var VB   = this.getPtoP( b.getLocalPosition(b2c.getLink(b2c.BASE), b2c.getPoint1() ), b.getLocalPosition(b2c.getLink(b2c.BASE), b2c.getPoint2() ) );
                  var DA   = this.getPtoP( c.getLocalPosition(b2c.getLink(b2c.TARGET), new Point2D(0, 0) ), c.getLocalPosition(a2c.constraint.getLink(a2c.target), a2c.constraint.getPoint(a2c.target)) );

                  VA = new Point2D(VA.getX()+DA.getX(), VA.getY()+DA.getY());

                  var det = Math.pow(VA.getX()*VB.getX()+VA.getY()*VB.getY() ,2) - (VB.getX()*VB.getX() + VB.getY()*VB.getY()) * (VA.getX()*VA.getX() + VA.getY()*VA.getY() - L2);

                  if( det&gt;=0 ) {
                    var mu;
                    if(this.sliderMu[b2c]==null){

                      var positive_t = ( -(VA.getX()*VB.getX()+VA.getY()*VB.getY()) + Math.sqrt(det) ) / (VB.getX()*VB.getX() + VB.getY()*VB.getY());
                      var negative_t = ( -(VA.getX()*VB.getX()+VA.getY()*VB.getY()) - Math.sqrt(det) ) / (VB.getX()*VB.getX() + VB.getY()*VB.getY());
                      var positive_des = new Point2D( VA.getX() + VB.getX()*positive_t, VA.getY() + VB.getY()*positive_t );
                      var negative_des = new Point2D( VA.getX() + VB.getX()*negative_t, VA.getY() + VB.getY()*negative_t );

                      var vP = this.getPtoP( a2b.constraint.getLink(a2b.base).getGlobalPosition(a2b.constraint.getPoint(a2b.base)), a2c.constraint.getLink(a2c.base).getGlobalPosition(a2c.constraint.getPoint(a2c.base)) );

                      var positiveDist = MMath.dist(vP, positive_des);
                      var negativeDist = MMath.dist(vP, negative_des);

                      if(positiveDist &lt; negativeDist) {
                        mu = +1.;
                      } else {
                        mu = -1.;
                      }
                      this.sliderMu[b2c] = mu;

                    } else {
                      mu = this.sliderMu[b2c];
                    }
                    var  t = ( -(VA.getX()*VB.getX()+VA.getY()*VB.getY()) + mu * Math.sqrt(det) ) / (VB.getX()*VB.getX() + VB.getY()*VB.getY());

                    if(t &lt; 0 || t &gt; 1){
                      //console.log("BROKEN: slider out of range")
                      _assembly.addUnspecified(a2c.constraint.getLink(a2c.base));
                      _assembly.addUnspecified(a2c.constraint.getLink(a2c.target));

                      if(t&lt;0) t=0;
                      if(t&gt;1) t=1;
                    }

                    var des = new Point2D( VA.getX() + VB.getX()*t, VA.getY() + VB.getY()*t );
                    var angle = Math.atan2(VP.getY(), VP.getX()) - Math.atan2(des.getY(), des.getX());

                    b.zeroToPoint( b.getLocalPosition(a2b.constraint.getLink(a2b.target), a2b.constraint.getPoint(a2b.target)) );
                    b.setRelativePosition( a.getLocalPosition(a2b.constraint.getLink(a2b.base), a2b.constraint.getPoint(a2b.base)) );
                    b.setRelativeAngle(angle);

                    des = new Point2D(des.getX()-DA.getX(), des.getY()-DA.getY());
                    c.zeroToPoint( c.getLocalPosition(b2c.getLink(b2c.TARGET), new Point2D(0, 0)  )  );
                    c.setRelativePosition( des );

                    c.setRelativeAngle(b2c.getLink(b2c.BASE).getAngle()-b2c.getLink(b2c.TARGET).getAngle()+b2c.getAngle());

                    b.merge(c, groupList);
                    a.merge(b, groupList);

                  } else {
                    // broken
                  }
                }
              }
            baseGroupIndex++;
        }
    }
    // position specification -- fininshed //

    for(var i=1; i&lt;groupList.length(); i++){
        _assembly.addUnspecified(groupList.get(i).getLinkList());
    }

    // additional specification //
    var needToMove = true;
    while(needToMove){
      needToMove = false;
      var space=groupList.get(0);

      for(var i=1; i&lt;groupList.length(); i++){
        var baseLG = groupList.get(i);
        var outgoingCoaxialConstraint = baseLG.findOutgoingCoaxialConstraint( _assembly.getAllConstraint(), groupList );
        for(var ccii in outgoingCoaxialConstraint.array){
            var cci = outgoingCoaxialConstraint.get(ccii);
          if( space.getLinkList().contains(cci.constraint.getLink(cci.target)) ){
            baseLG.zeroToPoint( baseLG.getLocalPosition(cci.constraint.getLink(cci.base), cci.constraint.getPoint(cci.base)));
            baseLG.setRelativePosition( space.getLocalPosition(cci.constraint.getLink(cci.target), cci.constraint.getPoint(cci.target)));
            space.merge(baseLG, groupList);
            needToMove = true;
            break;
          }
        }
      }
    }

    // Rearranging all mechanism //
    groupList.get(0).backToZero();

    return maxCost;

}

</t>
<t tx="leo.20191210203522.5">MechanismCalculator.prototype.getTriangleCost = function(dr1, dr2, dr3){
    var ds = [dr1, dr2, dr3];
    ds.sort();
    if( ds[2] &gt;= ds[0]+ds[1] ){
      return Number.POSITIVE_INFINITY;
    } else {
      return 3*(ds[0]+ds[1])/(ds[0]+ds[1]-ds[2]);
    }
}

</t>
<t tx="leo.20191210203522.6">MechanismCalculator.prototype.buildLinkGroup = function(_assembly){
    var returnValue = new ArrayList();

    for(var ei in _assembly.getAllElement().array){
        var e = _assembly.getAllElement().get(ei);
      if(e instanceof Link){
        var lg = new LinkGroup(e);
        //console.log(e);
        if(e instanceof Space){
          returnValue.addIn(0, lg);
        } else {
          returnValue.add(lg);
        }
      }
    }

    return returnValue;
}

</t>
<t tx="leo.20191210203522.7">MechanismCalculator.prototype.mapMu = function(_assembly){
    var returnValue = new Object();

    for(var c1i in _assembly.getAllConstraint().array){
        var c1 = _assembly.getAllConstraint().get(c1i);
        var secondLayer = new Object();

        if(c1 instanceof CoaxialConstraint){
            var p1 = c1.getLink(c1.BASE).getGlobalPosition(c1.getPoint(c1.BASE));

            for(var c2i in _assembly.getAllConstraint().array){
                var c2 = _assembly.getAllConstraint().get(c2i);

                if(c2 instanceof CoaxialConstraint &amp;&amp; c1!=c2){
                    var thirdLayer = new Object();

                    var p2 = c2.getLink(c1.BASE).getGlobalPosition(c2.getPoint(c1.BASE));

                    p2.setLocation(p2.getX()-p1.getX(), p2.getY()-p1.getY());

                    for(var c3i in _assembly.getAllConstraint().array){
                        var c3 = _assembly.getAllConstraint().get(c3i);

                        if(c3 instanceof CoaxialConstraint &amp;&amp; c1!=c3 &amp;&amp; c2!=c3){
                            var p3 = c3.getLink(c1.BASE).getGlobalPosition(c3.getPoint(c1.BASE));

                            p3.setLocation(p3.getX()-p1.getX(), p3.getY()-p1.getY());
                            var v = p2.getY()*p3.getX() - p2.getX()*p3.getY();

                            if(v&gt;0) v=1;
                            if(v&lt;0) v=-1;
                            thirdLayer[c3] = v;

                        }
                    }
                    secondLayer[c2] = thirdLayer;
                }
            }
            returnValue[c1] = secondLayer;
          }
    }
    return returnValue;
}
</t>
<t tx="leo.20191210203522.8">MechanismCalculator.prototype.getSliderMu = function(_assembly){
    /*
  LinkedHashMap&lt;SliderConstraint, LinkedHashMap&lt;CoaxialConstraint, LinkedHashMap&lt;CoaxialConstraint, Double&gt;&gt;&gt; returnValue = new LinkedHashMap&lt;SliderConstraint, LinkedHashMap&lt;CoaxialConstraint, LinkedHashMap&lt;CoaxialConstraint, Double&gt;&gt;&gt;();

  for (Constraint c : _assembly.getAllConstraint()) {
    if(c instanceof SliderConstraint){
      LinkedHashMap&lt;CoaxialConstraint, LinkedHashMap&lt;CoaxialConstraint, Double&gt;&gt; secondLayer = new LinkedHashMap&lt;CoaxialConstraint, LinkedHashMap&lt;CoaxialConstraint, Double&gt;&gt;();

      SliderConstraint sc = (SliderConstraint) c;
      Link baseLink = sc.getLink(Constraint.BASE);
      Link targetLink = sc.getLink(Constraint.TARGET);

      for(Constraint c1 : _assembly.getAllConstraint()) {
        if(c1 instanceof CoaxialConstraint ){
          CoaxialConstraint cc1 = (CoaxialConstraint) c1;
          LinkedHashMap&lt;CoaxialConstraint, Double&gt; thirdLayer = new LinkedHashMap&lt;CoaxialConstraint, Double&gt;();

          for(Constraint c2 : _assembly.getAllConstraint()) {
            if(c2 instanceof CoaxialConstraint ){
              CoaxialConstraint cc2 = (CoaxialConstraint) c2;

              Point2D p1  = baseLink.getGlobalPosition(sc.getPoint1());
              Point2D p2  = baseLink.getGlobalPosition(sc.getPoint2());
              Point2D pc1 = cc1.getLink(0).getGlobalPosition(cc1.getPoint(0));
              Point2D pc2 = cc2.getLink(0).getGlobalPosition(cc2.getPoint(0));

              double t1 = MMath.getNearestTfromALine(pc1, p1, p2);
              double t2 = MMath.getNearestTfromALine(pc2, p1, p2);

              double mu = (t1&lt;=t2) ?+1 :-1;

              thirdLayer.put(cc2, mu);
            }
          }

          secondLayer.put(cc1, thirdLayer);
        }
      }
      returnValue.put(sc, secondLayer);
    }
  }

  return returnValue;
  */
}

</t>
<t tx="leo.20191210203522.9">MechanismCalculator.prototype.search_AC_Constraint = function(_targetLG, _angularConstraint, _coaxialConstraint){
    var returnValue = new Array(2);

    returnValue[0] = new ArrayList();
    for(var acii in _angularConstraint.array){
        var aci = _angularConstraint.get(acii);
        if(aci instanceof ACI){
            if(_targetLG.getLinkList().contains(aci.constraint.getLink(aci.target))){
                returnValue[0].add(aci);
            }
        }
    }

    returnValue[1] = new ArrayList();
    for(var ccii in _coaxialConstraint.array){
        var cci = _coaxialConstraint.get(ccii);
        if(cci instanceof CCI){
            if(_targetLG.getLinkList().contains(cci.constraint.getLink(cci.target))){
                returnValue[1].add(cci);
            }
        }
    }

    return returnValue;
}

</t>
<t tx="leo.20191210203553.1"></t>
<t tx="leo.20191210203617.1">/**
 * @author juwhan kim
 * @author hanjong kim
 * last modified: 2016.06.30
 */

// ==========================================================================================
//						MechElement Class
// ==========================================================================================

// === Constructor ===
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203632.1">function MechElement(arg1, arg2, arg3){
    this.name;
    this.originPoint = new Point2D();
    this.backup_originPoint;
    this.DOF;

    var arg_num = arguments.length;
    switch(arg_num){
        case 1:
            if(typeof(arg1)=="string"){									// Element(String _name)
                this.name = arg1;
            }
            else{														// Element(Point2D _pt)
                this.originPoint = arg1;
            }
            break;
        case 2:
            if((typeof(arg1)=="number")&amp;&amp;(typeof(arg2)=="number")){ 	// Element(double _x, double _y)
                this.originPoint = new Point2D(arg1, arg2);
            }
            else{														// Element(String _name, Point2D _pt)
                this.name = arg1;
                this.originPoint = arg2;
            }
            break;
        case 3:  														//  Element(String _name, double _x, double _y)
                this.name = arg1;
                this.originPoint = new Point2D(arg2, arg3);
            break;
    }
}


//-------------------- IO Functions --------------------
</t>
<t tx="leo.20191210203632.2">MechElement.prototype.getOriginPoint = function(){
    return this.originPoint;
}
</t>
<t tx="leo.20191210203632.3">MechElement.prototype.setOriginPoint = function(arg1, arg2){
    var arg_num = arguments.length;
    switch(arg_num){
        case 1:
            this.originPoint = arg1;
            break;
        case 2:
            this.originPoint = new Point2D(arg1, arg2);
            break;

    }
}
</t>
<t tx="leo.20191210203632.4">MechElement.prototype.getName = function(){
    return this.name;
}
</t>
<t tx="leo.20191210203632.5">MechElement.prototype.setName = function(_name){
    this.name = _name;
}
</t>
<t tx="leo.20191210203632.6">MechElement.prototype.getDOF = function(){
    return this.DOF;
}
</t>
<t tx="leo.20191210203632.7">MechElement.prototype.savePosition = function(){
    this.backup_originPoint = new Point2D(this.originPoint.getX(), this.originPoint.getY());
}
</t>
<t tx="leo.20191210203632.8">MechElement.prototype.restorePosition = function(){
    this.originPoint = this.backup_originPoint;
}
</t>
<t tx="leo.20191210203646.1">//--------------------
// Link Class
//--------------------
// from m.sketch 2.4 java
// updated on 2015.11.02

//-------------------- Constructor --------------------
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203652.1">function Link(arg1, arg2, arg3){
    MechElement.apply(this, arguments);

    this.pointList = new ArrayList();
    this.vertex = [];
    this.angle = 0;
    this.DOF = 3;
    this.lengths = [];

  this.backup_angle = 0;
  this.backup_pointNum = 0;
  this.backup_vertexNum = 0;

  this.angleOnFirstTwoPoints = 0;
  //this.counter = 1;

  if(arguments.length&gt;0) {
    if(!(typeof(arg1)=="string")){
      this.name = "Link" + Link.counter++;
    }
    this.init();
  }
    // for 3D
    this.stack = 0;

    // for Slider
    this.isSlider = false;
    this.baseSC = null;
}
Link.counter = 1;
Link.sliderCount = 1;
Link.prototype = new MechElement;
Link.prototype.constructor = Link;

//-------------------- IO Functions --------------------
</t>
<t tx="leo.20191210203652.10">Link.prototype.getGlobalPosition = function(_p){
    var returnValue = new Point2D(this.originPoint.getX()+_p.getX()*Math.cos(this.angle)-_p.getY()*Math.sin(this.angle),
                                this.originPoint.getY()+_p.getX()*Math.sin(this.angle)+_p.getY()*Math.cos(this.angle));
    return returnValue;
}
</t>
<t tx="leo.20191210203652.11">Link.prototype.getLocalPosition = function(_p){
    var tx = _p.getX()-this.originPoint.getX();
    var ty = _p.getY()-this.originPoint.getY();

    var returnValue = new Point2D(tx*Math.cos(-this.angle)-ty*Math.sin(-this.angle), tx*Math.sin(-this.angle)+ty*Math.cos(-this.angle));

    return returnValue;
}
</t>
<t tx="leo.20191210203652.12">Link.prototype.getGlobalVertex = function(){
    if(this.vertex==null){
        return null;
    }

    var returnValue = new Array(this.vertex.length);
    for(var i=1; i&lt;this.vertex.length; i+=2){
      returnValue[i-1] = (this.originPoint.getX()+this.vertex[i-1]*Math.cos(this.angle)-this.vertex[i]*Math.sin(this.angle));
      returnValue[ i ] = (this.originPoint.getY()+this.vertex[i-1]*Math.sin(this.angle)+this.vertex[i]*Math.cos(this.angle));
    }
    return returnValue;
}
</t>
<t tx="leo.20191210203652.13">Link.prototype.savePosition = function(){
  //this.savePosition();                       // does it work?
  this.backup_originPoint = new Point2D(this.originPoint.getX(), this.originPoint.getY());
  this.backup_angle = this.angle;
}
</t>
<t tx="leo.20191210203652.14">Link.prototype.restorePosition = function(){
  //this.restorePosition();
  this.originPoint = this.backup_originPoint;
  this.angle = this.backup_angle;
}



</t>
<t tx="leo.20191210203652.15">Link.prototype.init = function(){
    var firstPoint = new Point2D(0, 0);
    this.pointList.add(firstPoint);
}

</t>
<t tx="leo.20191210203652.16">Link.prototype.redefineVertex = function(){
    if(this.pointList.length() &lt; 2) return;

    var vertexOrder = new ArrayList();

    // finding the first point //
    var firstPoint = this.pointList.get(0);
    for(var i=1; i&lt;this.pointList.length(); i++){
      if(firstPoint.getY() &lt; this.pointList.get(i).getY()){
        firstPoint = this.pointList.get(i);
      } else if(firstPoint.getY()==this.pointList.get(i).getY() &amp;&amp; firstPoint.getX()&gt;this.pointList.get(i).getX()){
        firstPoint = this.pointList.get(i);
      }
    }
    vertexOrder.add(firstPoint);

    // stacking vertex
    var lastAngle = Math.PI/2;
    while(true){
      var thisPoint = vertexOrder.get(vertexOrder.length()-1);

      var nextPoint = null;
      var angle = 10;
      for(var i=0; i&lt;this.pointList.length(); i++){
        if(this.pointList.get(i)!=thisPoint &amp;&amp; (this.pointList.get(i).getY()!=thisPoint.getY() || this.pointList.get(i).getX()!=thisPoint.getX())){
        //if(this.pointList.get(i)!=thisPoint{
          var thisAngle = Math.atan2(this.pointList.get(i).getY()-thisPoint.getY(), this.pointList.get(i).getX()-thisPoint.getX());

          for(var k=-1; k&lt;2; k++){
            var comAngle = thisAngle + k*2*Math.PI;
            if(comAngle&lt;angle &amp;&amp; comAngle&gt;=lastAngle){
              angle = comAngle;
              nextPoint = this.pointList.get(i);
            }
          }
        }
      }

      if(nextPoint!=null){
        vertexOrder.add(nextPoint);
        lastAngle = angle;
        if(nextPoint==vertexOrder.get(0)){
          break;
        }
      }else{
        vertexOrder.add(vertexOrder.get(0));
        break;
      }
    }

    // simplify
    this.vertex = new Array(vertexOrder.length()*4-4);
    this.lengths = [];

    if(!this.isSlider){
        for(var i=0; i&lt;vertexOrder.length()-1; i++){
            this.vertex[i*4+0] = vertexOrder.get(i).getX();
            this.vertex[i*4+1] = vertexOrder.get(i).getY();
            this.vertex[i*4+2] = vertexOrder.get(i+1).getX();
            this.vertex[i*4+3] = vertexOrder.get(i+1).getY();

            this.lengths.push(this.distance(this.vertex[i*4+0], this.vertex[i*4+1], this.vertex[i*4+2], this.vertex[i*4+3]));
        }
    }
    else{
        // for slider rect
        for(var i=0; i&lt;vertexOrder.length()-1; i++){
          var angle = Math.atan2(vertexOrder.get(i+1).getY()-vertexOrder.get(i).getY(), vertexOrder.get(i+1).getX()-vertexOrder.get(i).getX())-Math.PI/2;
          var dist = 20;
          this.vertex[i*4+0] = vertexOrder.get(i).getX() + dist*Math.cos(angle);
          this.vertex[i*4+1] = vertexOrder.get(i).getY() + dist*Math.sin(angle);
          this.vertex[i*4+2] = vertexOrder.get(i+1).getX() + dist*Math.cos(angle);
          this.vertex[i*4+3] = vertexOrder.get(i+1).getY() + dist*Math.sin(angle);
          this.lengths.push(this.distance(this.vertex[i*4+0], this.vertex[i*4+1], this.vertex[i*4+2], this.vertex[i*4+3]));
        }
    }

}

</t>
<t tx="leo.20191210203652.17">Link.prototype.getGlobalRoundedVertex = function(_rot){
  if(this.pointList.length() &lt; 2) return [];

  var vertexOrder = new ArrayList();

  // finding the first point //
    var firstPoint = this.pointList.get(0);
    for(var i=1; i&lt;this.pointList.length(); i++){
      if(firstPoint.getY() &lt; this.pointList.get(i).getY()){
        firstPoint = this.pointList.get(i);
      } else if(firstPoint.getY()==this.pointList.get(i).getY() &amp;&amp; firstPoint.getX()&gt;this.pointList.get(i).getX()){
        firstPoint = this.pointList.get(i);
      }
    }
    vertexOrder.add(firstPoint);

    // stacking vertex
    var lastAngle = Math.PI/2;
    while(true){
      var thisPoint = vertexOrder.get(vertexOrder.length()-1);

      var nextPoint = null;
      var angle = 10;
      for(var i=0; i&lt;this.pointList.length(); i++){
        if(this.pointList.get(i)!=thisPoint &amp;&amp; (this.pointList.get(i).getY()!=thisPoint.getY() || this.pointList.get(i).getX()!=thisPoint.getX())){
          var thisAngle = Math.atan2(this.pointList.get(i).getY()-thisPoint.getY(), this.pointList.get(i).getX()-thisPoint.getX());
          for(var k=-1; k&lt;2; k++){
            var comAngle = thisAngle + k*2*Math.PI;
            if(comAngle&lt;angle &amp;&amp; comAngle&gt;=lastAngle){
              angle = comAngle;
              nextPoint = this.pointList.get(i);
            }
          }
        }
      }

      if(nextPoint!=null){
        vertexOrder.add(nextPoint);
        lastAngle = angle;
        if(nextPoint==vertexOrder.get(0)){
          break;
        }
      }else{
        vertexOrder.add(vertexOrder.get(0));
        break;
      }
    }

    vertexOrder.add(vertexOrder.get(1));

    var vertexList = new ArrayList();

    for(var i=0; i&lt;vertexOrder.length()-2; i++){
      var angle  = Math.atan2(vertexOrder.get(i+1).getY()-vertexOrder.get(i  ).getY(), vertexOrder.get(i+1).getX()-vertexOrder.get(i  ).getX())-Math.PI/2;
      var angle2 = Math.atan2(vertexOrder.get(i+2).getY()-vertexOrder.get(i+1).getY(), vertexOrder.get(i+2).getX()-vertexOrder.get(i+1).getX())-Math.PI/2;
      if(angle2&lt;angle) angle2+=2*Math.PI;

      var dist = (msketchSettings.linkWidth/SCALE_TRANS)/2;

      var step = 10;

      vertexList.add(vertexOrder.get(i).getX() + dist*Math.cos(angle));
      vertexList.add(vertexOrder.get(i).getY() + dist*Math.sin(angle));
      vertexList.add(vertexOrder.get(i+1).getX() + dist*Math.cos(angle));
      vertexList.add(vertexOrder.get(i+1).getY() + dist*Math.sin(angle));

      // for fixed rounded angle
      for(var k=0; k&lt;step; k++){
          var _newAngle = angle + (angle2-angle)*(k/step)
          vertexList.add(vertexOrder.get(i+1).getX() + dist*Math.cos(_newAngle));
          vertexList.add(vertexOrder.get(i+1).getY() + dist*Math.sin(_newAngle));
      }
      /*
      for(;angle&lt;angle2;angle+=step){
        vertexList.add(vertexOrder.get(i+1).getX() + dist*Math.cos(angle));
        vertexList.add(vertexOrder.get(i+1).getY() + dist*Math.sin(angle));
      }
      */

    }

    /*
    this.vertex = new Array(vertexList.length());
    for(var i=0; i&lt;vertexList.length(); i++){
      this.vertex[i] = vertexList.get(i);
    }

    */

    if(vertexList==null){
      return [];
    }

    var returnVertex = new Array(vertexList.length());

    this.angleOnFirstTwoPoints = Math.atan2(this.pointList.get(1).getY()-this.pointList.get(0).getY(),this.pointList.get(1).getX()-this.pointList.get(0).getX()) + this.angle;
    for(var i=1; i&lt;vertexList.length(); i+=2){
      var tempX = (this.originPoint.getX()+vertexList.get(i-1)*Math.cos(this.angle)-vertexList.get(i)*Math.sin(this.angle));
      var tempY = (this.originPoint.getY()+vertexList.get(i-1)*Math.sin(this.angle)+vertexList.get(i)*Math.cos(this.angle));

      if(_rot==0){
        returnVertex[i-1] = tempX;
        returnVertex[ i ] = tempY;
      }else{
        returnVertex[i-1] = Math.cos(this.angleOnFirstTwoPoints)*tempX  + Math.sin(this.angleOnFirstTwoPoints)*tempY;
        returnVertex[ i ] =-Math.sin(this.angleOnFirstTwoPoints)*tempX  + Math.cos(this.angleOnFirstTwoPoints)*tempY;
      }

    }
    return returnVertex;
    //console.log(this.vertex);
}

</t>
<t tx="leo.20191210203652.18">Link.prototype.getGlobalPositionRotated = function(_p){
  var tempX = this.getGlobalPosition(_p).getX();
  var tempY = this.getGlobalPosition(_p).getY();

  var returnX = Math.cos(this.angleOnFirstTwoPoints)*tempX  + Math.sin(this.angleOnFirstTwoPoints)*tempY;
  var returnY =-Math.sin(this.angleOnFirstTwoPoints)*tempX  + Math.cos(this.angleOnFirstTwoPoints)*tempY;

  var returnValue = new Point2D(returnX,returnY);
  return returnValue;
}

</t>
<t tx="leo.20191210203652.19">Link.prototype.getLength = function(_index){
  return this.lengths[_index];
}
</t>
<t tx="leo.20191210203652.2">Link.prototype.toString = function(){
  return this.name;
}
</t>
<t tx="leo.20191210203652.20">Link.prototype.getLengths = function(_index){
  return this.lengths;
}
</t>
<t tx="leo.20191210203652.21">Link.prototype.distance = function(_x1, _y1, _x2, _y2){
    var d = Math.sqrt((_x2-_x1)*(_x2-_x1) + (_y2-_y1)*(_y2-_y1));
    return d;
}

</t>
<t tx="leo.20191210203652.22">Link.prototype.pushVertex = function(){
  this.backup_vertexNum = this.vertex.length;
}

</t>
<t tx="leo.20191210203652.23">Link.prototype.vertexIsChanged = function(){
  if(this.backup_vertexNum == this.vertex.length){
    return false;
  }
  else{
    return true;
  }
}

</t>
<t tx="leo.20191210203652.24">Link.prototype.pushPoint = function(){
  this.backup_pointNum = this.pointList.length();
}

</t>
<t tx="leo.20191210203652.25">Link.prototype.pointIsChanged = function(){
  if(this.backup_pointNum == this.pointList.length()){
    return false;
  }
  else{
    return true;
  }
}

</t>
<t tx="leo.20191210203652.26">Link.prototype.setSlider = function(_sc){
    this.isSlider = true;
    this.baseSC = _sc;
    this.name = this.name.replace("Link", "Slider");
}


/* removed in 2.4
//--------------------
// Space Class
//--------------------
function Space(){
    Link.apply(this, arguments);

    this.name = "Global Space";
    this.originPoint = new Point2D(0, 0);
    this.DOF = 0;

  //console.log("[Space] new space: " + this.name);
}
// --- Inheritance
Space.prototype = new Link();
Space.prototype.constructor = Space;
*/
</t>
<t tx="leo.20191210203652.3">Link.prototype.getAngle = function(){
    return this.angle;
}
</t>
<t tx="leo.20191210203652.4">Link.prototype.setAngle = function(_angle){
    this.angle = _angle;
}
</t>
<t tx="leo.20191210203652.5">Link.prototype.getPointList = function(){
    return this.pointList;
}
</t>
<t tx="leo.20191210203652.6">Link.prototype.addGlobalPoint = function(arg1, arg2){
    var arg_num = arguments.length;
    var returnValue;

    switch(arg_num){
        case 1: // Point2D
            var localPt = this.getLocalPosition(arg1);
            arg1.setLocation(localPt);
            returnValue = this.addLocalPoint(arg1);
            break;
        case 2: // x, y
            returnValue = this.addGlobalPoint(new Point2D(arg1, arg2));
            break;

    }
    return returnValue;
}

</t>
<t tx="leo.20191210203652.7">Link.prototype.addLocalPoint = function(_pt){
    var returnValue = this.pointList.add(_pt);
    this.redefineVertex();
    return returnValue;
}
</t>
<t tx="leo.20191210203652.8">Link.prototype.removePoint = function(_pt){
    var returnValue = this.pointList.remove(_pt);
    this.redefineVertex();
    return returnValue;
}
</t>
<t tx="leo.20191210203652.9">Link.prototype.getVertex = function(){
    return this.vertex;
}
</t>
<t tx="leo.20191210203712.1">//--------------------
// Space Class
//--------------------
// from m.sketch 2.4 java
// updated on 2015.11.02

//-------------------- Constructor --------------------
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203717.1">function Space(){
    Link.apply(this, arguments);

    this.name = "Anchor";
    this.originPoint = new Point2D(0, 0);
    this.DOF = 0;

  //console.log("[Space] new space: " + this.name);
}
// --- Inheritance
Space.prototype = new Link();
Space.prototype.constructor = Space;

</t>
<t tx="leo.20191210203717.2">Space.prototype.redefineVertex = function(){

}
</t>
<t tx="leo.20191210203736.1">//--------------------
// JointActuator Class
//--------------------
// from m.sketch 2.4 java
// updated on 2015.11.02

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203742.1">function JointActuator(arg1, arg2, arg3, arg4) {
    MechElement.apply(this, arguments);

    this.coaxialConstraint;
    this.angularConstraint;
    this.angle = 0;
    this.initAngle = 0;

    this.isServo = false;
    this.startAngle = 0;
    this.endAngle = Math.PI;

    this.speedMultiply = 1.00;
    this.phaseShift = 0;
    this.revDir = false;

    this.backup_angle;

    var arg_num = arguments.length;

    switch (arg_num) {
        case 3:
            if (arg1 != null &amp;&amp; arg2 != null &amp;&amp; arg3 != null) {
                this.coaxialConstraint = arg1;
                this.angularConstraint = new AngularConstraint(arg2, arg3);
                this.originPoint = arg1.getPoint(0);
            }
            this.name = "Motor" + JointActuator.counter++;
            break;
        case 4: // String _name, CoaxialConstraint _cc, Link _baseLink, Link _targetLink
            if (arg2 != null &amp;&amp; arg3 != null &amp;&amp; arg4 != null) {
                this.coaxialConstraint = arg2;
                this.angularConstraint = new AngularConstraint(arg3, arg4);
                this.originPoint = arg2.getPoint(0);
            }
            this.name = arg1;
            break;
    }
}
// --- Inheritance
JointActuator.counter = 1;
JointActuator.prototype = new MechElement();
JointActuator.prototype.constructor = JointActuator;

</t>
<t tx="leo.20191210203742.10">JointActuator.prototype.dettach = function(_assembly) {
    if (_assembly == null) return;
    _assembly.removeConstraint(this.angularConstraint);
}

</t>
<t tx="leo.20191210203742.11">JointActuator.prototype.savePosition = function() {
    this.backup_angle = this.getValue();
}
</t>
<t tx="leo.20191210203742.12">JointActuator.prototype.restorePosition = function() {
    this.setValue(this.backup_angle);
}


// interfacing with motor panel
</t>
<t tx="leo.20191210203742.13">JointActuator.prototype.setPhase = function(_phase) {
    this.phaseShift = _phase;
}
</t>
<t tx="leo.20191210203742.14">JointActuator.prototype.getPhase = function() {
    return this.phaseShift;
}
</t>
<t tx="leo.20191210203742.15">JointActuator.prototype.setSpeedMultiply = function(_speedM) {
    this.speedMultiply = _speedM;
}
</t>
<t tx="leo.20191210203742.16">JointActuator.prototype.getSpeedMultiply = function() {
    return this.speedMultiply;
}
</t>
<t tx="leo.20191210203742.17">JointActuator.prototype.setReverse = function(_flag) {
    this.revDir = _flag;
}
</t>
<t tx="leo.20191210203742.18">JointActuator.prototype.getReverse = function() {
    return this.revDir;
}
</t>
<t tx="leo.20191210203742.19">JointActuator.prototype.setStartAngle = function(_phase) {
    this.startAngle = _phase;
}
</t>
<t tx="leo.20191210203742.2">JointActuator.prototype.getName = function() {
    return this.name;
}
</t>
<t tx="leo.20191210203742.20">JointActuator.prototype.getStartAngle = function() {
    return this.startAngle;
}
</t>
<t tx="leo.20191210203742.21">JointActuator.prototype.setEndAngle = function(_phase) {
    this.endAngle = _phase;
}
</t>
<t tx="leo.20191210203742.22">JointActuator.prototype.getEndAngle = function() {
    return this.endAngle;
}
</t>
<t tx="leo.20191210203742.23">JointActuator.prototype.setInitAngle = function(_angle) {
    this.initAngle = _angle;
}


</t>
<t tx="leo.20191210203742.24">JointActuator.prototype.setServo = function() {
    this.isServo = true;
}
</t>
<t tx="leo.20191210203742.25">JointActuator.prototype.setDC = function() {
    this.isServo = false;
}
</t>
<t tx="leo.20191210203742.3">JointActuator.prototype.getValue = function() {
    return this.angle;
}
</t>
<t tx="leo.20191210203742.4">JointActuator.prototype.setValue = function(_value) {
    this.angle = _value;
    this.angularConstraint.setAngle(this.angle - this.initAngle);
}

</t>
<t tx="leo.20191210203742.5">JointActuator.prototype.setCoaxialConstraint = function(_cc) {
    this.coaxialConstraint = _cc;
}
</t>
<t tx="leo.20191210203742.6">JointActuator.prototype.getCoaxialConstraint = function() {
    return this.coaxialConstraint;
}
</t>
<t tx="leo.20191210203742.7">JointActuator.prototype.getBaseLink = function() {
    return this.angularConstraint.getLink(this.angularConstraint.BASE);
}
</t>
<t tx="leo.20191210203742.8">JointActuator.prototype.getTargetLink = function() {
    return this.angularConstraint.getLink(this.angularConstraint.TARGET);
}
</t>
<t tx="leo.20191210203742.9">JointActuator.prototype.attach = function(_assembly) {
    if (_assembly == null) return;
    _assembly.addConstraint(this.angularConstraint);

}
</t>
<t tx="leo.20191210203803.1">//--------------------
// Trajectory Class
//--------------------
// from m.sketch 2.4 java
// updated on 2015.11.02


@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203812.1">function Trajectory(_assembly, _point) {

    this.assembly;
    this.link;
    this.point;
    this.gpoint;
    this.trajectory = new ArrayList();
    this.trajectoryOneCycle= new Array(); //* For YONSEI Analysis

    if (_assembly != null &amp;&amp; _point != null) {
            this.assembly = _assembly
            this.link = _assembly.getBelongedLink(_point);
            this.point = _point;
            this.flush();
            this.gpoint = this.link.getGlobalPosition(this.point);
    }
}

</t>
<t tx="leo.20191210203812.2">Trajectory.prototype.getPoint = function() {
    return this.point;
}
</t>
<t tx="leo.20191210203812.3">Trajectory.prototype.setPoint = function(_point) {
    this.point = _point;
}
</t>
<t tx="leo.20191210203812.4">Trajectory.prototype.getTrajectory = function() {
    return this.trajectory;
}
</t>
<t tx="leo.20191210203812.5">Trajectory.prototype.getTrajectoryOneCycle = function() {
    return this.trajectoryOneCycle;
}

</t>
<t tx="leo.20191210203812.6">Trajectory.prototype.flush = function() {
    this.trajectory = new ArrayList();
    this.trajectoryOneCycle = new Array();
}

</t>
<t tx="leo.20191210203812.7">Trajectory.prototype.record = function() {
    this.gpoint = this.link.getGlobalPosition(this.point);
    this.trajectory.add(this.gpoint);

    /*
    if(this.trajectory.length()==2){
        this.trajectory.set(0, this.trajectory.get(1));
    }
    */

    if(this.trajectory.length()&gt;MAX_TRAJECTORY_SIZE/3-1){
        this.trajectory.removeOf(0);
    }

    //* For YONSEI Analysis
    if(isAnalysisOn &amp;&amp; Math.abs(globalAngle)&lt;Math.PI*2){
        this.trajectoryOneCycle.push(Math.abs(globalAngle)+"/"+this.gpoint.getX()+"/"+this.gpoint.getY());
        //console.log(trajectoryOneCycle[trajectoryOneCycle.length-1]);
        if(this.trajectoryOneCycle.length==2){
            this.trajectoryOneCycle[0] = this.trajectoryOneCycle[1];
        }
    }

    //console.log(this.trajectory.get(0));
    /*
    if(this.link.getGlobalPosition(this.point)==null) return;
    this.pointList.add(this.link.getGlobalPosition(this.point));
    this.gpoint = this.link.getGlobalPosition(this.point);
    */
}

</t>
<t tx="leo.20191210203812.8">Trajectory.prototype.init = function(){
    //this.flush();
    if(this.gpoint!=null)	this.gpoint = this.link.getGlobalPosition(this.point);
}
</t>
<t tx="leo.20191210203827.1">@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203835.1">function Gear(){
    this.point = new Point2D(0, 0);
    this.radius = 100;
    this.pitch = 15;
    this.teethUnit = 20;

    this.vertices = [];

    this.defineVertices();
}

</t>
<t tx="leo.20191210203835.2">Gear.prototype.getPoint = function(){
    return this.point;
}
</t>
<t tx="leo.20191210203835.3">Gear.prototype.setPoint = function(_p){
    this.point = _p;
}
</t>
<t tx="leo.20191210203835.4">Gear.prototype.setRadius = function(_r){
    this.radius = _r;
    this.defineVertices();
}
</t>
<t tx="leo.20191210203835.5">Gear.prototype.defineVertices = function(){
    var circum = 2 * Math.PI * this.radius;
    var numOfTeeth = Math.ceil(circum/this.teethUnit);

    var returnVertex = [];

    var step = Math.PI*2 / numOfTeeth;

    for(var i=0; i&lt;Math.PI*2-step/2; i+=step){
        var topX = ( this.radius + (this.pitch/2) )*Math.cos(i);
        var topY = ( this.radius + (this.pitch/2) )*Math.sin(i);
        var bottomX = ( this.radius - (this.pitch/2) )*Math.cos(i);
        var bottomY = ( this.radius - (this.pitch/2) )*Math.sin(i);

        var topX1 = topX + 2 * Math.sin(i);
        var topY1 = topY - 2 * Math.cos(i);
        var topX2 = topX - 2 * Math.sin(i);
        var topY2 = topY + 2 * Math.cos(i);

        var bottomX1 = bottomX + 7 * Math.sin(i);
        var bottomY1 = bottomY - 7 * Math.cos(i);
        var bottomX2 = bottomX - 7 * Math.sin(i);
        var bottomY2 = bottomY + 7 * Math.cos(i);

        returnVertex.push(bottomX1);
        returnVertex.push(bottomY1);
        returnVertex.push(0);
        returnVertex.push(topX1);
        returnVertex.push(topY1);
        returnVertex.push(0);

        returnVertex.push(topX2);
        returnVertex.push(topY2);
        returnVertex.push(0);
        returnVertex.push(bottomX2);
        returnVertex.push(bottomY2);
        returnVertex.push(0);

    }

    this.vertices = returnVertex;
}
</t>
<t tx="leo.20191210203835.6">Gear.prototype.getVertices = function(){
    return this.vertices;
}
</t>
<t tx="leo.20191210203851.1">//--------------------
// Load Class
//--------------------
// updated on 2018.02.05 by jeong yunwoo

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210203857.1">function Load(_assembly, _point){
  this.assembly;
  this.link;
  this.point;
  this.gpoint;
  // this.fx = 1;
  // this.fy = 1;
  this.initialLoad = 100;
  this.loadX = this.initialLoad;
  this.loadY = this.initialLoad;

  if (_assembly != null &amp;&amp; _point != null) {
            this.assembly = _assembly
            this.link = _assembly.getBelongedLink(_point);
            this.point = _point;
            this.gpoint = this.link.getGlobalPosition(this.point);
    }
}

</t>
<t tx="leo.20191210203857.2">Load.prototype.getPoint = function() {
    return this.point;
}

</t>
<t tx="leo.20191210203857.3">Load.prototype.init = function(){
    if(this.gpoint!=null)	this.gpoint = this.link.getGlobalPosition(this.point);
}

// Load.prototype.getFy = function() {
// 	return this.fy;
// }
</t>
<t tx="leo.20191210203857.4">Load.prototype.getLoadX = function() {
    return this.loadX;
}

</t>
<t tx="leo.20191210203857.5">Load.prototype.getLoadY = function() {
    return this.loadY;
}

</t>
<t tx="leo.20191210203857.6">Load.prototype.setLoadX = function(_loadX) {
    this.loadX = _loadX;
}

</t>
<t tx="leo.20191210203857.7">Load.prototype.setLoadY = function(_loadY) {
    this.loadY = _loadY;
}

</t>
<t tx="leo.20191210203857.8">Load.prototype.getGlobalPosition = function(){
  return this.gpoint;
}
</t>
<t tx="leo.20191210203938.1"></t>
<t tx="leo.20191210204001.1">// =============================================================================
// 							Assembly Group Class
// =============================================================================
// from m.sketch 2.4 java
// updated on 2015.11.02

/**
* This is a class for organizing Assembly class in Three.js environment.
*/

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204008.1">function AssemblyGroup(){
    // for elements
    this.assembly 		= new Assembly();
    this.mechCalc 		= new MechanismCalculator();
    this.space 			= new Space();
    this.trajectoryList = new ArrayList();
    this.optimizedPath 	= new Trajectory();
    this.loadList 		= new ArrayList();

    // for THREE.JS
    this.group 			= new THREE.Object3D();
    this.plane;
    this.mousePlane;
    this.selectCube;
    this.sbGrid;
    this.mmGrid;
    this.axis;

    this.frame;

    this.anchorMaterial 	= new THREE.MeshBasicMaterial({ map: (new THREE.TextureLoader()).load('./public/res/anchor.png'),
                                                            side: THREE.DoubleSide,
                                                            transparent: true,
                                                            depthWrite: false,
                                                            depthTest: false });
    this.loadMaterial 	= new THREE.MeshBasicMaterial({ map: (new THREE.TextureLoader()).load('./public/res/load.png'), 	side: THREE.DoubleSide,
                                                            transparent: true,
                                                            depthWrite: false,
                                                            depthWrite: false,
                                                            depthTest: false });

    this.objectList 		= [];
    this.lengthList			= [];
    this.actuatorObjList  	= [];
    this.trajectoryObjList  = [];
    this.gearObjList		= [];
    this.loadObjList 		= [];

    this.segmentHoverGeometry;
    this.segmentHoverObject;
    this.segmentSelectedGeometry;
    this.segmentSelectedObject;

    this.optPathGeometry;
    this.optPathObject;


    this.prevElementsNum = 0;
    this.isHidingText = false;
    this.isRemoveText = false;
    this.needsUpdate = false;

    // CONSTRUCTOR

    this.assembly.addSpace(this.space);
    this.drawPlane();
    this.drawSelection();

}

AssemblyGroup.PLANE_SIZE 				= 1000;
AssemblyGroup.GRID_GAP					= 100;
AssemblyGroup.PLANE_COLOR 				= 0x6a3fc4;
AssemblyGroup.PLANE_OPA 				= 0.2;
AssemblyGroup.NUM_OF_GRID 				= 50;

AssemblyGroup.CUBE_SIZE 				= 30;
AssemblyGroup.CUBE_OPA 					= 0.5;

AssemblyGroup.GRID_OPA 					= 0.1;
AssemblyGroup.SBGRID_OPA 				= 0.5;

AssemblyGroup.SEGMENT_HOVER_OPA 		= 0.5;
AssemblyGroup.SEGMENT_SELECTED_OPA 		= 1;




// DECLARATION &amp; UPDATE
</t>
<t tx="leo.20191210204008.10">AssemblyGroup.prototype.getSpace = function(){
    return this.space;
}
</t>
<t tx="leo.20191210204008.11">AssemblyGroup.prototype.getMousePlane = function(){
    return this.mousePlane;
}
</t>
<t tx="leo.20191210204008.12">AssemblyGroup.prototype.getPlane = function(){
    return this.plane;
}
</t>
<t tx="leo.20191210204008.13">AssemblyGroup.prototype.getTrajectory = function(){
    return this.trajectoryList;
}
</t>
<t tx="leo.20191210204008.14">AssemblyGroup.prototype.getSelection = function(){
    return this.selectCube;
}

// DRAW COMMON FEATURES
</t>
<t tx="leo.20191210204008.15">AssemblyGroup.prototype.drawPlane = function(){
    var planeGeometry = new THREE.PlaneGeometry( AssemblyGroup.PLANE_SIZE, AssemblyGroup.PLANE_SIZE );
    var planeMaterial = new THREE.MeshBasicMaterial( { color: AssemblyGroup.PLANE_COLOR, side: THREE.DoubleSide, transparent: true, opacity: AssemblyGroup.PLANE_OPA,  depthWrite: false, depthTest: false } );

    this.group = new THREE.Object3D();
    this.plane = new THREE.Mesh( planeGeometry, planeMaterial );
    this.group.add( this.plane );

    planeGeometry = new THREE.PlaneGeometry( 9999, 9999 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: AssemblyGroup.PLANE_COLOR, side: THREE.DoubleSide, transparent: true, opacity: 0,  depthWrite: false, depthTest: false } );

    this.mousePlane = new THREE.Mesh( planeGeometry, planeMaterial );
    this.group.add( this.mousePlane );


    this.mmGrid = new THREE.GridHelper( AssemblyGroup.GRID_GAP*AssemblyGroup.NUM_OF_GRID, AssemblyGroup.NUM_OF_GRID ); // dimension, number
    this.mmGrid.material.opacity = AssemblyGroup.GRID_OPA;
    this.mmGrid.material.transparent = true;
    this.mmGrid.material.depthWrite = false;
    this.mmGrid.material.depthTest = false;
    this.mmGrid.rotation.x = Math.PI/2;
    this.group.add( this.mmGrid );


    this.sbGrid = new THREE.GridHelper( SCIENCEBOX_SNAP*AssemblyGroup.NUM_OF_GRID, AssemblyGroup.NUM_OF_GRID , EDISON_COLOR, EDISON_COLOR);
    this.sbGrid.material.opacity = AssemblyGroup.SBGRID_OPA;
    this.sbGrid.material.transparent = true;
    this.sbGrid.material.depthWrite = false;
    this.sbGrid.material.depthTest = false;
    this.sbGrid.rotation.x = Math.PI/2;
    //this.sbGrid.setColors(0x671eac, 0x671eac);
    this.group.add( this.sbGrid );

    this.axis = new THREE.AxisHelper();
    this.axis.position.set( 0, 0, 0 );
    this.axis.scale.set(100, 100, 100);
    this.group.add( this.axis );
}

</t>
<t tx="leo.20191210204008.16">AssemblyGroup.prototype.drawSelection = function(){
    var _geometry = new THREE.SphereGeometry( AssemblyGroup.CUBE_SIZE, AssemblyGroup.CUBE_SIZE, AssemblyGroup.CUBE_SIZE );
    var _material = new THREE.MeshLambertMaterial( { color: EDISON_COLOR, transparent: true, opacity: AssemblyGroup.CUBE_OPA} )
    this.selectCube = new THREE.Mesh( _geometry, _material );
    this.group.add(this.selectCube);
    this.selectCube.visible = false;

    var vertices = new Float32Array(6);
    _material = new THREE.LineBasicMaterial( { color: HOVER_COLOR, side: THREE.DoubleSide, linewidth: 2, transparent: true} );
    this.segmentHoverGeometry = new THREE.BufferGeometry();
    this.segmentHoverGeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices , 3 ).setDynamic( true ) );
    this.segmentHoverObject = new THREE.Line( this.segmentHoverGeometry, _material );
    this.group.add(this.segmentHoverObject);
    this.segmentHoverObject.position.set( 0, 0, 0.5 );

    _material = new THREE.LineBasicMaterial( { color: SELECTED_COLOR, side: THREE.DoubleSide, linewidth: 2, transparent: true} );
    this.segmentSelectedGeometry = new THREE.BufferGeometry();
    this.segmentSelectedGeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices , 3 ).setDynamic( true ) );
    this.segmentSelectedObject = new THREE.Line( this.segmentSelectedGeometry, _material );
    this.group.add(this.segmentSelectedObject);
    this.segmentSelectedObject.position.set( 0, 0, 0.5 );
}

// VISIBILITY
</t>
<t tx="leo.20191210204008.17">AssemblyGroup.prototype.showPlane = function(){
    this.plane.material.opacity = AssemblyGroup.PLANE_OPA;
    this.setOpacity(1);
    this.showText();
    this.showGrid();
}
</t>
<t tx="leo.20191210204008.18">AssemblyGroup.prototype.hidePlane = function(){
    this.plane.material.opacity = 0;
    this.setOpacity(DISABLED_PLANE_OPA);
    this.hideText();
    this.hideGrid();
}

</t>
<t tx="leo.20191210204008.19">AssemblyGroup.prototype.showGrid = function(){
    this.mmGrid.material.opacity = AssemblyGroup.GRID_OPA;
    this.axis.visible = true;
}

</t>
<t tx="leo.20191210204008.2">AssemblyGroup.prototype.init = function(){
    this.load();
    this.showGrid();
    this.hideSBGrid();
    this.onStart();
    scene.add(this.group);
}

</t>
<t tx="leo.20191210204008.20">AssemblyGroup.prototype.hideGrid = function(){
    this.mmGrid.material.opacity = 0;
    this.axis.visible = false;
}


</t>
<t tx="leo.20191210204008.21">AssemblyGroup.prototype.showSBGrid = function(){
    if(isScienceBoxSanpOn){
        this.sbGrid.material.opacity = AssemblyGroup.SBGRID_OPA;
    }else{
        this.sbGrid.material.opacity = 0;
    }
    this.hideGrid();
}

</t>
<t tx="leo.20191210204008.22">AssemblyGroup.prototype.hideSBGrid = function(){
    this.sbGrid.material.opacity = 0;
    this.showGrid();
}

</t>
<t tx="leo.20191210204008.23">AssemblyGroup.prototype.showCube = function(){
    //this.selectCube.material.opacity = AssemblyGroup.CUBE_OPA;
    this.selectCube.visible = true;
}
</t>
<t tx="leo.20191210204008.24">AssemblyGroup.prototype.hideCube = function(){
    //this.selectCube.material.opacity = 0;
    this.selectCube.visible = false;
}

</t>
<t tx="leo.20191210204008.25">AssemblyGroup.prototype.showText = function(){
    this.isHidingText = false;
}

</t>
<t tx="leo.20191210204008.26">AssemblyGroup.prototype.hideText = function(){
    this.isHidingText = true;
}


</t>
<t tx="leo.20191210204008.27">AssemblyGroup.prototype.setSettings = function(_settings){
    if(msketchSettings.showGrid)	this.group.add( this.mmGrid );
    else 							this.group.remove( this.mmGrid );

    if(msketchSettings.showPlane)	this.group.add( this.plane );
    else 							this.group.remove( this.plane );

    this.isRemoveText = !msketchSettings.showText;

    var _planeSacle =  ( msketchSettings.planeSize/SCALE_TRANS ) / AssemblyGroup.PLANE_SIZE;
    this.plane.scale.set( _planeSacle, _planeSacle, 1 );

    var _gridSacle =  ( msketchSettings.gridGap/SCALE_TRANS ) / AssemblyGroup.GRID_GAP;
    this.mmGrid.scale.set( _gridSacle, 1, _gridSacle );
}


</t>
<t tx="leo.20191210204008.28">AssemblyGroup.prototype.setOpacity = function(_opa){
    for(var i=0; i&lt;this.group.children.length; i++){
        if( this.group.children[i] != this.plane 	&amp;&amp; this.group.children[i] != this.mousePlane 	&amp;&amp; this.group.children[i] != this.plane 		&amp;&amp;
            this.group.children[i] != this.mmGrid 	&amp;&amp; this.group.children[i] != this.sbGrid 		&amp;&amp; this.group.children[i] != this.selectCube	&amp;&amp; this.group.children[i] != this.axis ){

            if(this.group.children[i].material!=null){
                this.group.children[i].material.transparent = true;
                this.group.children[i].material.opacity = _opa;
            }

            if(this.group.children[i].children.length&gt;1){
                for(j=0; j&lt;this.group.children[i].children.length; j++){
                    this.group.children[i].children[j].material.transparent = true;
                    this.group.children[i].children[j].material.opacity = _opa;
                }
            }
        }

    }
}

</t>
<t tx="leo.20191210204008.29">AssemblyGroup.prototype.setPlane = function(_z){
    this.group.position.z = _z;
}
</t>
<t tx="leo.20191210204008.3">AssemblyGroup.prototype.remove = function(){
    scene.remove(this.group);
}

</t>
<t tx="leo.20191210204008.30">AssemblyGroup.prototype.getPositionData = function(){
    var _data = new Object(); // object로 변경
    _data.tx = parseFloat(this.group.position.x);
    _data.ty = parseFloat(this.group.position.y);
    _data.tz = parseFloat(this.group.position.z);
    _data.rx = parseFloat(this.group.rotation.x);
    _data.ry = parseFloat(this.group.rotation.y);
    _data.rz = parseFloat(this.group.rotation.z);
    return _data;
}

</t>
<t tx="leo.20191210204008.31">AssemblyGroup.prototype.setPositionData = function(_data){

    this.group.position.x = parseFloat(_data.tx);
    this.group.position.y = parseFloat(_data.ty);
    this.group.position.z = parseFloat(_data.tz);
    this.group.rotation.x = parseFloat(_data.rx);
    this.group.rotation.y = parseFloat(_data.ry);
    this.group.rotation.z = parseFloat(_data.rz);

}


</t>
<t tx="leo.20191210204008.32">AssemblyGroup.prototype.savePositions = function(){
    this.assembly.savePositions();
}
</t>
<t tx="leo.20191210204008.33">AssemblyGroup.prototype.restorePositions = function(){
    this.assembly.restorePositions();
}

</t>
<t tx="leo.20191210204008.34">AssemblyGroup.prototype.calculateAssembly = function(){
    return this.mechCalc.calculateAssembly(this.assembly);
}

</t>
<t tx="leo.20191210204008.35">AssemblyGroup.prototype.actuateAll = function(_angle){
    for(var ai in this.assembly.getAllActuator().array){
        var a = this.assembly.getAllActuator().get(ai);

        if(!a.isServo){ // is dc
            var actuatingAngle = _angle*a.getSpeedMultiply();
            actuatingAngle = (a.getReverse())? actuatingAngle-a.getPhase():-actuatingAngle-a.getPhase();

            a.setValue(-actuatingAngle);
        }else{ // is servo
            var actuatingAngle = _angle*a.getSpeedMultiply();

            var startAngle 	= a.getStartAngle() + a.getPhase();
            var endAngle 	= a.getEndAngle() + a.getPhase();

            /*
            if(startAngle &gt; endAngle){
                var tempAngle 	= startAngle;
                startAngle 		= endAngle;
                endAngle 		= tempAngle;
            }
            */
            if(startAngle==endAngle) return;
            var servoAngle = startAngle+(endAngle-startAngle)/2 - (endAngle-startAngle)/2 * Math.cos( actuatingAngle/2 * (2*Math.PI/(endAngle-startAngle)) );

            a.setValue(servoAngle);

        }

    }

    return this.calculateAssembly();
}

</t>
<t tx="leo.20191210204008.36">AssemblyGroup.prototype.setAllActuator = function(_angle){ // Not in use
    for(var ai in this.assembly.getAllActuator().array){
        var a = this.assembly.getAllActuator().get(ai);
        if(a.name == _name){
            a.setValue(_angle);
        }
    }
    return this.calculateAssembly();
}

</t>
<t tx="leo.20191210204008.37">AssemblyGroup.prototype.actuateByName = function(_name, _angle){ // Not in use
    for(var ai in this.assembly.getAllActuator().array){
        var a = this.assembly.getAllActuator().get(ai);
        if(a.name == _name){
            a.setValue(_angle);
        }
    }
    return this.calculateAssembly();
}

</t>
<t tx="leo.20191210204008.38">AssemblyGroup.prototype.getAllActuator = function(){
    return this.assembly.getAllActuator();
}

</t>
<t tx="leo.20191210204008.39">AssemblyGroup.prototype.recordTrajectories = function(){
    for (var ti in this.trajectoryList.array) {
      var t=this.trajectoryList.get(ti);
      t.record();
    }
}

</t>
<t tx="leo.20191210204008.4">AssemblyGroup.prototype.load = function(){
    this.loadElements();
    this.loadActuators();
    this.loadTrajectories();
    this.loadOptPath();
    this.loadLoads();
}
</t>
<t tx="leo.20191210204008.40">AssemblyGroup.prototype.flushTrajectories = function(){
    for (var ti in this.trajectoryList.array) {
      var t=this.trajectoryList.get(ti);
      t.flush();
    }
}

</t>
<t tx="leo.20191210204008.41">AssemblyGroup.prototype.initTrajectories = function(){
    for (var ti in this.trajectoryList.array) {
      var t=this.trajectoryList.get(ti);
      t.init();
    }
}

</t>
<t tx="leo.20191210204008.42">AssemblyGroup.prototype.newTrajectory = function(_point){
    this.trajectoryList.add(new Trajectory(this.assembly, _point));
}

</t>
<t tx="leo.20191210204008.43">AssemblyGroup.prototype.newLoad = function(_point){
    this.loadList.add(new Load(this.assembly, _point));
}



// ===== DRAWING ELEMENTS =====
</t>
<t tx="leo.20191210204008.44">AssemblyGroup.prototype.loadElements = function(){

    var elementList = this.assembly.getAllElement();
    if(elementList==null) return;

    // check is it changed?
    var toBeChanged = false;
    if(elementList.array.length!=this.prevElementsNum) toBeChanged = true;

    for(var ei in elementList.array){
        var e = elementList.get(ei);
        if(e instanceof Space){
            if(e.pointIsChanged()){
                toBeChanged = true;
            }
        }
        else if(e instanceof Link){
            if(e.vertexIsChanged() || e.pointIsChanged()){
                toBeChanged = true;
            }
        }
    }

    // force to refresh
    if(this.needsUpdate){
        this.needsUpdate = false;
        toBeChanged = true;
    }

    if(!toBeChanged) return;

    // start drawing
    this.resetElements( this.objectList );
    this.resetElements( this.lengthList );
    this.objectList 	= [];
    this.lengthList 	= [];

    for(var ei in elementList.array){
        var e = elementList.get(ei);
        if(e instanceof Space){
            for(var pi in e.getPointList().array){
                var p = e.getPointList().get(pi);
                var coordinate = e.getGlobalPosition(p);

                this.objectList.push( new Anchor3D(p, coordinate.getX(), coordinate.getY(), this.group, this.anchorMaterial ) );
            }
            e.pushPoint();
        }
        else if(e instanceof Link){
            var v = e.getGlobalVertex();
            if(viewMode == 0) 		var vertices = this.getLinkVertex(v);
            else if(viewMode == 1)	var vertices = this.getLinkVertex( e.getGlobalRoundedVertex(0) );

            this.objectList.push( new Link3D(e, vertices, this.group ) );

            if(!this.isRemoveText &amp;&amp; !e.isSlider){
                for(var i=0; i&lt;v.length/4; i++){
                    var _x = (v[i*4+0]+v[i*4+2])/2;
                    var _y = (v[i*4+1]+v[i*4+3])/2;

                    this.lengthList.push( new Text3D(e, _x, _y, this.group ) );
                }
            }

            for(var pi in e.getPointList().array){
                var p = e.getPointList().get(pi);
                var coordinate = e.getGlobalPosition(p);

                if(!e.isSlider || (e.isSlider &amp;&amp; pi == 0)){
                    this.objectList.push( new Point3D(p, coordinate.getX(), coordinate.getY(), this.group ) );
                }

            }
            e.pushPoint();
            e.pushVertex();
        }
    }

    this.prevElementsNum = elementList.array.length;
}

</t>
<t tx="leo.20191210204008.45">AssemblyGroup.prototype.updateElements = function(){

     var elementList = this.assembly.getAllElement();
     if(elementList==null) return;

     for(var ei in elementList.array){
        var e = elementList.get(ei);
        if(e instanceof Space){
            for(var pi in e.getPointList().array){
                var p = e.getPointList().get(pi);
                var coordinate = e.getGlobalPosition(p);

                var obj = this.findObjectFromElement(p);
                if(obj instanceof Anchor3D){
                    obj.setPosition( coordinate.getX(), coordinate.getY() );

                    if(p == hoverPoint){
                        obj.setColor(HOVER_COLOR);
                        //obj.setScale(AssemblyGroup.HOVER_SCALE);
                    }
                    else if(p == selectedPointTg){
                        obj.setColor(SELECTED_COLOR);
                        //obj.setScale(AssemblyGroup.SELECTED_SCALE);
                    }
                    else{
                        obj.setColor(NORMAL_COLOR);
                        //obj.setScale(1);
                    }
                }
            }
        }
        else if(e instanceof Link){
            var v = e.getGlobalVertex();
            if(viewMode == 0) 		var vertices = this.getLinkVertex(v);
            else if(viewMode == 1)	var vertices = this.getLinkVertex( e.getGlobalRoundedVertex(0) );

            var v3D = e.getGlobalRoundedVertex(0); // for 3D rounded
            var vertices3D = this.getLinkVertex(v3D);

            var obj = this.findObjectFromElement(e);
            if(obj instanceof Link3D){
                obj.setVertices( vertices, vertices3D );

                if(e == hoverLink)										obj.setColor(HOVER_COLOR);
                else if(this.assembly.getUnspecified().contains(e))		obj.setColor(ERROR_COLOR);
                else	 												obj.setColor(NORMAL_COLOR);
            }

            if(!this.isRemoveText &amp;&amp; !e.isSlider){
                for(var i=0; i&lt;v.length/4; i++){
                    var _x = (v[i*4+0]+v[i*4+2])/2+120;
                    var _y = (v[i*4+1]+v[i*4+3])/2-20;

                    if(this.findLengthListFromElement(e) != null){
                        var obj = this.findLengthListFromElement(e)[i];
                        if(obj instanceof Text3D){
                            obj.setPosition(_x, _y);
                            obj.setText( (e.getLength(i)/10).toFixed(2) + "mm\nSB: " + (e.getLength(i)/(SCIENCEBOX_SNAP)).toFixed(1) );

                            if(this.isHidingText){
                                obj.setOpacity(0);
                            }else{
                                obj.setOpacity(1);
                            }

                            if(v.length/4==2 &amp;&amp; i==1){
                                obj.setOpacity(0);
                            }
                        }
                    }
                }
            }

            for(var pi in e.getPointList().array){
                var p = e.getPointList().get(pi);
                var coordinate = e.getGlobalPosition(p);

                if(!e.isSlider || (e.isSlider &amp;&amp; pi == 0)){
                    var obj = this.findObjectFromElement(p);

                    if(obj instanceof Point3D){
                        obj.setPosition( coordinate.getX(), coordinate.getY() );

                        if(p == hoverPoint){
                            obj.setColor(HOVER_COLOR);
                        }
                        else if(p == selectedPointTg){
                            obj.setColor(SELECTED_COLOR);
                        }
                        else{
                            obj.setColor(NORMAL_COLOR);
                        }
                    }
                }
            }
        }
    }
}

</t>
<t tx="leo.20191210204008.46">AssemblyGroup.prototype.loadActuators = function(){
    this.resetElements(this.actuatorObjList);
    this.actuatorObjList = [];

    var _actuatorList = this.assembly.getAllActuator();
    if(_actuatorList==null) return;

    for(var ai in _actuatorList.array){
        var a = _actuatorList.get(ai);
        if(a instanceof JointActuator){
            var x = this.assembly.getBelongedLink(a.getOriginPoint()).getGlobalPosition(a.getOriginPoint()).getX();
            var y = this.assembly.getBelongedLink(a.getOriginPoint()).getGlobalPosition(a.getOriginPoint()).getY();

            this.actuatorObjList.push( new Actuator3D( a, x, y, this.group ) );
        }
    }
}
</t>
<t tx="leo.20191210204008.47">AssemblyGroup.prototype.updateActuators = function(){
    var _actuatorList = this.assembly.getAllActuator();
    if(_actuatorList==null) return;

    for(var ai in _actuatorList.array){
        var a = _actuatorList.get(ai);
        if(a instanceof JointActuator){
            var x = this.assembly.getBelongedLink(a.getOriginPoint()).getGlobalPosition(a.getOriginPoint()).getX();
            var y = this.assembly.getBelongedLink(a.getOriginPoint()).getGlobalPosition(a.getOriginPoint()).getY();
            var lastAngle = a.getValue();

            var obj = this.findActObjFromActuator(a);
            if(obj instanceof Actuator3D){
                obj.showServoAngle( a.getStartAngle()+a.getPhase(), a.getEndAngle()+a.getPhase(), this.group);
                obj.setPosition( x, y );
                obj.setAngle( -lastAngle );

                if(this.isHidingText){
                    obj.setTextOpacity(0);
                }else{
                    obj.setTextOpacity(1);
                }

                if(a == hoverActuator){
                    obj.setColor(EDISON_COLOR);
                    //obj.setScale(AssemblyGroup.HOVER_SCALE);
                }
                else if(a == pointedActuator){
                    obj.setColor(SELECTED_COLOR);
                    //obj.setScale(AssemblyGroup.POINTED_ACTUATOR_SCALE);
                }
                else{
                    obj.setColor(ACTUATOR_COLOR);
                    //obj.setScale(1);
                }
            }
        }
    }
}

</t>
<t tx="leo.20191210204008.48">AssemblyGroup.prototype.loadTrajectories = function(){
    this.resetElements(this.trajectoryObjList);
    this.trajectoryObjList = [];

    if(this.trajectoryList==null) return;

    for (var ti in this.trajectoryList.array) {
        var t=this.trajectoryList.get(ti);

        t.init();

        var vertices = new Float32Array(MAX_TRAJECTORY_SIZE);


        for(var i =0; i&lt;vertices.length; i++){
            vertices[i] = Math.random();
        }

        this.trajectoryObjList.push( new Trajectory3D(t, vertices, t.gpoint.getX(), t.gpoint.getY(), this.group) );

    }
}
</t>
<t tx="leo.20191210204008.49">AssemblyGroup.prototype.updateTrajectories = function(){
    var interval = 1;

    for (var ti in this.trajectoryList.array) {
        var t = this.trajectoryList.get(ti);

        var pointNum = t.getTrajectory().length();

        var obj = this.findTrgObjFromTrajectory(t);
        if(obj instanceof Trajectory3D){

            if(pointNum&gt;5 &amp;&amp; (pointNum/interval)*3 &lt; MAX_TRAJECTORY_SIZE){
                var vertices = new Float32Array((pointNum/interval)*3);

                var j=0;
                for(var i=0; i&lt;pointNum; i+=interval){
                    if(t.getTrajectory().get(i)!=null){
                        vertices[j] = t.getTrajectory().get(i).getX();
                        vertices[j+1] = t.getTrajectory().get(i).getY();
                        vertices[j+2] = Trajectory3D.Z_POS;
                        j+=3;
                    }
                }

                obj.setVertices(vertices);
                obj.setDrawRange( 0, pointNum/interval );
            }

            obj.setPosition( t.gpoint.getX(), t.gpoint.getY() );
        }
    }
}
</t>
<t tx="leo.20191210204008.5">AssemblyGroup.prototype.updateRender = function(){
    this.prevElementsNum = 0;
    this.loadElements();
}

</t>
<t tx="leo.20191210204008.50">AssemblyGroup.prototype.loadOptPath = function(){
    this.group.remove(this.optPathObject);

    var segments = 18;

    if(this.optimizedPath.getTrajectory() == null) return;

    var t=this.optimizedPath;

    t.init();

    var vertices = new Float32Array(MAX_TRAJECTORY_SIZE);

    var curveMaterial = new THREE.LineBasicMaterial( { color: OPT_PATH_COLOR , side: THREE.DoubleSide, linewidth: 2 } );

    this.optPathGeometry = new THREE.BufferGeometry();
    this.optPathGeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ).setDynamic( true ) );
    this.optPathGeometry.setDrawRange( 0, 0 );
    this.optPathObject = new THREE.Line ( this.optPathGeometry , curveMaterial )

    this.group.add( this.optPathObject );
}
</t>
<t tx="leo.20191210204008.51">AssemblyGroup.prototype.updateOptPath = function(){
    var interval = 1;

    var t = this.optimizedPath;

    if(t.getTrajectory() == null) return;

    var pointNum = t.getTrajectory().length();

    if(pointNum&gt;5 &amp;&amp; (pointNum/interval)*3 &lt; MAX_TRAJECTORY_SIZE){
        var vertices = new Float32Array((pointNum/interval)*3);

        var j=0;
        for(var i=0; i&lt;pointNum; i+=interval){
            if(t.getTrajectory().get(i)!=null){
                vertices[j] = t.getTrajectory().get(i).getX();
                vertices[j+1] = t.getTrajectory().get(i).getY();
                vertices[j+2] = -1;
                j+=3;
            }
        }

        this.optPathGeometry.attributes.position.array = vertices;
        this.optPathGeometry.setDrawRange( 0, pointNum/interval );
        this.optPathGeometry.attributes.position.needsUpdate = true;

    }
}


// Load and Update Load Function
</t>
<t tx="leo.20191210204008.52">AssemblyGroup.prototype.loadLoads = function(){
    this.resetElements(this.loadObjList);
    this.loadObjList = [];

    if(this.loadList==null) return;

    for (var ti in this.loadList.array) {
        var t=this.loadList.get(ti);
        t.init();
        this.loadObjList.push( new Load3D(t, t.gpoint.getX(), t.gpoint.getY(), this.group, this.loadMaterial) );
    }
}

</t>
<t tx="leo.20191210204008.53">AssemblyGroup.prototype.updateLoads = function(){
    for (var ti in this.loadList.array) {
        var t = this.loadList.get(ti);
        var obj = this.findLoadObjFromLoad(t);
        if(obj instanceof Load3D){
            obj.setPosition( t.gpoint.getX(), t.gpoint.getY() );
        }
  }
}



// for selection of link
</t>
<t tx="leo.20191210204008.54">AssemblyGroup.prototype.drawHoverSegment = function(_x, _y){
  var targetLink = getLinkByPosition(_x, _y);

  if( targetLink!=null){

    if(targetLink.isSlider) return false;

    var pointPair = findPointPair(targetLink, _x, _y);

    var vertices = new Float32Array(6);

    if(pointPair!=null){
      vertices[0] = targetLink.getGlobalPosition(pointPair[0]).getX();
      vertices[1] = targetLink.getGlobalPosition(pointPair[0]).getY();
      vertices[2] = 0;
      vertices[3] = targetLink.getGlobalPosition(pointPair[1]).getX();
      vertices[4] = targetLink.getGlobalPosition(pointPair[1]).getY();
      vertices[5] = 0;
    }

    this.updateSegmentHover(vertices);
  }
  else{
    this.updateSegmentHover(new Float32Array(6));
  }
}

</t>
<t tx="leo.20191210204008.55">AssemblyGroup.prototype.updateSegmentHover = function(vertices){
    this.segmentHoverGeometry.attributes.position.array = vertices;
    this.segmentHoverGeometry.attributes.position.needsUpdate = true;
    this.segmentHoverObject.material.opacity = AssemblyGroup.SEGMENT_HOVER_OPA;
}
</t>
<t tx="leo.20191210204008.56">AssemblyGroup.prototype.setSegmentSelected = function(_link, _pair){
    var vertices = new Float32Array(6);

    if(_pair!=null){
      vertices[0] = _link.getGlobalPosition(_pair[0]).getX();
      vertices[1] = _link.getGlobalPosition(_pair[0]).getY();
      vertices[2] = 0;
      vertices[3] = _link.getGlobalPosition(_pair[1]).getX();
      vertices[4] = _link.getGlobalPosition(_pair[1]).getY();
      vertices[5] = 0;
    }

    this.segmentSelectedGeometry.attributes.position.array = vertices;
    this.segmentSelectedGeometry.attributes.position.needsUpdate = true;
    this.segmentSelectedObject.material.opacity = AssemblyGroup.SEGMENT_SELECTED_OPA;
}
</t>
<t tx="leo.20191210204008.57">AssemblyGroup.prototype.removeSegmentSelected = function(){
    var vertices = new Float32Array(6);
    this.segmentHoverGeometry.attributes.position.array = vertices;
    this.segmentHoverGeometry.attributes.position.needsUpdate = true;
    this.segmentSelectedGeometry.attributes.position.array = vertices;
    this.segmentSelectedGeometry.attributes.position.needsUpdate = true;
}

// Used to convert Link vertext to Float32Array
</t>
<t tx="leo.20191210204008.58">AssemblyGroup.prototype.getLinkVertex = function(_v){
    var zPos = Link3D.Z_POS;
    var returnVertex = new Float32Array(_v.length*1.5+3);

    var j = 0;
    for(var i = 0; i&lt;returnVertex.length-3; i+=3){
        returnVertex[i] = _v[j];
        returnVertex[i+1] = _v[j+1];
        returnVertex[i+2] = zPos;
        j+=2;
    }
    returnVertex[returnVertex.length-3] = _v[0];
    returnVertex[returnVertex.length-2] = _v[1];
    returnVertex[returnVertex.length-1] = zPos;

    return returnVertex;
}

</t>
<t tx="leo.20191210204008.59">AssemblyGroup.prototype.findObjectFromElement = function(_e){
    for(var i=0; i&lt;this.objectList.length; i++){
        if(this.objectList[i].findFromElement(_e)){
            return this.objectList[i];
        }
    }
    return null;
}
</t>
<t tx="leo.20191210204008.6">AssemblyGroup.prototype.update = function(){
    this.updateElements();
    this.updateActuators();
    this.updateTrajectories();
    this.updateOptPath();
    this.updateLoads();
}

</t>
<t tx="leo.20191210204008.60">AssemblyGroup.prototype.findActObjFromActuator = function(_a){
    for(var i=0; i&lt;this.actuatorObjList.length; i++){
        if(this.actuatorObjList[i].findFromElement(_a)){
            return this.actuatorObjList[i];
        }
    }
    return null;
}
</t>
<t tx="leo.20191210204008.61">AssemblyGroup.prototype.findTrgObjFromTrajectory = function(_t){
    for(var i=0; i&lt;this.trajectoryObjList.length; i++){
        if(this.trajectoryObjList[i].findFromElement(_t)){
            return this.trajectoryObjList[i];
        }
    }
    return null;
}

</t>
<t tx="leo.20191210204008.62">AssemblyGroup.prototype.findLoadObjFromLoad = function(_l){
    for(var i=0; i&lt;this.loadObjList.length; i++){
        if(this.loadObjList[i].findFromElement(_l)){
            return this.loadObjList[i];
        }
    }
    return null;
}

</t>
<t tx="leo.20191210204008.63">AssemblyGroup.prototype.findLengthListFromElement = function(_e){
    var returnValue = [];

    for(var i=0; i&lt;this.lengthList.length; i++){
        if(this.lengthList[i].findFromElement(_e)){
            returnValue.push( this.lengthList[i] );
        }
    }

    if(returnValue.length != 0) return returnValue;

    return null;
}
</t>
<t tx="leo.20191210204008.64">AssemblyGroup.prototype.resetElements = function(_objArray){
    // Reset Geometry and Objects
    for(var i = 0; i &lt; _objArray.length; i++){
        _objArray[i].remove( this.group );
    }

    //**********************
    //*TRASH COLLECTOR
    //*********************

    if ( renderer instanceof THREE.CanvasRenderer ) {

        scene.__lights = { length: 0, push: function(){}, indexOf: function (){ return -1 }, splice: function(){} }
        scene.__objectsAdded = { length: 0, push: function(){}, indexOf: function (){ return -1 }, splice: function(){} }
        scene.__objectsRemoved = { length: 0, push: function(){}, indexOf: function (){ return -1 }, splice: function(){} }

    }
    // End of Reset
}


// added for try360
</t>
<t tx="leo.20191210204008.65">AssemblyGroup.prototype.try360 = function(){
    this.savePositions();
    this.onStart();
    this.flushTrajectories();

    var step = (2*Math.PI) / OptInterface.SAMPLE_SIZE;
    var maxCost = 0;

    /*
    for(var tempAngle = 0; tempAngle &lt; 2 * Math.PI + step/2; tempAngle+=step){
        for(var aci in this.assembly.getAllActuator().array){
            var ac = this.assembly.getAllActuator().get(aci);
            ac.setValue(tempAngle);
        }

        var d = this.calculateAssembly();
        if(maxCost&lt;d)
          maxCost = d;
        if(d == Number.POSITIVE_INFINITY){
          break;
        }

        this.recordTrajectories();
    }
    */

    for(var tempAngle = 0; tempAngle &lt; 2 * Math.PI + step/2; tempAngle+=step){
        this.actuateAll(tempAngle);

        var d = this.calculateAssembly();
        if(maxCost&lt;d)
          maxCost = d;
        if(d == Number.POSITIVE_INFINITY){
          break;
        }

        if(isPathOptimizing){
            this.trajectoryList.get(baseTrjInd).record();
        }else{
            this.recordTrajectories();
        }

    }



    this.onEnd();
    this.restorePositions();
    this.initTrajectories();

    this.update();
    return maxCost;
}


// Gear 3D
</t>
<t tx="leo.20191210204008.66">AssemblyGroup.prototype.makeGear = function(){
    this.resetElements(this.gearObjList);
    this.gearObjList = [];

    var _actuatorList = this.assembly.getAllActuator();
    if(_actuatorList==null) return false;

    if(_actuatorList.array.length &lt; 2){
        //showSnackBar("2개 이상의 모터가 필요합니다.", "More than 2 motors are required.");
        return false;
    }
    // currently for pair
    for(var ai in _actuatorList.array){
        var a = _actuatorList.get(ai);
        var ai = parseInt(ai);
        var aNext = _actuatorList.get(ai+1);

        if(a instanceof JointActuator){

            if(aNext!=null){
                var x = this.assembly.getBelongedLink(a.getOriginPoint()).getGlobalPosition(a.getOriginPoint()).getX();
                var y = this.assembly.getBelongedLink(a.getOriginPoint()).getGlobalPosition(a.getOriginPoint()).getY();

                var xNext = this.assembly.getBelongedLink(aNext.getOriginPoint()).getGlobalPosition(aNext.getOriginPoint()).getX();
                var yNext = this.assembly.getBelongedLink(aNext.getOriginPoint()).getGlobalPosition(aNext.getOriginPoint()).getY();

                var dist = MMath.dist( new Point2D(x, y), new Point2D(xNext, yNext) );

                var speed = a.getSpeedMultiply();
                var speedNext = aNext.getSpeedMultiply();

                var radius = dist * speedNext / (speed + speedNext);
                var radiusNext = dist * speed / (speed + speedNext);

                var interGearRadius = SCIENCEBOX_SNAP * 0.5;
                var interX = x + (xNext - x) * speedNext / (speed + speedNext);
                var interY = y + (yNext - y) * speed / (speed + speedNext);

                if(a.getReverse() == aNext.getReverse()){
                    this.gearObjList.push( new Gear3D(x, y, radius - interGearRadius, ai+1) );
                    this.gearObjList.push( new Gear3D(xNext, yNext, radiusNext - interGearRadius, ai+1) );

                    this.gearObjList.push( new Gear3D(interX, interY, interGearRadius, ai+1) );
                }else{
                    this.gearObjList.push( new Gear3D(x, y, radius, ai+1) );
                    this.gearObjList.push( new Gear3D(xNext, yNext, radiusNext, ai+1) );
                }
            }

        }
    }
}

</t>
<t tx="leo.20191210204008.67">AssemblyGroup.prototype.removeGear = function(){
    this.resetElements(this.gearObjList);
    this.gearObjList = [];
}

</t>
<t tx="leo.20191210204008.68">function Gear3D(_x, _y, _r, _z, _a){
    this.gear = new Gear();
    this.gear.setRadius(_r);
    this.gear.setPoint(new Point2D(_x, _y));
    this.stack = _z;
    this.gearObject = null

    this.createShape(currentAssemblyGroup.group);
}

Gear3D.HEIGHT			= 30;
Gear3D.EXTRUDE_SET		= {
                            steps: 1,
                            amount: Gear3D.HEIGHT,
                            bevelEnabled: false
                        };
Gear3D.HOLE_SIZE		= 20;

</t>
<t tx="leo.20191210204008.69">Gear3D.prototype.createShape = function(_group){
    _vertices = this.gear.getVertices();

    this.shape = new THREE.Shape();
    this.shape.moveTo(_vertices[0], _vertices[1]);
    for(var i=0; i&lt;_vertices.length; i+=3){
        this.shape.lineTo(_vertices[i], _vertices[i+1]);
    }
    this.shape.lineTo(_vertices[0], _vertices[1]);

    this.gearGeometry = new THREE.ExtrudeGeometry( this.shape, Gear3D.EXTRUDE_SET );
    this.gearMaterial = new THREE.MeshStandardMaterial( {color: 0xC0C0C0, transparent: true, blending: THREE.MultiplyBlending } );
    //this.gearObject = new THREE.Mesh( this.gearGeometry, this.gearMaterial ) ;

    var gear3Dbsp = new ThreeBSP( this.gearGeometry );

    // making hole
    var holeGeometry = new THREE.CylinderGeometry( Gear3D.HOLE_SIZE, Gear3D.HOLE_SIZE, Gear3D.HEIGHT+1, 16 );
    holeGeometry.rotateX( -Math.PI/2 );
    holeGeometry.translate(0, 0, Gear3D.HEIGHT/2);
    var holeMesh = new THREE.Mesh( holeGeometry, this.gearMaterial );

    gear3Dbsp = gear3Dbsp.subtract( new ThreeBSP( holeMesh ) );


    if(this.gear.radius &gt; SCIENCEBOX_SNAP * 1.2){
        holeMesh.position.set(SCIENCEBOX_SNAP, 0, 0);
        gear3Dbsp = gear3Dbsp.subtract( new ThreeBSP( holeMesh ) );
        holeMesh.position.set(-SCIENCEBOX_SNAP, 0, 0);
        gear3Dbsp = gear3Dbsp.subtract( new ThreeBSP( holeMesh ) );
    }

    this.gearObject = gear3Dbsp.toMesh( this.gearMaterial );

    this.gearObject.position.set(this.gear.getPoint().getX(), this.gear.getPoint().getY(), - this.stack * Gear3D.HEIGHT);

    _group.add(this.gearObject);
}

</t>
<t tx="leo.20191210204008.7">AssemblyGroup.prototype.onStart = function(){
    this.mechCalc.onStart(this.assembly);
}
</t>
<t tx="leo.20191210204008.70">Gear3D.prototype.remove = function(_group){
    _group.remove( this.gearObject );
}

// frame
</t>
<t tx="leo.20191210204008.71">AssemblyGroup.prototype.makeFrame = function(_d, _a){

    this.group.remove(this.frame);

    //find max area
    var max = new Point2D(-9999, -9999);
    var min = new Point2D(9999, 9999);

    var elementList = this.assembly.getAllElement();
    if(elementList==null) return;

    for(var ei in elementList.array){
       var e = elementList.get(ei);
       if(e instanceof Space){
           for(var pi in e.getPointList().array){
               var p = e.getPointList().get(pi);
               var coordinate = e.getGlobalPosition(p);

               if(coordinate.getX()&gt;max.getX()){
                max.x = coordinate.getX();
                }
                if(coordinate.getX()&lt;min.getX()){
                    min.x = coordinate.getX();
                }
                if(coordinate.getY()&gt;max.getY()){
                    max.y = coordinate.getY();
                }
                if(coordinate.getY()&lt;min.getY()){
                    min.y = coordinate.getY();
                }
           }
       }
   }

    var margin = 200;
    var frameWidth = max.getX()-min.getX() + margin*2;
    var frameHeight = max.getY()-min.getY() + margin*2;
    var frameThickness = 30;


    var frameX = (max.getX()+min.getX())/2;
    var frameY = (max.getY()+min.getY())/2;

    var frameMaterial = new THREE.MeshStandardMaterial( {color: 0xC0C0C0, transparent: true, blending: THREE.MultiplyBlending } );

    var frontGeometry = new THREE.BoxGeometry( frameWidth, frameHeight, frameThickness );
    var frontMesh = new THREE.Mesh( frontGeometry, frameMaterial );
    frontMesh.position.set( frameX, frameY, 0 );

    var frameBsp = new ThreeBSP( frontMesh );

    // holes
    for(var ei in elementList.array){
       var e = elementList.get(ei);
       if(e instanceof Space){
           for(var pi in e.getPointList().array){
               var p = e.getPointList().get(pi);
               var coordinate = e.getGlobalPosition(p);

               var holeGeometry = new THREE.CylinderGeometry( Gear3D.HOLE_SIZE, Gear3D.HOLE_SIZE, frameThickness+1, 16 );
                holeGeometry.rotateX( -Math.PI/2 );
                holeGeometry.translate(coordinate.getX(), coordinate.getY(), 0);
                var holeMesh = new THREE.Mesh( holeGeometry, frameMaterial );

                frameBsp = frameBsp.subtract( new ThreeBSP( holeMesh ) );
           }
       }
   }

   var maxGearStack = 0;
   for(var gi in this.gearObjList){
      var g = this.gearObjList[gi];

      var coordinate = g.gear.getPoint();

      var holeGeometry = new THREE.CylinderGeometry( Gear3D.HOLE_SIZE, Gear3D.HOLE_SIZE, frameThickness+1, 16 );
       holeGeometry.rotateX( -Math.PI/2 );
       holeGeometry.translate(coordinate.getX(), coordinate.getY(), 0);
       var holeMesh = new THREE.Mesh( holeGeometry, frameMaterial );

       frameBsp = frameBsp.subtract( new ThreeBSP( holeMesh ) );
       maxGearStack = this.gearObjList[gi].stack;
  }
    // anotherSide
    var anotherSideFrame = frameBsp.toMesh( frameMaterial ).clone();
    anotherSideFrame.position.set(frameX, frameY, -_d/SCALE_TRANS);
    frameBsp = frameBsp.union( new ThreeBSP( anotherSideFrame ) );

    // bottom
    var bottomGeometry = new THREE.BoxGeometry( frameWidth, frameThickness, _d/SCALE_TRANS+frameThickness);
    var bottomMesh = new THREE.Mesh( bottomGeometry, frameMaterial );
    bottomMesh.position.set( frameX, frameY-frameHeight/2, -(_d/SCALE_TRANS)/2 );
    frameBsp = frameBsp.union( new ThreeBSP( bottomMesh ) );

    // motorBox

    if(_a != null){
        var _aX = this.assembly.getBelongedLink(_a.getOriginPoint()).getGlobalPosition(_a.getOriginPoint()).getX();
        var _aY = this.assembly.getBelongedLink(_a.getOriginPoint()).getGlobalPosition(_a.getOriginPoint()).getY();

        var motorBoxWidth = 320;
        var motorBoxDepth = 280;
        var motorBoxX = _aX - motorBoxWidth/2 - SCIENCEBOX_SNAP - 45;
        var motorBoxY = _aY - 95 - frameThickness/2;

        var motorBoxGeometry = new THREE.BoxGeometry( motorBoxWidth, frameThickness, motorBoxDepth );
        var motorBoxMesh = new THREE.Mesh( motorBoxGeometry, frameMaterial );

        var motorBoxBsp = new ThreeBSP(motorBoxMesh);

        var sideWidth = frameX - motorBoxX + motorBoxWidth/2 - frameWidth/2 + 100;
        if(sideWidth&lt;motorBoxWidth) sideWidth = motorBoxWidth;
        var sideHeight = motorBoxY - frameY + frameHeight/2 + frameThickness
        var sideX = (sideWidth - motorBoxWidth)/2;
        var sideY = -sideHeight/2 + frameThickness/2

        var motorBoxSideGeometry = new THREE.BoxGeometry( sideWidth, sideHeight, frameThickness );

        var motorBoxSideMesh = new THREE.Mesh( motorBoxSideGeometry, frameMaterial );
        motorBoxSideMesh.position.set(sideX, sideY, -motorBoxDepth/2 + frameThickness/2 )
        motorBoxBsp = motorBoxBsp.union( new ThreeBSP(motorBoxSideMesh) );

        motorBoxSideMesh.position.set(sideX, sideY, +motorBoxDepth/2 - frameThickness/2 )
        motorBoxBsp = motorBoxBsp.union( new ThreeBSP(motorBoxSideMesh) );

        var holeGeometry = new THREE.CylinderGeometry( Gear3D.HOLE_SIZE, Gear3D.HOLE_SIZE, frameThickness+1, 16 );
        var holeMesh = new THREE.Mesh( holeGeometry, frameMaterial );
        holeMesh.position.set(motorBoxWidth/2 - 70, 0, -SCIENCEBOX_SNAP/2);
        var motorBoxBsp = motorBoxBsp.subtract( new ThreeBSP( holeMesh ));

        holeMesh.position.set(motorBoxWidth/2 - 70, 0, +SCIENCEBOX_SNAP/2);
        motorBoxBsp = motorBoxBsp.subtract( new ThreeBSP( holeMesh ));
        holeMesh.position.set(motorBoxWidth/2 - 70 - SCIENCEBOX_SNAP, 0, -SCIENCEBOX_SNAP/2);
        motorBoxBsp = motorBoxBsp.subtract( new ThreeBSP( holeMesh ));
        holeMesh.position.set(motorBoxWidth/2 - 70 - SCIENCEBOX_SNAP, 0, +SCIENCEBOX_SNAP/2);
        motorBoxBsp = motorBoxBsp.subtract( new ThreeBSP( holeMesh ));


        var motorBoxMesh = motorBoxBsp.toMesh( frameMaterial );
        motorBoxMesh.position.set(motorBoxX, motorBoxY, -(_d/SCALE_TRANS)/2 - frameThickness/2);
        frameBsp = frameBsp.union( new ThreeBSP(motorBoxMesh) );

        var motorBottomGeometry = new THREE.BoxGeometry( motorBoxWidth, frameThickness, motorBoxDepth -frameThickness*2);
        var motorBottomMesh = new THREE.Mesh( motorBottomGeometry, frameMaterial );
        motorBottomMesh.position.set(motorBoxX, frameY-frameHeight/2, -(_d/SCALE_TRANS)/2 - frameThickness/2);

        //this.group.add(motorBottomMesh)
        frameBsp = frameBsp.subtract( new ThreeBSP(motorBottomMesh) );

    }
    //bottomMesh.position.set( frameX, frameY-frameHeight/2, -(_d/SCALE_TRANS)/2 );
    //frameBsp = frameBsp.union( new ThreeBSP( bottomMesh ) );

    this.frame = frameBsp.toMesh( frameMaterial );

    this.frame.position.z = -(maxGearStack+0.5) * Gear3D.HEIGHT;

    this.group.add( this.frame );
}

</t>
<t tx="leo.20191210204008.72">AssemblyGroup.prototype.removeFrame = function(){
    this.group.remove( this.frame );
}
</t>
<t tx="leo.20191210204008.8">AssemblyGroup.prototype.onEnd = function(){
    this.mechCalc.onEnd(this.assembly);
}

// RETURNS
</t>
<t tx="leo.20191210204008.9">AssemblyGroup.prototype.getAssembly = function(){
    return this.assembly;
}
</t>
<t tx="leo.20191210204023.1">// =============================== Drawing Three.js Elements ===========================

// Link
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204028.1">function Link3D(_l, _v, _group){
    this.link = _l;
    this.prevVertex = null;
    this.prevLengths = null;

    this.linkMaterial 	= new THREE.LineBasicMaterial( { color: NORMAL_COLOR , side: THREE.DoubleSide, linewidth: Link3D.LINE_WIDTH } );
    //this.linkMaterial = new THREE.MeshBasicMaterial( {color: 0xff0000} );
    this.linkGeometry	= new THREE.BufferGeometry();
    this.linkGeometry.addAttribute( 'position', new THREE.BufferAttribute( _v, 3 ).setDynamic( true ) );
    this.linkObject		= new THREE.Line( this.linkGeometry, this.linkMaterial );
    //this.linkObject		= new THREE.Mesh( this.linkGeometry, this.linkMaterial );
    _group.add( this.linkObject );


    // for 3D init
    this.stack = this.link.stack;

    this.group3D = new THREE.Object3D();

    this.link3DGeometry = new THREE.Object3D();
    this.link3DMaterial = new THREE.MeshStandardMaterial( {color: 0xC0C0C0, transparent: true, blending: THREE.MultiplyBlending } );
    this.transparentMaterial = new THREE.MeshStandardMaterial({color: 0xffffff, transparent: true, blending: THREE.SubtractiveBlending });
    this.link3DObject = new THREE.Mesh( this.link3DGeometry, this.link3DMaterial ) ;
    this.group3D.add(this.link3DObject);

    this.link3DHoles = new THREE.Object3D();
    this.group3D.add(this.link3DHoles);


}
Link3D.Z_POS 			= 0;
Link3D.LINE_WIDTH		= 2;
Link3D.SHOW_3D 			= false;

</t>
<t tx="leo.20191210204028.10">Point3D.prototype.remove = function (_group){
    _group.remove( this.lineObject );
    _group.remove( this.fillObject );
}
</t>
<t tx="leo.20191210204028.11">Point3D.prototype.findFromElement = function(_p){
    if(this.point == _p) 	return true;
    else 					return false;
}
</t>
<t tx="leo.20191210204028.12">Point3D.prototype.setPosition = function(_x, _y){
    this.fillObject.position.set( _x, _y, Point3D.Z_POS );
    this.lineObject.position.set( _x, _y, Point3D.Z_POS );
}
</t>
<t tx="leo.20191210204028.13">Point3D.prototype.setScale = function(_scale){
    this.fillObject.scale.set( _scale, _scale, _scale );
    this.lineObject.scale.set( _scale, _scale, _scale );
}
</t>
<t tx="leo.20191210204028.14">Point3D.prototype.setColor = function(_color){

    if(_color == NORMAL_COLOR){
        this.fillMaterial.color.setHex( 0xffffff );
        this.fillMaterial.opacity = 0;
    }else{
        this.fillMaterial.color.setHex( _color );
        this.fillMaterial.opacity = 0.5;
    }
    //this.lineMaterial.color.setHex( _color );
}

// Anchor
</t>
<t tx="leo.20191210204028.15">function Anchor3D(_p, _x, _y, _group, _material){
    this.point 				= _p;

    this.anchorGeometry 	= new THREE.PlaneGeometry( Anchor3D.ANCHOR_SIZE, Anchor3D.ANCHOR_SIZE );
    this.anchorObject 		= new THREE.Mesh( this.anchorGeometry, _material );

    this.anchorObject.overdraw = true;
    this.anchorObject.position.set( _x, _y, Anchor3D.Z_POS );
    _group.add( this.anchorObject );

    this.point3D 			= new Point3D( _p, _x, _y, _group );
}

Anchor3D.ANCHOR_SIZE	= 80;
Anchor3D.Z_POS 			= -0.1;


</t>
<t tx="leo.20191210204028.16">Anchor3D.prototype.remove = function(_group){
    this.point3D.remove( _group );
    _group.remove( this.anchorObject );
}
</t>
<t tx="leo.20191210204028.17">Anchor3D.prototype.findFromElement = function(_p){
    if(this.point == _p) 	return true;
    else 					return false;
}
</t>
<t tx="leo.20191210204028.18">Anchor3D.prototype.setPosition = function(_x, _y){
    this.anchorObject.position.set( _x, _y, Anchor3D.Z_POS );
    this.point3D.setPosition( _x, _y );
}
</t>
<t tx="leo.20191210204028.19">Anchor3D.prototype.setScale = function(_scale){
    this.point3D.setScale( _scale );
}
</t>
<t tx="leo.20191210204028.2">Link3D.prototype.remove = function (_group){
    _group.remove( this.linkObject );
}
</t>
<t tx="leo.20191210204028.20">Anchor3D.prototype.setColor = function(_color){
    this.point3D.setColor( _color );
}

// Text
</t>
<t tx="leo.20191210204028.21">function Text3D(_l, _x, _y, _group){
    this.link 			= _l;
    this.prevText		= "";

    this.canvas 		= document.createElement('canvas');
    this.canvas.width 	= 256;
    this.canvas.height 	= 128;

    this.context 		= this.canvas.getContext('2d');

    this.texture 		= new THREE.Texture(this.canvas);
    this.texture.needsUpdate = true;

    this.textMaterial   = new THREE.MeshBasicMaterial( {map: this.texture, side:THREE.DoubleSide , transparent: true, depthWrite: false, depthTest: false} );
    this.textGeometry	= new THREE.PlaneGeometry( this.canvas.width, this.canvas.height );
    this.textObject		= new THREE.Mesh( this.textGeometry, this.textMaterial );

    this.textObject.position.set( _x, _y, Text3D.Z_POS );
    _group.add( this.textObject );
}

Text3D.Z_POS 	= 0;

</t>
<t tx="leo.20191210204028.22">Text3D.prototype.remove = function(_group){
    _group.remove( this.textObject );
}
</t>
<t tx="leo.20191210204028.23">Text3D.prototype.findFromElement = function(_l){
    if(this.link == _l) 	return true;
    else 					return false;
}
</t>
<t tx="leo.20191210204028.24">Text3D.prototype.setPosition = function(_x, _y){
    this.textObject.position.set( _x, _y, Text3D.Z_POS );
}
</t>
<t tx="leo.20191210204028.25">Text3D.prototype.setText = function(_text){
    if(_text == this.prevText) return;

    this.canvas 	= this.textMaterial.map.image;

    this.context 	= this.canvas.getContext('2d');
    this.context.clearRect( 0, 0, this.canvas.width, this.canvas.height );
    this.context.font 		= "24px Nunito";
    this.context.fillStyle 	= "rgba(0,0,0,0.9)";
    this.context.fillText(_text.split('\n')[0], 0, 80);

    if(_text.split('\n').length&gt;0){
        this.context.font 		= "18px Nunito";
        this.context.fillStyle 	= "rgba(0,0,0,0.9)";
        this.context.fillText("("+ _text.split('\n')[1] +")", 0, 100);
    }

    this.textMaterial.map.needsUpdate = true;
    this.prevText = _text;
}
</t>
<t tx="leo.20191210204028.26">Text3D.prototype.setOpacity = function(_opa){
    this.textMaterial.opacity = _opa;
}

// Actuator
</t>
<t tx="leo.20191210204028.27">function Actuator3D(_a, _x, _y, _group){
    this.actuator 			= _a;
    this.startAngle 		= 0;
    this.endAngle 			= 0;

    this.actGeometry 		= new THREE.CircleGeometry( Actuator3D.ACTUATOR_SIZE, Actuator3D.SEGMENT );
    //this.actGeometry.vertices.shift();
    this.actMaterial 		= new THREE.LineBasicMaterial( { color: ACTUATOR_COLOR, 	side: THREE.DoubleSide, 	linewidth: Actuator3D.LINE_WIDTH } );
    this.actObject			= new THREE.Line( this.actGeometry, this.actMaterial );
    this.actObject.position.set( 0, 0, 0 );

    this.dotGeometry 		= new THREE.CircleGeometry( Actuator3D.DOT_SIZE, Actuator3D.SEGMENT );
    this.dotGeometry.vertices.shift();
    this.dotMaterial 		= new THREE.MeshBasicMaterial( { color: ACTUATOR_COLOR, 	side: THREE.DoubleSide} );
    this.dotObject			= new THREE.Mesh( this.dotGeometry, this.dotMaterial );
    this.dotObject.position.set( Actuator3D.ACTUATOR_SIZE, 0, 0 );

    this.subGroup 			= new THREE.Object3D();
    this.subGroup.add(this.actObject);
    this.subGroup.add(this.dotObject);

    this.subGroup.position.set( _x, _y, Actuator3D.Z_POS );

    _group.add( this.subGroup );

    // text
    this.canvas 		= document.createElement('canvas');
    this.canvas.width 	= 256;
    this.canvas.height 	= 256;

    this.context 		= this.canvas.getContext('2d');
    this.context.clearRect( 0, 0, this.canvas.width, this.canvas.height );
    this.context.font 		= "24px Nunito";
    this.context.fillStyle 	= "rgba(0,0,0,0.9)";
    this.context.fillText(this.actuator.getName(), 90, 80);

    this.texture 		= new THREE.Texture(this.canvas);
    this.texture.needsUpdate = true;

    this.textMaterial   = new THREE.MeshBasicMaterial( {map: this.texture, side:THREE.DoubleSide , transparent: true, depthWrite: false, depthTest: false} );
    this.textGeometry	= new THREE.PlaneGeometry( this.canvas.width, this.canvas.height );
    this.textObject		= new THREE.Mesh( this.textGeometry, this.textMaterial );

    this.textObject.position.set( _x, _y, Actuator3D.Z_POS );

    _group.add( this.textObject );


    //arc

    this.angleCurve = new THREE.EllipseCurve(
        0, 0,  // ax, aY
        0, 0,  // xRadius, yRadius
        0, 0,  // aStartAngle, aEndAngle
        true,  // aClockwise
        0      // aRotation
    );

    this.anglePath 		= new THREE.Path( this.angleCurve.getPoints( Actuator3D.SEGMENT ) );
    this.angleGeometry 	= this.anglePath.createPointsGeometry( Actuator3D.SEGMENT );
    this.angleMaterial 	= new THREE.LineBasicMaterial( { color: ACTUATOR_COLOR, 	side: THREE.DoubleSide, 	linewidth: Actuator3D.LINE_WIDTH, transparent: true, opacity:0 } );
    this.angleObject = new THREE.Line( this.angleGeometry, this.angleMaterial );

    this.angleObject.position.set( _x, _y, Actuator3D.Z_POS );

    _group.add( this.angleObject );

}

Actuator3D.ACTUATOR_SIZE	= 32;
Actuator3D.DOT_SIZE			= 3;
Actuator3D.Z_POS 			= 0.2;
Actuator3D.SEGMENT			= 32;
Actuator3D.LINE_WIDTH		= 2;

</t>
<t tx="leo.20191210204028.28">Actuator3D.prototype.remove = function(_group){
    _group.remove( this.subGroup );
    _group.remove( this.textObject );
    _group.remove( this.angleObject );
}
</t>
<t tx="leo.20191210204028.29">Actuator3D.prototype.findFromElement = function(_a){
    if(this.actuator == _a) 	return true;
    else 						return false;
}
</t>
<t tx="leo.20191210204028.3">Link3D.prototype.findFromElement = function(_l){
    if(this.link == _l) 	return true;
    else 					return false;
}
</t>
<t tx="leo.20191210204028.30">Actuator3D.prototype.setPosition = function(_x, _y){
    this.subGroup.position.set( _x, _y, Actuator3D.Z_POS );
    this.textObject.position.set( _x, _y, Actuator3D.Z_POS );
    this.angleObject.position.set( _x, _y, Actuator3D.Z_POS );
}
</t>
<t tx="leo.20191210204028.31">Actuator3D.prototype.setAngle = function(_angle){
    this.subGroup.rotation.z = _angle;
}
</t>
<t tx="leo.20191210204028.32">Actuator3D.prototype.setColor = function(_color){
    this.actMaterial.color.setHex( _color );
    this.dotMaterial.color.setHex( _color );
    this.angleMaterial.color.setHex( _color );
}
</t>
<t tx="leo.20191210204028.33">Actuator3D.prototype.setScale = function(_scale){
    this.subGroup.scale.set( _scale, _scale, _scale );
    this.angleObject.scale.set( _scale, _scale, _scale );
}
</t>
<t tx="leo.20191210204028.34">Actuator3D.prototype.setTextOpacity = function(_opa){
    this.textMaterial.opacity = _opa;
}
</t>
<t tx="leo.20191210204028.35">Actuator3D.prototype.showServoAngle = function(_s, _e, _group){
    if(!this.actuator.isServo) 	this.angleMaterial.opacity = 0;
    else 						this.angleMaterial.opacity = 1;

    if( (this.startAngle == - _s &amp;&amp; this.endAngle == - _e) || (this.startAngle == - _e &amp;&amp; this.endAngle == - _s) ) return;

    if(_s&lt;_e){
        this.startAngle = - _s;
        this.endAngle 	= - _e;

    }else{
        this.startAngle = - _e;
        this.endAngle 	= - _s;
    }

    _group.remove( this.angleObject );

    this.angleCurve = new THREE.EllipseCurve(
        0,  0,        // ax, aY
        Actuator3D.ACTUATOR_SIZE+10, Actuator3D.ACTUATOR_SIZE+10,           // xRadius, yRadius
        this.startAngle, this.endAngle,  	  // aStartAngle, aEndAngle
        true,         // aClockwise
        0             // aRotation
    );

    this.anglePath 		= new THREE.Path( this.angleCurve.getPoints( Actuator3D.SEGMENT ) );
    this.angleGeometry 	= this.anglePath.createPointsGeometry( Actuator3D.SEGMENT );
    this.angleMaterial 	= new THREE.LineBasicMaterial( { color: ACTUATOR_COLOR, 	side: THREE.DoubleSide, 	linewidth: Actuator3D.LINE_WIDTH, transparent: true, opacity:0 } );
    this.angleObject = new THREE.Line( this.angleGeometry, this.angleMaterial );

    if(!this.actuator.isServo) 	this.angleMaterial.opacity = 0;
    else 						this.angleMaterial.opacity = 1;

    _group.add( this.angleObject );
}


// Trajectory
</t>
<t tx="leo.20191210204028.36">function Trajectory3D(_t, _v, _x, _y, _group){
    this.trajectory = _t;

    this.trjMaterial 	= new THREE.LineBasicMaterial( { color: TRAJECTORY_COLOR , side: THREE.DoubleSide, linewidth: Trajectory3D.LINE_WIDTH } );
    this.trjGeometry	= new THREE.BufferGeometry();
    this.trjGeometry.addAttribute( 'position', new THREE.BufferAttribute( _v, 3 ).setDynamic( true ) );
    this.trjObject		= new THREE.Line( this.trjGeometry, this.trjMaterial );

    _group.add( this.trjObject );

    this.dotGeometry 		= new THREE.CircleGeometry( Trajectory3D.DOT_SIZE, Trajectory3D.SEGMENT );
    this.dotGeometry.vertices.shift();
    this.dotMaterial 		= new THREE.MeshBasicMaterial( { color: TRAJECTORY_COLOR, side: THREE.DoubleSide} );
    this.dotObject			= new THREE.Mesh( this.dotGeometry, this.dotMaterial );
    this.dotObject.position.set( _x, _y, Trajectory3D.Z_POS );

    _group.add( this.dotObject );

    this.setDrawRange(0,0);
}
Trajectory3D.DOT_SIZE		= 6;
Trajectory3D.Z_POS 			= 0.3;
Trajectory3D.LINE_WIDTH		= 2;
Trajectory3D.SEGMENT		= 32;

</t>
<t tx="leo.20191210204028.37">Trajectory3D.prototype.remove = function(_group){
    _group.remove( this.trjObject );
    _group.remove( this.dotObject );
}
</t>
<t tx="leo.20191210204028.38">Trajectory3D.prototype.findFromElement = function(_t){
    if(this.trajectory == _t) 	return true;
    else 						return false;
}
</t>
<t tx="leo.20191210204028.39">Trajectory3D.prototype.setVertices = function(_vertices){
    this.trjGeometry.attributes.position.array = _vertices;
    this.trjGeometry.attributes.position.needsUpdate = true;
}
</t>
<t tx="leo.20191210204028.4">Link3D.prototype.setVertices = function(_vertices, _vertices3D){
    if(JSON.stringify(_vertices) == JSON.stringify(this.prevVertex)) return; // fixed

    this.linkGeometry.attributes.position.array = _vertices;
    this.linkGeometry.attributes.position.needsUpdate = true;
    this.prevVertex = _vertices;



    if(Link3D.SHOW_3D){
        this.createShape(_vertices3D);
    }else{
        this.linkObject.remove(this.group3D);
    }
}
</t>
<t tx="leo.20191210204028.40">Trajectory3D.prototype.setPosition = function(_x, _y){
    this.dotObject.position.set( _x, _y, Trajectory3D.Z_POS );
}
</t>
<t tx="leo.20191210204028.41">Trajectory3D.prototype.setColor = function(_color){
    this.trjMaterial.color.setHex( _color );
    this.dotMaterial.color.setHex( _color );
}
</t>
<t tx="leo.20191210204028.42">Trajectory3D.prototype.setDrawRange = function(_s, _e){
    this.trjGeometry.setDrawRange(_s, _e);
}


// Load
</t>
<t tx="leo.20191210204028.43">function Load3D(_l, _x, _y, _group, _material){
    this.load 			= _l;

    //fy
    this.loadYGeometry 	= new THREE.PlaneGeometry( Load3D.LOAD_SIZE, Load3D.LOAD_SIZE );
    this.loadYObject 		= new THREE.Mesh( this.loadYGeometry, _material );

    this.loadYObject.overdraw = true;
    if(this.load.getLoadY()&lt;0){
        this.loadYObject.position.set( _x, _y-40, Load3D.Z_POS );
    }else{
        this.loadYObject.rotateZ(Math.PI);
        this.loadYObject.position.set( _x, _y+40, Load3D.Z_POS );
    }
    _group.add( this.loadYObject );

    // text
    this.canvasY 		= document.createElement('canvas');
    this.canvasY.width 	= 256;
    this.canvasY.height 	= 256;

    this.contextY 		= this.canvasY.getContext('2d');
    this.contextY.clearRect( 0, 0, this.canvasY.width, this.canvasY.height );
    this.contextY.font 		= "24px Nunito";
    this.contextY.fillStyle 	= "rgba(0,0,0,0.9)";
    this.contextY.textAlign = "center";
    this.contextY.fillText(this.load.getLoadY() + "N", 128, 128);

    this.textureY 		= new THREE.Texture(this.canvasY);
    this.textureY.needsUpdate = true;

    this.textYMaterial   = new THREE.MeshBasicMaterial( {map: this.textureY, side:THREE.DoubleSide , transparent: true, depthWrite: false, depthTest: false} );
    this.textYGeometry	= new THREE.PlaneGeometry( this.canvasY.width, this.canvasY.height );
    this.textYObject		= new THREE.Mesh( this.textYGeometry, this.textYMaterial );

    if(this.load.getLoadY()&lt;0){
        this.textYObject.position.set( _x, _y-110, Load3D.Z_POS );
    }else{
        this.textYObject.position.set( _x, _y+100, Load3D.Z_POS );
    }


    _group.add( this.textYObject );

    //fx
    this.loadXGeometry 	= new THREE.PlaneGeometry( Load3D.LOAD_SIZE, Load3D.LOAD_SIZE );
    this.loadXObject 		= new THREE.Mesh( this.loadXGeometry, _material );

    this.loadXObject.overdraw = true;

    if(this.load.getLoadX()&gt;=0){
        this.loadXObject.position.set( _x+40, _y, Load3D.Z_POS );
        this.loadXObject.rotateZ(Math.PI/2);
    }else{
        this.loadXObject.position.set( _x-40, _y, Load3D.Z_POS );
        this.loadXObject.rotateZ(-Math.PI/2);
    }

    _group.add( this.loadXObject );

    // text
    this.canvasX 		= document.createElement('canvas');
    this.canvasX.width 	= 256;
    this.canvasX.height 	= 256;

    this.contextX 		= this.canvasX.getContext('2d');
    this.contextX.clearRect( 0, 0, this.canvasX.width, this.canvasX.height );
    this.contextX.font 		= "24px Nunito";
    this.contextX.fillStyle 	= "rgba(0,0,0,0.9)";
    this.contextX.textAlign = "center";
    this.contextX.fillText(this.load.getLoadX() + "N", 128, 128);

    this.textureX 		= new THREE.Texture(this.canvasX);
    this.textureX.needsUpdate = true;

    this.textXMaterial   = new THREE.MeshBasicMaterial( {map: this.textureX, side:THREE.DoubleSide , transparent: true, depthWrite: false, depthTest: false} );
    this.textXGeometry	= new THREE.PlaneGeometry( this.canvasX.width, this.canvasX.height );
    this.textXObject		= new THREE.Mesh( this.textXGeometry, this.textXMaterial );

    if(this.load.getLoadX()&gt;=0){
        this.textXObject.position.set( _x+120, _y-10, Load3D.Z_POS );
    }else{
        this.textXObject.position.set( _x-120, _y-10, Load3D.Z_POS );
    }
    _group.add( this.textXObject );
}

Load3D.LOAD_SIZE	= 80;
Load3D.Z_POS 			= -0.1;

</t>
<t tx="leo.20191210204028.44">Load3D.prototype.remove = function(_group){
    _group.remove( this.loadYObject );
    _group.remove( this.textYObject );
    _group.remove( this.loadXObject );
    _group.remove( this.textXObject );
}
</t>
<t tx="leo.20191210204028.45">Load3D.prototype.findFromElement = function(_l){
    if(this.load == _l) 	return true;
    else 						return false;
}
</t>
<t tx="leo.20191210204028.46">Load3D.prototype.setPosition = function(_x, _y){
    //fy
    if(this.load.getLoadY()&lt;0){
        this.loadYObject.visible = true;
        this.loadYObject.position.set( _x, _y-40, Load3D.Z_POS );
        this.textYObject.position.set( _x, _y-110, Load3D.Z_POS );
    }
    else if(this.load.getLoadY()==0){
        this.loadYObject.visible = false;
        this.textYObject.position.set( _x, _y+10, Load3D.Z_POS );
    }
    else{
        this.loadYObject.visible = true;
        this.loadYObject.position.set( _x, _y+40, Load3D.Z_POS );
        this.textYObject.position.set( _x, _y+100, Load3D.Z_POS );
    }

    //fx
    if(this.load.getLoadX()&gt;0){
        this.loadXObject.visible = true;
        this.loadXObject.position.set( _x+40, _y, Load3D.Z_POS );
        this.textXObject.position.set( _x+120, _y-10, Load3D.Z_POS );
    }
    else if(this.load.getLoadX()==0){
        this.loadXObject.visible = false;
        this.textXObject.position.set( _x+20, _y-10, Load3D.Z_POS );
    }
    else{
        this.loadXObject.visible = true;
        this.loadXObject.position.set( _x-40, _y, Load3D.Z_POS );
        this.textXObject.position.set( _x-120, _y-10, Load3D.Z_POS );
    }
}
</t>
<t tx="leo.20191210204028.5">Link3D.prototype.setColor = function(_color){
    this.linkMaterial.color.setHex( _color );
}

// for 3D
Link3D.HEIGHT			= 30;
Link3D.EXTRUDE_SET		= {
                            steps: 1,
                            amount: Link3D.HEIGHT,
                            bevelEnabled: false
                        };
Link3D.HOLE_SIZE		= 20;

</t>
<t tx="leo.20191210204028.6">Link3D.prototype.createShape = function(_vertices){
    this.linkObject.remove(this.group3D);
    this.group3D.remove(this.link3DObject);
    this.group3D.remove(this.link3DHoles);

    this.shape = new THREE.Shape();
    this.shape.moveTo(_vertices[0], _vertices[1]);
    for(var i=0; i&lt;_vertices.length; i+=3){
        this.shape.lineTo(_vertices[i], _vertices[i+1]);
    }
    this.shape.lineTo(_vertices[0], _vertices[1]);

    this.link3DGeometry = new THREE.ExtrudeGeometry( this.shape, Link3D.EXTRUDE_SET );
    this.link3DObject = new THREE.Mesh( this.link3DGeometry, this.link3DMaterial ) ;
    var link3Dbsp = new ThreeBSP( this.link3DGeometry );

    this.link3DHoles = new THREE.Object3D();
    // creating hole
    for(var pi in this.link.getPointList().array){
        var p = this.link.getPointList().get(pi);
        var coordinate = this.link.getGlobalPosition(p);

        var holeGeometry = new THREE.CylinderGeometry( Link3D.HOLE_SIZE, Link3D.HOLE_SIZE, Link3D.HEIGHT+1, 16 );
        holeGeometry.rotateX( -Math.PI/2 );
        holeGeometry.translate(coordinate.getX(), coordinate.getY(), Link3D.HEIGHT/2);

        var holeMesh = new THREE.Mesh( holeGeometry, this.transparentMaterial );

        if(!isPlaying) link3Dbsp = link3Dbsp.subtract( new ThreeBSP( holeMesh ) )
        //else this.link3DHoles.add(holeMesh); // for check
    }
    if(!isPlaying) this.link3DObject = link3Dbsp.toMesh( this.link3DMaterial );
    //else this.group3D.add(this.link3DHoles);
    this.group3D.add(this.link3DObject);

    this.linkObject.add( this.group3D );

    this.updateStack();
}
</t>
<t tx="leo.20191210204028.7">Link3D.prototype.setStack = function(_n){
    this.link.stack = _n;
    this.updateStack();
}
</t>
<t tx="leo.20191210204028.8">Link3D.prototype.updateStack = function(){
    this.stack = this.link.stack;
    this.group3D.position.z = this.stack * Link3D.HEIGHT;
}

// Point
</t>
<t tx="leo.20191210204028.9">function Point3D(_p, _x, _y, _group){
    this.point 				= _p;

    // for viewMode
    if(viewMode == 0)		Point3D.POINT_SIZE = 10;
    else if(viewMode == 1)	Point3D.POINT_SIZE = (msketchSettings.holeDiameter/SCALE_TRANS)/2;

    this.fillGeometry 		= new THREE.CircleGeometry( Point3D.POINT_SIZE - 0.1, Point3D.SEGMENT );
    //this.fillGeometry.vertices.shift();
    this.fillMaterial 		= new THREE.MeshBasicMaterial( { color: WHITE_COLOR, side: THREE.DoubleSide, transparent: true} );
    this.fillMaterial.opacity = 0;
    this.fillObject			= new THREE.Mesh( this.fillGeometry, this.fillMaterial );
    this.fillObject.position.set( _x, _y, Point3D.Z_POS );

    this.lineGeometry 		= new THREE.CircleGeometry( Point3D.POINT_SIZE, Point3D.SEGMENT );
    this.lineGeometry.vertices.shift();
    this.lineMaterial 		= new THREE.LineBasicMaterial( { color: NORMAL_COLOR, side: THREE.DoubleSide, linewidth: Point3D.LINE_WIDTH } );
    this.lineObject			= new THREE.Line( this.lineGeometry, this.lineMaterial );
    this.lineObject.position.set( _x, _y, Point3D.Z_POS );

    _group.add( this.lineObject );
    _group.add( this.fillObject );
}

Point3D.Z_POS 			= 0.1;
Point3D.POINT_SIZE		= 10;
Point3D.SEGMENT			= 32;
Point3D.LINE_WIDTH		= 2;

</t>
<t tx="leo.20191210204042.1">// =============================================================================
// 						Initializing Three.js and HTML Elements
// =============================================================================
var container, camera, scene, renderer, raycaster;
var canvasWidth, canvasHeight;

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204048.1">function init(){
	canvasWidth = $('#threejs_canvas').innerWidth();
	canvasHeight = $('#threejs_canvas').innerHeight();
	//scene and camera
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera( 1, canvasWidth/canvasHeight, 10000, 100000000 );
	camera.position.set( 0, 0, 100000 );
	scene.add( camera );

	//scene basic setup
	scene.add( new THREE.AmbientLight( WHITE_COLOR ) );
	var light = new THREE.PointLight( WHITE_COLOR, 0.5);
	light.position.set( 0, 1000, 1000 );
	/*
	light.castShadow = true;
	light.shadow.camera.near = camera.near;
	light.shadow.camera.far = camera.far;
	light.shadow.camera.fov = 70;
	light.shadow.mapSize.width = 1024;
	light.shadow.mapSize.height = 1024;
	*/
	scene.add( light );

	var globalAxis = new THREE.AxisHelper();
	globalAxis.position.set( 0, 0, 0 );
	globalAxis.scale.set(200, 200, 200);
	scene.add( globalAxis );

	//renderer
	//IE Competible


	if ( webglAvailable() ) {
		renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
		renderer.shadowMap.enabled = true;
		console.log("WebGL Renderer Enabled");
	} else {
		renderer = new THREE.CanvasRenderer();
		console.log("Canvas Renderer Enabled");
	}


	//renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setClearColor( BACKGROUND_COLOR );
	renderer.setSize( canvasWidth, canvasHeight );
	document.getElementById("threejs_canvas").appendChild( renderer.domElement );


	// Controls
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.rotateSpeed = 0.8;
	controls.zoomSpeed = 1.2;
	controls.panSpeed = 0.8;
	controls.enableDamping = true;
	controls.dampingFactor = 0.75;

	transformControl = new THREE.TransformControls( camera, renderer.domElement );
	transformControl.addEventListener( 'change', render );
	transformControl.setSize(0.008);
	transformControl.setRotationSnap(Math.PI/12);

	scene.add( transformControl );

	raycaster = new THREE.Raycaster();
	mouse = new THREE.Vector3(0,0,0);

	// Event Listener
	window.addEventListener( 'resize', onWindowResize, false );
	renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
	renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
	renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
	renderer.domElement.addEventListener( 'mouseout', onDocumentMouseOut, false );
	renderer.domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );
	renderer.domElement.addEventListener( 'touchstart', onDocumentTouchDown, false );
	renderer.domElement.addEventListener( 'touchend', onDocumentTouchUp, false );

	transformControl.addEventListener( 'change', onUpdatePlanePanel, false );
	window.addEventListener( 'keydown', onDocumentKeyDown, false);
	window.addEventListener( 'keyup', onDocumentKeyUp, false);

}

</t>
<t tx="leo.20191210204048.2">function webglAvailable() {
	try {
		var canvas = document.createElement( 'canvas' );
		return !!( window.WebGLRenderingContext &amp;&amp; (
			canvas.getContext( 'webgl' ) ||
			canvas.getContext( 'experimental-webgl' ) )
		);
	} catch ( e ) {
		return false;
	}
}
</t>
<t tx="leo.20191210204116.1"></t>
<t tx="leo.20191210204124.1">// =============================================================================
// 									Animate (Loop)
// =============================================================================

var mouse, intersects;
var mouseState 			= 0;
var currentInterface;
var mouseX, mouseY, lastX, lastY;

var STATE_NULL = 0;
var STATE_DOWN = 1;
var STATE_DOWN_AND_MOVE = 2;
var STATE_DOWN_AND_OUT = 3;

var ctrlDown = false;

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204148.1">function getMousePoints(_event, _target){
	if(!isTouchScreen){
		mouse.x = ( _event.offsetX / canvasWidth ) * 2 - 1;
		mouse.y = - ( _event.offsetY / canvasHeight ) * 2 + 1;
	}
	else if ( _event.touches != null ){
		isTouchScreen = true;
		if ( _event.touches.length === 1 ) {
			var tgOffset = _event.target.getBoundingClientRect();
			mouse.x = ( (_event.targetTouches[0].clientX -  tgOffset.left) / canvasWidth ) * 2 - 1;
			mouse.y = -( (_event.targetTouches[0].clientY -  tgOffset.top) / canvasHeight ) * 2 + 1;
		}
	}

	raycaster.setFromCamera( mouse, camera );
	intersects = raycaster.intersectObject( _target, true );

	var mVector;
	if (intersects.length &gt; 0) {
		mVector = new THREE.Vector3().copy( intersects[ 0 ].point );
        intersects[ 0 ].object.worldToLocal( mVector );
        mouseX = mVector.x;
		mouseY = mVector.y;
	}

}

function getTargetPlane(){
	var assemblySelection = raycaster.intersectObject( scene, true );
	if(assemblySelection.length&gt;0){
		for(var i=0; i&lt;assemblySelection.length; i++){
			for(var j=0; j&lt;AssemblyGroupList.length; j++){
				if(assemblySelection[i].object == AssemblyGroupList[j].selectCube){
					return j;
				}
			}
		}
	}
	return -1;
}

function onDocumentMouseMove( event ) {
	event.preventDefault();

	getMousePoints(event, currentMousePlane);

	if (currentInterface!=null &amp;&amp; mouseX!=lastX &amp;&amp; mouseY!=lastY) {
	    switch(mouseState) {
	    case STATE_NULL:
	      currentInterface.mouseMove(mouseX, mouseY);
	      break;
	    case STATE_DOWN:
	      currentInterface.mouseDownAndMoveFirst(mouseX, mouseY);
	      currentInterface.mouseDownAndMove(mouseX, mouseY);
	      mouseState=STATE_DOWN_AND_MOVE;
	      break;
	    case STATE_DOWN_AND_MOVE:
	      currentInterface.mouseDownAndMove(mouseX, mouseY);
	      break;
      	case STATE_DOWN_AND_OUT:
	      currentInterface.mouseDownAndMove(mouseX, mouseY);
	      break;
	    }

    }

	controls.enabled = true;

</t>
<t tx="leo.20191210204148.10">function onDocumentKeyDown( event ){
	ctrlDown = false;
	if (event.ctrlKey) ctrlDown = true;
	if (event.ctrlKey &amp;&amp; event.keyCode == 90){
		undo();
	}
	if (event.ctrlKey &amp;&amp; event.keyCode == 89){
		redo();
	}

    //var ctrlKey = 17, vKey = 86, cKey = 67;
}

</t>
<t tx="leo.20191210204148.11">function onDocumentKeyUp( event ){
	ctrlDown = false;

	checkHistory();

	if(event.keyCode == 32){
		//interfaceSelect(TOOL_NAV);
	}
}

</t>
<t tx="leo.20191210204148.12">function onWindowResize() {
	canvasWidth = $('#threejs_canvas').innerWidth();
	canvasHeight = $('#threejs_canvas').innerHeight();

	windowHalfX = canvasWidth / 2;
	windowHalfY = canvasHeight / 2;

	camera.aspect = canvasWidth / canvasHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( canvasWidth, canvasHeight );
}

</t>
<t tx="leo.20191210204148.13">function onUpdatePlanePanel(){
	getPlaneInfoToPlanePanel();
}
</t>
<t tx="leo.20191210204148.2">	if(event.type == "mousemove") {
		isTouchScreen = false;
		controls.zoomSpeed = 1.2;

	}
	lastX = mouseX;
</t>
<t tx="leo.20191210204148.3">    lastY = mouseY;

}

</t>
<t tx="leo.20191210204148.4">function onDocumentMouseDown( event ) {
	event.preventDefault();

	getMousePoints(event, currentMousePlane);

	if(event.which!=1 &amp;&amp; !isTouchScreen) return;

	if (currentInterface!=null &amp;&amp; mouseState!=STATE_DOWN_AND_OUT) {
		currentInterface.mouseDown(mouseX, mouseY);
		mouseState=STATE_DOWN;
	}

}

</t>
<t tx="leo.20191210204148.5">function onDocumentMouseUp( event ) {
	event.preventDefault();

	getMousePoints(event, currentMousePlane);

	if (currentInterface!=null) {
	    switch(mouseState) {
	    case STATE_NULL:
	      currentInterface.mouseDownAndUp(mouseX, mouseY);
	      break;
	    case STATE_DOWN:
	      currentInterface.mouseDownAndUp(mouseX, mouseY);
	      currentInterface.mouseMove(mouseX, mouseY);
	      break;
	    case STATE_DOWN_AND_MOVE:
	      currentInterface.mouseMoveAndUp(mouseX, mouseY);
	      currentInterface.mouseMove(mouseX, mouseY);
	      break;
	    }
	    currentAssemblyGroup.onStart();
	    currentAssemblyGroup.calculateAssembly();
	}
	mouseState=STATE_NULL;

	if(toolState==TOOL_PSEL){
		if(getTargetPlane()!=-1){
			selectAssembly(getTargetPlane());
		}
	}

	checkHistory();
}

</t>
<t tx="leo.20191210204148.6">function onDocumentMouseOut( event ) {
	event.preventDefault();

	getMousePoints(event, currentMousePlane);

	if(mouseState == STATE_DOWN_AND_MOVE &amp;&amp; event.which == 1){
		mouseState=STATE_DOWN_AND_OUT;
	}
	controls.enabled = false;
}

// touch events
</t>
<t tx="leo.20191210204148.7">function onDocumentTouchDown( event ){
	event.preventDefault();
	isTouchScreen = true;
	controls.zoomSpeed = 0.3;
	onDocumentMouseMove(event);
	onDocumentMouseDown(event);
}
</t>
<t tx="leo.20191210204148.8">function onDocumentTouchUp( event ){
	event.preventDefault();
	onDocumentMouseMove(event);
	onDocumentMouseUp(event);
	hoverPoint = new Point2D;
	hoverLink = null;
}
</t>
<t tx="leo.20191210204148.9">function onDocumentTouchMove( event ){
	event.preventDefault();
	onDocumentMouseMove(event);

}



</t>
<t tx="leo.20191210204157.1">// =============================================================================
// 							Tool Select and Execute Script
// =============================================================================

//* ===== Tool function variables =====
var toolState 			= -1;
var TOOL_RUN 			= 1,
	TOOL_NAV 			= 2,

	TOOL_LINK 			= 3,
	TOOL_JA 			= 4,
	TOOL_MARK 			= 5,
	TOOL_MOVE 			= 6,
	TOOL_REMOVE 		= 7,

	TOOL_PCAM 			= 8,
	TOOL_PADD 			= 9,
	TOOL_PREMOVE 		= 10,
	TOOL_PSEL 			= 11,
	TOOL_PTRANS 		= 12,
	TOOL_PROT 			= 13,

	TOOL_SLIDER			= 14;
	TOOL_PCOPY 			= 15;

	// Menubar
	TOOL_NEWFILE 		= 21,
	TOOL_SAVE	 		= 22,
	TOOL_OPEN 			= 23,
	TOOL_EXPORT 		= 24,
	TOOL_IMPORT 		= 25,
	TOOL_DRAWING 		= 26,
	TOOL_EXAMPLE 		= 27,
	TOOL_MANUAL 		= 28,

	TOOL_CAMEO_DRAWING 	= 29,
	TOOL_EDISON_XML 	= 30;

	// Panel and External Functions
	PANEL_MOVE 			= 51;
	TOOL_OPT 			= 40;
	TOOL_PPATTERN		= 41;
	TOOL_PMOTOR			= 42;
	TOOL_PANALYSIS		= 43;
	TOOL_FAB			= 44;

	TOOL_ADDLOAD		= 61;
	TOOL_EDITLOAD		= 62;
	TOOL_REMOVELOAD		= 63;

var	PANEL_MOVE_INDEX	= 1,
	PANEL_PLANE_INDEX 	= 2;



var prevTool = -1;


@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204203.1">function interfaceSelect(_selected){
	switch(_selected){
		// Header Toolbar
		case TOOL_RUN:
			isPlaying=!isPlaying;
			if (isPlaying) {
				toolState = -1;
				setTool(toolState);
				prevMillis = new Date().getTime();
				globalAngle = 0;

				for(var i=0; i&lt;AssemblyGroupList.length; i++){
					AssemblyGroupList[i].load();
					AssemblyGroupList[i].savePositions();
					AssemblyGroupList[i].onStart();
					AssemblyGroupList[i].flushTrajectories();
					AssemblyGroupList[i].hideCube();
					AssemblyGroupList[i].setOpacity(1);
				}

				currentAssemblyGroup.hidePlane();
				currentAssemblyGroup.setOpacity(1);
			}
			else{
				for(var i=0; i&lt;AssemblyGroupList.length; i++){
					AssemblyGroupList[i].restorePositions()
					AssemblyGroupList[i].onEnd();
					AssemblyGroupList[i].flushTrajectories();
					AssemblyGroupList[i].initTrajectories();
					AssemblyGroupList[i].showCube();
					AssemblyGroupList[i].setOpacity(DISABLED_PLANE_OPA);
				}

				currentAssemblyGroup.showPlane();
				if(isAnalysisOn) isAnalysisOn=false;
				try360forAssemblies();
			}
			break;
		case TOOL_NAV:
			isControlable = !isControlable;
			prevControlable = isControlable;
			if(isControlable){
				prevTool=toolState;
				if(toolState!=TOOL_PTRANS &amp;&amp; toolState!=TOOL_PROT &amp;&amp; toolState!=TOOL_PSEL){
					toolState = -1;
					setTool(toolState);
				}
			}else{
				if(prevTool == TOOL_LINK || prevTool == TOOL_JA || prevTool == TOOL_MARK || prevTool == TOOL_MOVE || prevTool == TOOL_REMOVE ){
					toolState=prevTool;
					setTool(toolState);
				}
			}
			break;

		case TOOL_LINK:
			if(toolState!=TOOL_LINK) toolState = TOOL_LINK;
			else if(toolState==TOOL_LINK) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_JA:
			if(toolState!=TOOL_JA) toolState = TOOL_JA;
			else if(toolState==TOOL_JA) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_SLIDER:
			if(toolState!=TOOL_SLIDER) toolState = TOOL_SLIDER;
			else if(toolState==TOOL_SLIDER) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_MARK:
			if(toolState!=TOOL_MARK) toolState = TOOL_MARK;
			else if(toolState==TOOL_MARK) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_MOVE:
			if(toolState!=TOOL_MOVE) toolState = TOOL_MOVE;
			else if(toolState==TOOL_MOVE) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_REMOVE:
			if(toolState!=TOOL_REMOVE) toolState = TOOL_REMOVE;
			else if(toolState==TOOL_REMOVE) toolState = -1;
			setTool(toolState);
			break;

		case TOOL_PCAM:
			var rX = currentAssemblyGroup.group.rotation.x;
			var rY = currentAssemblyGroup.group.rotation.y;
			var rZ = currentAssemblyGroup.group.rotation.z;

			camera.position.x = 100000*Math.sin(rY);
			camera.position.y = 100000*Math.sin(rX)*Math.cos(rY)*(-1);
			camera.position.z = 100000*Math.cos(rX)*Math.cos(rY);

			_target = new THREE.Vector3(currentAssemblyGroup.group.position.x,currentAssemblyGroup.group.position.y,currentAssemblyGroup.group.position.z);

			controls.target.set(Number(_target.x), Number(_target.y), Number(_target.z));
			camera.lookAt( currentAssemblyGroup.group.position );
			break;
		case TOOL_PADD:
			addAssemblyGroup(currentAssemblyGroup.group.position.z+100);
			currentAssemblyGroup.init();
			selectAssembly(AssemblyGroupList.length-1);
			checkHistory();
			break;
		case TOOL_PREMOVE:
			removeAssemblyGroup(findCurrentAssemblyNum());
			checkHistory();
			break;
		case TOOL_PSEL:
			if(toolState!=TOOL_PSEL) toolState = TOOL_PSEL;
			else if(toolState==TOOL_PSEL) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_PTRANS:
			if(toolState!=TOOL_PTRANS) toolState = TOOL_PTRANS;
			else if(toolState==TOOL_PTRANS) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_PROT:
			if(toolState!=TOOL_PROT) toolState = TOOL_PROT;
			else if(toolState==TOOL_PROT) toolState = -1;
			setTool(toolState);
			break;
		case TOOL_PCOPY:
			var _data = getMsketchInfoForPlane();
			loadMsketchInfoForPlane(JSON.parse(_data).sketch, true);

			break;


		// Manubar
		case TOOL_NEWFILE:
			if(isPlaying)	interfaceSelect(TOOL_RUN);
			makeNewFile();
			//showSnackBar("새 파일 생성됨.", "New File was created.");
			showMessage("New File was created.")
			closeDrawer();
			break;
		case TOOL_SAVE:
			break;
		case TOOL_OPEN:
			break;
		case TOOL_EXPORT:
			if(isPlaying)	interfaceSelect(TOOL_RUN);

			var dataOut = getMsketchInfoForPlane();
			saveAsText($('#msketch-titlebar-filename').val()+"_Plane"+findCurrentAssemblyNum()+".json", dataOut);
			closeDrawer();
			break;
		case TOOL_IMPORT:
			if(isPlaying)	interfaceSelect(TOOL_RUN);

			interfaceSelect(TOOL_PADD);
			loadFromStringData(dataFile, true);
			dataFile=null;
			toggleDrawer();
			break;
		case TOOL_DRAWING:
			exportDrawing();
			closeDrawer();
			break;
		case TOOL_CAMEO_DRAWING:
			exportCameoDrawing();
			toggleDrawer();
			break;
		case TOOL_EDISON_XML:
			if(isPlaying)	interfaceSelect(TOOL_RUN);
			exportEdisonXML();
			toggleDrawer();
			break;
		case TOOL_EXAMPLE:
			if(isPlaying)	interfaceSelect(TOOL_RUN);
			openFileFromStringData(dataFile, true);
			dataFile=null;
			toggleDrawer();
			break;
		case TOOL_MANUAL:
			window.open(MANUAL_URL, '_blank');
			toggleDrawer();
			break;

		// External Tools
		case TOOL_ADDLOAD:
			if(toolState!=TOOL_ADDLOAD) toolState = TOOL_ADDLOAD;
			else if(toolState==TOOL_ADDLOAD) toolState = -1;
			setTool(toolState);
			break;

		case TOOL_EDITLOAD:
			if(toolState!=TOOL_EDITLOAD) toolState = TOOL_EDITLOAD;
			else if(toolState==TOOL_EDITLOAD) toolState = -1;
			setTool(toolState);
			break;

		case TOOL_REMOVELOAD:
			if(toolState!=TOOL_REMOVELOAD) toolState = TOOL_REMOVELOAD;
			else if(toolState==TOOL_REMOVELOAD) toolState = -1;
			setTool(toolState);
			break;



	}

	checkToolSet();
	//checkPanelSet();

	//* ===== Check orbit control =====
	if (isControlable) {
		//controls.enabled = true;
		controls.enableRotate = true;
	} else {
		//controls.enabled = false;
		controls.enableRotate = false;
	}



	//* ===== Plane Selection =====
	if(toolState==TOOL_PSEL){
		for(var i=0; i&lt;AssemblyGroupList.length; i++){
			AssemblyGroupList[i].showCube();
		}
	}
	else{
		for(var i=0; i&lt;AssemblyGroupList.length; i++){
			AssemblyGroupList[i].hideCube();
		}
	}

}



</t>
<t tx="leo.20191210204203.2">function setTool(_tool){
	var _dettach = true;
	var _allowNav = true;
	switch(_tool){
		case -1:
			currentInterface = null;
			isControlable = prevControlable;
			break;
		case TOOL_LINK:
			currentInterface = new LinkInterface();
			_allowNav = false;
			break;
		case TOOL_JA:
			currentInterface = new JAInterface();
			_allowNav = false;
			break;
		case TOOL_SLIDER:
			currentInterface = new SliderInterface();
			_allowNav = false;
			break;
		case TOOL_MARK:
			currentInterface = new MarkInterface();
			_allowNav = false;
			break;
		case TOOL_MOVE:
			currentInterface = new MoveInterface();
			_allowNav = false;
			break;
		case TOOL_REMOVE:
			currentInterface = new RemoveInterface();
			_allowNav = false;
			break;
		case TOOL_PTRANS:
			transformControl.attach( currentAssemblyGroup.group );
			transformControl.setMode( "translate" );
			currentInterface = null;
			_dettach=false;
			break;
		case TOOL_PROT:
			transformControl.attach( currentAssemblyGroup.group );
			transformControl.setMode( "rotate" );
			currentInterface = null;
			_dettach=false;
			break;
		case TOOL_PSEL:
			currentInterface = null;
			break;
		case TOOL_OPT:
			currentInterface = new OptInterface();
			_allowNav = false;
			break;


		// External Interface
		case TOOL_ADDLOAD:
			currentInterface = new AddLoadInterface();
			_allowNav = false;
			break;

		case TOOL_EDITLOAD:
			currentInterface = new EditLoadInterface();
			_allowNav = false;
			break;

		case TOOL_REMOVELOAD:
			currentInterface = new RemoveLoadInterface();
			_allowNav = false;
			break;
	}

	if(_allowNav == false &amp;&amp; isControlable){
		isControlable = false;
	}


	if(_dettach){
		transformControl.detach( currentAssemblyGroup.group );
	}
	if(toolState!=TOOL_OPT &amp;&amp; !isPlaying){
		//flushAllTargetTrj();
	}
}


/* added for drawer */
</t>
<t tx="leo.20191210204203.3">$('#msketch_drawer_open').click(function(){
	if( $('#msketch_drawer_open').hasClass('active') ){
		$('#msketch_drawer').css('left', -240);
	}else{
		$('#msketch_drawer').css('left', 0);
	}

	$('#msketch_drawer_open').toggleClass('active');
});

function closeDrawer(){
	if( $('#msketch_drawer_open').hasClass('active') ){
		$('#msketch_drawer').css('left', -240);
	}
	$('#msketch_drawer_open').removeClass('active');
}




function checkToolSet() {
	if(isPlaying)		$('#btn_play').addClass('active');
	else 				$('#btn_play').removeClass('active');

	if(isControlable)	$('#btn_nav').addClass('active');
	else 				$('#btn_nav').removeClass('active');

	if(toolState == TOOL_LINK)		$('#btn_link').addClass('active');
	else 							$('#btn_link').removeClass('active');
	if(toolState == TOOL_JA)		$('#btn_ja').addClass('active');
	else 							$('#btn_ja').removeClass('active');
	if(toolState == TOOL_SLIDER)	$('#btn_slider').addClass('active');
	else 							$('#btn_slider').removeClass('active');
	if(toolState == TOOL_MARK)		$('#btn_mark').addClass('active');
	else 							$('#btn_mark').removeClass('active');
	if(toolState == TOOL_MOVE)		$('#btn_move').addClass('active');
	else 							$('#btn_move').removeClass('active');
	if(toolState == TOOL_REMOVE)	$('#btn_remove').addClass('active');
	else 							$('#btn_remove').removeClass('active');
	if(toolState == TOOL_PSEL)		$('#btn_psel').addClass('active');
	else 							$('#btn_psel').removeClass('active');
	if(toolState == TOOL_PTRANS)	$('#btn_ptrans').addClass('active');
	else 							$('#btn_ptrans').removeClass('active');
	if(toolState == TOOL_PROT)		$('#btn_prot').addClass('active');
	else 							$('#btn_prot').removeClass('active');
	if(toolState == TOOL_OPT){
		$('#panel_opt_draw').addClass('active');
		// for drawing derised path of linkage generation function (yw_edited)
		$('#panel_gen_draw').addClass('active');
		$('#panel_opt_run').removeClass('disableClick');
		$('#panel_opt_stop').removeClass('disableClick');
		checkBaseTrj(true);
	}else{
		$('#panel_opt_draw').removeClass('active');
		// for drawing derised path of linkage generation function (yw_edited)
		$('#panel_gen_draw').removeClass('active');
		$('#panel_opt_run').addClass('disableClick');
		$('#panel_opt_stop').addClass('disableClick');
		checkBaseTrj(false);
	}

	// Load
	if(toolState == TOOL_ADDLOAD)		$('#btn_addload').addClass('active');
	else 								$('#btn_addload').removeClass('active');
	if(toolState == TOOL_EDITLOAD)		$('#btn_editload').addClass('active');
	else 								$('#btn_editload').removeClass('active');
	if(toolState == TOOL_REMOVELOAD)	$('#btn_removeload').addClass('active');
	else 								$('#btn_removeload').removeClass('active');

	if (isPlaying) {
		$('#msketch_toolbar').addClass('disableClick')
    } else {
		$('#msketch_toolbar').removeClass('disableClick');
    }

	if (toolState != TOOL_MOVE) {
</t>
<t tx="leo.20191210204203.4"></t>
<t tx="leo.20191210204203.5">        selectedPoint = null;
        selectedPointTg = null;
        selectedLink = null;
        selectedPointPair = null;
        currentAssemblyGroup.removeSegmentSelected();
    }
}

</t>
<t tx="leo.20191210204203.6">function setViewMode(_index){
	viewMode = _index;
	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		AssemblyGroupList[i].needsUpdate = true;
		AssemblyGroupList[i].load();
	}
}
</t>
<t tx="leo.20191210204211.1">//--------------------
// MouseEvnet Class
//--------------------
// from m.sketch 2.4 java
// updated on 2015.11.02

var hoverPoint = new Point2D;
var hoverLink = null;
var hoverActuator;
var pointedActuator;
var hoverMotorNum     = -1;

var selectedPoint     = null;
var selectedPointTg   = null;
var selectedLink      = null;
var selectedPointPair = null;

var DISTANCE_SNAP = 24;

//--------------------
// Link Class
//--------------------
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204217.1">function LinkInterface(){
  this.associatedPoint = null;
  this.associatedLink = null;
  this.activePoint = null;
  this.activeLink = null;
  this.lastX;
  this.lastY;
}

</t>
<t tx="leo.20191210204217.10">JAInterface.prototype.mouseDown = function(_x, _y){

    if(hoverPoint!=null){
      var targetCC = null;
      for(var ci in currentAssembly.getAllConstraint().array){
        var c = currentAssembly.getAllConstraint().get(ci);
        if(c instanceof CoaxialConstraint){
          var cc = c;
          for(var pi in cc.getAllPoint().array){
            var p = cc.getAllPoint().get(pi);
            if(p==hoverPoint){
              //added to avoid overlap
              var _isExist = false;
              for(var ai in currentAssembly.getAllActuator().array){
                var a = currentAssembly.getAllActuator().get(ai);
                if(a.getCoaxialConstraint() == c){
                  //console.log("OVERLAP");
                  _isExist = true;
                }else{
                  //console.log("NOT");
                }
              }
              if(!_isExist) targetCC = c;
            }
          }
        }
      }

      if(targetCC!=null){
        var ja = new JointActuator(targetCC, targetCC.getLink(0), targetCC.getLink(1));
        currentAssembly.addActuator(ja);
        //updateMotorList(); // update motor list
        //updateMotorInfo();
      }
    }
    currentAssemblyGroup.load();
    try360forAssemblies();
}
JAInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){}
JAInterface.prototype.mouseDownAndMove = function(_x, _y){}
JAInterface.prototype.mouseDownAndUp = function(_x, _y){}
JAInterface.prototype.mouseMoveAndUp = function(_x, _y){}


//--------------------
// Mark Class
//--------------------

</t>
<t tx="leo.20191210204217.11">function MarkInterface() {
  this.activePoint = null;
}

</t>
<t tx="leo.20191210204217.12">MarkInterface.prototype.mouseMove = function(_x, _y){
  hoverPoint = getPointByPosition(_x, _y);
}
</t>
<t tx="leo.20191210204217.13">MarkInterface.prototype.mouseDown = function(_x, _y){
  this.activePoint = hoverPoint;

  if(this.activePoint!=null){
      var duplicateCheck = false;
      for(var i=0; i&lt;currentAssemblyGroup.trajectoryList.length(); i++){
        if(currentAssemblyGroup.trajectoryList.get(i).getPoint() == this.activePoint) {
          currentAssemblyGroup.trajectoryList.remove(currentAssemblyGroup.trajectoryList.get(i));
          duplicateCheck=true;
          currentAssemblyGroup.load();
          //loadTrajectories(trajectoryList);
        }
      }
      if(!duplicateCheck){
        currentAssemblyGroup.newTrajectory(this.activePoint);
        //currentAssemblyGroup.trajectoryList.add(new Trajectory(currentAssembly, this.activePoint));
        currentAssemblyGroup.load();
        //loadTrajectories(trajectoryList);

      }
      this.activePoint=null;
    }

  try360forAssemblies();
}
MarkInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){}
MarkInterface.prototype.mouseDownAndMove = function(_x, _y){}
MarkInterface.prototype.mouseDownAndUp = function(_x, _y){}
</t>
<t tx="leo.20191210204217.14">MarkInterface.prototype.mouseMoveAndUp = function(_x, _y){
  this.activePoint = null;
}


//--------------------
// Move Class
//--------------------
</t>
<t tx="leo.20191210204217.15">function MoveInterface(){
	this.linkToMove;
	this.pointToMove;
	this.activePoint = null;
	this.activeLink = null;
	this.lastX;
	this.lastY;
}

</t>
<t tx="leo.20191210204217.16">MoveInterface.prototype.mouseMove = function(_x, _y){
	hoverPoint = getPointByPosition(_x, _y);

    // for selecting slider
    /*
    if(hoverPoint!=null){
        var _tempLink = currentAssembly.getBelongedLink(hoverPoint);
        if(_tempLink.isSlider){
            if(_tempLink.getPointList().get(0)!=hoverPoint){
                hoverPoint = null;
            }
        }
    }
    */

    currentAssemblyGroup.drawHoverSegment(_x, _y);

}

</t>
<t tx="leo.20191210204217.17">MoveInterface.prototype.mouseDown = function(_x, _y){
	if (hoverPoint!=null) {
  	this.activePoint = hoverPoint;
    this.activeLink  = null;
  }
  var targetLink = getLinkByPosition(_x, _y);
  if(targetLink!=null){
    this.activeLink   = targetLink;
  }

  this.lastX = _x;
  this.lastY = _y;


}

</t>
<t tx="leo.20191210204217.18">MoveInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){
	this.linkToMove  = new ArrayList();
    this.pointToMove = new ArrayList();

    if (this.activePoint!=null) {
      this.linkToMove.add( currentAssembly.getBelongedLink(this.activePoint) );
      this.pointToMove.add(this.activePoint);
    }

    for(var i=0; i&lt;currentAssembly.getAllConstraint().length(); i++){
      if(currentAssembly.getAllConstraint().get(i) instanceof CoaxialConstraint){
        var cc = currentAssembly.getAllConstraint().get(i);

        check_one_cc:
        for(var j=0; j&lt;this.pointToMove.length(); j++){
          for(var p2i in cc.getAllPoint().array){
            var p2 = cc.getAllPoint().get(p2i);

            if(this.pointToMove.get(j)==p2){
              for(var p3i in cc.getAllPoint().array){
                var p3 = cc.getAllPoint().get(p3i);
                var ifContains = false;
                for(var pi in this.pointToMove.array){
                  var p = this.pointToMove.get(pi);
                  if(p==p3) ifContains = true;
                }

                if(!ifContains){
                  this.linkToMove.add(currentAssembly.getBelongedLink(p3));
                  this.pointToMove.add(p3);
                }
              }
              break check_one_cc;
            }
          }
        }
      }
    }
}

</t>
<t tx="leo.20191210204217.19">MoveInterface.prototype.mouseDownAndMove = function(_x, _y){
    var tX, tY;
    if(isScienceBoxSanpOn){
      tX = (_x%SCIENCEBOX_SNAP&lt;SCIENCEBOX_SNAP/2)? _x - (_x%SCIENCEBOX_SNAP) : _x + (SCIENCEBOX_SNAP-_x%SCIENCEBOX_SNAP);
      tY = (_y%SCIENCEBOX_SNAP&lt;SCIENCEBOX_SNAP/2)? _y - (_y%SCIENCEBOX_SNAP) : _y + (SCIENCEBOX_SNAP-_y%SCIENCEBOX_SNAP);
    }
    else{
      tX = _x;
      tY = _y;
    }

    currentAssemblyGroup.updateSegmentHover(new Float32Array(6));
    currentAssemblyGroup.removeSegmentSelected();

    // to find is containing slider
    var targetSliderLink = null;
    for (var i=0; i&lt;this.linkToMove.length(); i++) {
      if(this.linkToMove.get(i).isSlider){
          targetSliderLink = this.linkToMove.get(i);
      }
    }

    if(this.activePoint!=null){
      hoverPoint = getPointByPosition(_x, _y, this.pointToMove);

      // for selecting slider
      /*
      if(hoverPoint!=null){
          var _tempLink = currentAssembly.getBelongedLink(hoverPoint);
          if(_tempLink.isSlider){
              if(_tempLink.getPointList().get(0)!=hoverPoint){
                  hoverPoint = null;
              }
          }
      }
      */

      if(hoverPoint !=null &amp;&amp; targetSliderLink == null){
        for (var i=0; i&lt;this.pointToMove.length(); i++) {
          this.pointToMove.get(i).setLocation( this.linkToMove.get(i).getLocalPosition(currentAssembly.getBelongedLink(hoverPoint).getGlobalPosition(hoverPoint)) );
          this.linkToMove.get(i).redefineVertex();
        }
      }else if(targetSliderLink != null){

          // for slider snap
        var tempSc = targetSliderLink.baseSC;

        var pts = tempSc.getPoints();
        pts = [ tempSc.getLink(tempSc.BASE).getGlobalPosition(pts[0]),
                tempSc.getLink(tempSc.BASE).getGlobalPosition(pts[1]) ];
        var t = MMath.getNearestTfromALine(new Point2D(_x, _y), pts[0], pts[1]);

        t = Math.max(0, Math.min(1, t));

        var sX = (pts[0].getX()*(1-t)+pts[1].getX()*t);
        var sY = (pts[0].getY()*(1-t)+pts[1].getY()*t);

        for (var i=0; i&lt;this.pointToMove.length(); i++) {
            if(targetSliderLink == this.linkToMove.get(i)){
                this.linkToMove.get(i).setOriginPoint( new Point2D(sX, sY) );
                this.linkToMove.get(i).setAngle(tempSc.getLink(tempSc.BASE).getAngle()+tempSc.getAngle());
                this.linkToMove.get(i).redefineVertex();
            }
            else{
                this.pointToMove.get(i).setLocation( this.linkToMove.get(i).getLocalPosition(new Point2D(sX, sY)) );
                this.linkToMove.get(i).redefineVertex();
            }
        }
    }else{
        for (var i=0; i&lt;this.pointToMove.length(); i++) {
          this.pointToMove.get(i).setLocation( this.linkToMove.get(i).getLocalPosition(new Point2D(tX, tY)) );
          this.linkToMove.get(i).redefineVertex();
        }
      }
    } else {
      for (var i=0; i&lt;this.pointToMove.length(); i++) {
        var position = this.linkToMove.get(i).getGlobalPosition(this.pointToMove.get(i));
        position.setLocation(position.getX()+(_x-lastX), position.getY()+(_y-lastY));
        this.pointToMove.get(i).setLocation( this.linkToMove.get(i).getLocalPosition(position) );
        this.linkToMove.get(i).redefineVertex();
      }
    }

    this.lastX = _x;
    this.lastY = _y;

    currentAssemblyGroup.load();
    try360forAssemblies();
}

</t>
<t tx="leo.20191210204217.2">LinkInterface.prototype.mouseMove = function(_x, _y){
  hoverPoint = getPointByPosition(_x, _y);

  if (hoverPoint==null) {
      hoverLink = getLinkByPosition(_x, _y);
  } else {
      hoverLink = null;
  }
}

</t>
<t tx="leo.20191210204217.20">MoveInterface.prototype.mouseDownAndUp = function(_x, _y){

    //find ScienceBox Approaximation
    if(isScienceBoxLinkOn &amp;&amp; this.activeLink!=null){
      var pointPair = findPointPair(this.activeLink, _x, _y);

      if(pointPair!=null){
        var _length = pointPair[0].distance(pointPair[1].getX(), pointPair[1].getY());
        var _newLength = (_length%SCIENCEBOX_SNAP&gt;SCIENCEBOX_SNAP/2)? _length-(_length%SCIENCEBOX_SNAP)+SCIENCEBOX_SNAP : _length-(_length%SCIENCEBOX_SNAP);
        setLengthToLink(this.activeLink, pointPair[0], pointPair[1], _newLength);

        currentAssemblyGroup.removeSegmentSelected();
      }
    }else if(this.activeLink!=null){
      // for move panel's length change
      selectedPointPair = findPointPair(this.activeLink, _x, _y);
      selectedLink = this.activeLink;
      selectedPointTg = null;

    }

    if(this.activePoint!=null){
      selectedPointTg = this.activePoint;
      selectedPoint = currentAssembly.getBelongedLink(this.activePoint).getGlobalPosition(this.activePoint);
      selectedPointPair = null;
      selectedLink = null;
      currentAssemblyGroup.removeSegmentSelected();
    }

    this.activePoint = null;
    this.activeLink = null;

    getPointInfoToMovePanel();

    currentAssemblyGroup.load();
    try360forAssemblies();
}

</t>
<t tx="leo.20191210204217.21">MoveInterface.prototype.mouseMoveAndUp = function(_x, _y){

    if(this.activePoint!=null){
      hoverPoint = getPointByPosition(_x, _y, this.pointToMove);
      if(hoverPoint !=null){
        currentAssembly.appendCoaxialConstraint( currentAssembly.getBelongedLink(this.activePoint), this.activePoint, currentAssembly.getBelongedLink(hoverPoint), hoverPoint);
      }
      else{
        selectedPointTg = this.activePoint;
        selectedPoint = currentAssembly.getBelongedLink(this.activePoint).getGlobalPosition(this.activePoint);
      }
      selectedPointPair = null;
      selectedLink = null;

    }

    this.activePoint = null;
    this.activeLink = null;

    getPointInfoToMovePanel();

    currentAssemblyGroup.load();
    try360forAssemblies();
}


//--------------------
// Remove Class
//--------------------
</t>
<t tx="leo.20191210204217.22">function RemoveInterface(){
}

</t>
<t tx="leo.20191210204217.23">RemoveInterface.prototype.mouseMove = function(_x, _y){
    hoverActuator = getActuatorByPosition(_x, _y);
    if(hoverActuator==null){
      hoverPoint = getPointByPosition(_x, _y);
      if(hoverPoint==null){
        hoverLink = getLinkByPosition(_x, _y);
      }else{
        hoverLink=null;
      }
    }else{
      hoverLink=null;
      hoverPoint=null;
    }

}

</t>
<t tx="leo.20191210204217.24">RemoveInterface.prototype.mouseDown = function(_x, _y){
    var removedPointList = new ArrayList();

    if(hoverActuator!=null){
      currentAssembly.removeActuator(hoverActuator);
      hoverActuator = null;

    }else if(hoverPoint!=null){
      removedPointList.add(hoverPoint);
      if(!(currentAssembly.getBelongedLink(hoverPoint) instanceof Space)){
        if(currentAssembly.getBelongedLink(hoverPoint).getPointList().length()&lt;=2
            || currentAssembly.getBelongedLink(hoverPoint).isSlider){
          hoverLink = currentAssembly.getBelongedLink(hoverPoint);
        }
        else{
          currentAssembly.getBelongedLink(hoverPoint).removePoint(hoverPoint);
          currentAssemblyGroup.load();
          //loadElements(currentAssembly);
        }
      }
      else{
        currentSpace.removePoint(hoverPoint);
        currentAssemblyGroup.load();
        //loadElements(currentAssembly);
      }


      hoverPoint = null;
    }

    if(hoverLink!=null &amp;&amp; hoverLink!=currentSpace){
      removedPointList.addAll(hoverLink.getPointList());
      currentAssembly.removeElement(hoverLink);
      hoverLink = null;
      //currentAssemblyGroup.load();
    }

    for(var rmpti in removedPointList.array){
      var rmpt = removedPointList.get(rmpti);
      currentAssembly.removePointInConstraint(rmpt);
      currentAssemblyGroup.load();
      //loadElements(currentAssembly);

      //remove marker
      for(var i=0; i&lt;currentAssemblyGroup.trajectoryList.length(); i++){
        if(currentAssemblyGroup.trajectoryList.get(i).getPoint() == rmpt) {
          currentAssemblyGroup.trajectoryList.remove(currentAssemblyGroup.trajectoryList.get(i));
          currentAssemblyGroup.load();
        }
      }
      
      //remove load
      for(var i=0; i&lt;currentAssemblyGroup.loadList.length(); i++){
        if(currentAssemblyGroup.loadList.get(i).getPoint() == rmpt) {
          currentAssemblyGroup.loadList.remove(currentAssemblyGroup.loadList.get(i));
          currentAssemblyGroup.load();
        }
      }
    }
    currentAssemblyGroup.load();
    //loadActuators(currentAssembly);
    updateMotorList();
    updateMotorInfo();

    try360forAssemblies();


}

RemoveInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){}
RemoveInterface.prototype.mouseDownAndMove = function(_x, _y){}
RemoveInterface.prototype.mouseDownAndUp = function(_x, _y){}
RemoveInterface.prototype.mouseMoveAndUp = function(_x, _y){}



</t>
<t tx="leo.20191210204217.25">function OptInterface(){
  currentAssemblyGroup.optimizedPath = new Trajectory();
  this.ind = -1;
  this.targetTrj = [];
  this.Lambda;

  this.total_iter;
  this.accumTime;
  this.msg;
  //this.SAMPLE_SIZE = 32;
}
OptInterface.SAMPLE_SIZE = 16;

OptInterface.prototype.mouseMove = function(_x, _y){}
OptInterface.prototype.mouseDown = function(_x, _y){}
</t>
<t tx="leo.20191210204217.26">OptInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){
    currentAssemblyGroup.optimizedPath.flush();
    var p = new Point2D(_x, _y);
    currentAssemblyGroup.optimizedPath.getTrajectory().add(p);
    currentAssemblyGroup.load();
    //try360forAssemblies();
}
</t>
<t tx="leo.20191210204217.27">OptInterface.prototype.mouseDownAndMove = function(_x, _y){
  var p = new Point2D(_x, _y);
  currentAssemblyGroup.optimizedPath.getTrajectory().add(p);
  currentAssemblyGroup.load();
  try360forAssemblies();
  checkBaseTrj(true);
}
OptInterface.prototype.mouseDownAndUp = function(_x, _y){}
</t>
<t tx="leo.20191210204217.28">OptInterface.prototype.mouseMoveAndUp = function(_x, _y){
    /*
  if(currentAssemblyGroup.getTrajectory().length()&gt;0){
    //this.ind = currentAssemblyGroup.getTrajectory().length() - 1;
    this.Lambda = 5;
    this.targetTrj = resample(currentAssemblyGroup.optimizedPath.getTrajectory(), OptInterface.SAMPLE_SIZE);

    this.total_iter = 0;
    this.accumTime = 0;
    //alert("Path Optimization Will be start.\nClick anywhere to stop while optimizing.")
    //showSnackBar("궤적 최적화를 시작합니다.\n아무 곳이나 클릭하면 종료됩니다.", "Path Optimization Will be start.\nClick anywhere to stop while optimizing.")
  }
  currentAssemblyGroup.load();

  try360forAssemblies();
  */
}


/*
Slider Interface
*/

</t>
<t tx="leo.20191210204217.29">function SliderInterface(){
    this.targetLink;
    this.tempSc;
}
</t>
<t tx="leo.20191210204217.3">LinkInterface.prototype.mouseDown = function(_x, _y){
    if ( hoverPoint==null &amp;&amp; hoverLink==null ) { // new space
      var newPt = new Point2D(_x, _y);
      currentSpace.addGlobalPoint(newPt);

      this.associatedPoint = newPt;
      this.associatedLink  = currentSpace;
    }
    else{ // start from existing point
      if( hoverPoint != null) {
        this.associatedLink  = currentAssembly.getBelongedLink(hoverPoint);
        this.associatedPoint = hoverPoint;
      }
      else if( hoverLink != null){
        this.activeLink = hoverLink;
      }
    }
    currentAssemblyGroup.load();
    //try360forAssemblies();
}

</t>
<t tx="leo.20191210204217.30">SliderInterface.prototype.mouseMove = function(_x, _y){
    this.targetLink = getLinkByPosition(_x, _y);
    hoverLink = this.targetLink;
}
</t>
<t tx="leo.20191210204217.31">SliderInterface.prototype.mouseDown = function(_x, _y){
    if (this.targetLink!=null) {
      this.tempSc = findSliderConstraint(this.targetLink, _x, _y);
    }
}
</t>
<t tx="leo.20191210204217.32">SliderInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){
}
</t>
<t tx="leo.20191210204217.33">SliderInterface.prototype.mouseDownAndMove = function(_x, _y){
}
</t>
<t tx="leo.20191210204217.34">SliderInterface.prototype.mouseDownAndUp = function(_x, _y){
    if (this.tempSc!=null) {
      var pts = this.tempSc.getPoints();
      pts = [ this.tempSc.getLink(this.tempSc.BASE).getGlobalPosition(pts[0]),
              this.tempSc.getLink(this.tempSc.BASE).getGlobalPosition(pts[1]) ];

      var t = MMath.getNearestTfromALine(new Point2D(_x, _y), pts[0], pts[1]);
      t = Math.max(0, Math.min(1, t));

      var tempLink = new Link( pts[0].getX()*(1-t)+pts[1].getX()*t, pts[0].getY()*(1-t)+pts[1].getY()*t );

      // making the default slider link be a square //
      //tempLink.addLocalPoint(new Point2D(+30, -30));
      //tempLink.addLocalPoint(new Point2D(-30, -30));
      //tempLink.addLocalPoint(new Point2D(+30, +30));
      //tempLink.addLocalPoint(new Point2D(-30, +30));

      tempLink.setSlider( this.tempSc );
      tempLink.addLocalPoint(new Point2D(+50, 0));
      tempLink.addLocalPoint(new Point2D(-50, 0));

      this.tempSc.setLink(this.tempSc.TARGET, tempLink);
      tempLink.setAngle(this.tempSc.getLink(this.tempSc.BASE).getAngle()+this.tempSc.getAngle());

      currentAssembly.addElement(tempLink);
      currentAssembly.addConstraint(this.tempSc);
      currentAssemblyGroup.load();
    }
}
</t>
<t tx="leo.20191210204217.35">SliderInterface.prototype.mouseMoveAndUp = function(_x, _y){
}


// For load Interface : @ywJeong

//--------------------
// AddLoad Class
//--------------------
</t>
<t tx="leo.20191210204217.36">function AddLoadInterface(){
  this.activePoint = null;
}

</t>
<t tx="leo.20191210204217.37">AddLoadInterface.prototype.mouseMove = function(_x, _y){
  hoverPoint = getPointByPosition(_x, _y);
}
</t>
<t tx="leo.20191210204217.38">AddLoadInterface.prototype.mouseDown = function(_x, _y){
  this.activePoint = hoverPoint;

  if(this.activePoint!=null){
      var duplicateCheck = false;
      for(var i=0; i&lt;currentAssemblyGroup.loadList.length(); i++){
        if(currentAssemblyGroup.loadList.get(i).getPoint() == this.activePoint) {
          duplicateCheck=true;
        }
      }
      if(!duplicateCheck){
        currentAssemblyGroup.newLoad(this.activePoint);
        currentAssemblyGroup.load();
      }
      this.activePoint=null;
    }

  try360forAssemblies();
}
AddLoadInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){}
AddLoadInterface.prototype.mouseDownAndMove = function(_x, _y){}
AddLoadInterface.prototype.mouseDownAndUp = function(_x, _y){}
AddLoadInterface.prototype.mouseMoveAndUp = function(_x, _y){}

//--------------------
// EditLoad Class
//--------------------
var loadIndex;
</t>
<t tx="leo.20191210204217.39">function EditLoadInterface(){

}

</t>
<t tx="leo.20191210204217.4">LinkInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){
  if (this.associatedPoint!=null) {
    this.activeLink = new Link(this.associatedLink.getGlobalPosition(this.associatedPoint));
    currentAssembly.addElement(this.activeLink);
    currentAssembly.appendCoaxialConstraint(this.activeLink, this.activeLink.getPointList().get(0), this.associatedLink, this.associatedPoint);
  }
  if (this.activeLink!=null) {
    this.activePoint = new Point2D(_x, _y);
    this.activeLink.addGlobalPoint(this.activePoint);
  }
  currentAssemblyGroup.load();
  //try360forAssemblies();
}

</t>
<t tx="leo.20191210204217.40">EditLoadInterface.prototype.mouseMove = function(_x, _y){
  hoverPoint = getPointByPosition(_x, _y);
}
EditLoadInterface.prototype.mouseDown = function(_x, _y){}
EditLoadInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){}
EditLoadInterface.prototype.mouseDownAndMove = function(_x, _y){}
</t>
<t tx="leo.20191210204217.41">EditLoadInterface.prototype.mouseDownAndUp = function(_x, _y){
  this.activePoint = hoverPoint;
  var loadX;
  var loadY;
  if(this.activePoint!=null){
    for(var i=0; i&lt;currentAssemblyGroup.loadList.length(); i++){
      if(currentAssemblyGroup.loadList.get(i).getPoint() == this.activePoint) {
        loadX = currentAssemblyGroup.loadList.get(i).getLoadX();
        loadY = currentAssemblyGroup.loadList.get(i).getLoadY();
        loadIndex = i;
      }
    }
    this.activePoint=null;
  }
  getLoadInfoToLoadPanel(loadX, loadY);
}
EditLoadInterface.prototype.mouseMoveAndUp = function(_x, _y){}

//--------------------
// RemoveLoad Class
//--------------------
</t>
<t tx="leo.20191210204217.42">function RemoveLoadInterface(){
  this.activePoint = null;
}

</t>
<t tx="leo.20191210204217.43">RemoveLoadInterface.prototype.mouseMove = function(_x, _y){
  hoverPoint = getPointByPosition(_x, _y);
}
</t>
<t tx="leo.20191210204217.44">RemoveLoadInterface.prototype.mouseDown = function(_x, _y){
  this.activePoint = hoverPoint;

  if(this.activePoint!=null){
      for(var i=0; i&lt;currentAssemblyGroup.loadList.length(); i++){
        if(currentAssemblyGroup.loadList.get(i).getPoint() == this.activePoint) {
          currentAssemblyGroup.loadList.remove(currentAssemblyGroup.loadList.get(i));
          currentAssemblyGroup.load();
        }
      }
      this.activePoint=null;
    }
  try360forAssemblies();
}
RemoveLoadInterface.prototype.mouseDownAndMoveFirst = function(_x, _y){}
RemoveLoadInterface.prototype.mouseDownAndMove = function(_x, _y){}
RemoveLoadInterface.prototype.mouseDownAndUp = function(_x, _y){}
RemoveLoadInterface.prototype.mouseMoveAndUp = function(_x, _y){}


//--------------------
// Common Functions
//--------------------


</t>
<t tx="leo.20191210204217.45">function getPointByPosition(_x, _y, _ignorePointList){
	var arg_num = arguments.length;
	var returnValue;

  DISTANCE_SNAP = (!isTouchScreen)? 24 : 64;

  switch(arg_num){
    case 2:
      return getPointByPosition(_x, _y, new ArrayList());
      break;

    case 3:
      if(_ignorePointList instanceof ArrayList){ // _ignorePointList
        for(var ei in currentAssembly.getAllElement().array){
          var l = currentAssembly.getAllElement().get(ei);
          if(l instanceof Link){
            for(var pi in l.getPointList().array){
              var p = l.getPointList().get(pi);

              var ifContains = false;
              for(var tpi in _ignorePointList.array){
                var tp = _ignorePointList.get(tpi);

                if(tp==p) ifContains = true;

              }
              // for avoid slider length
              if(l.isSlider){
                  if(pi!=0){
                      ifContains = true;
                  }
              }

              if(!ifContains &amp;&amp; l.getGlobalPosition(p).distance(_x, _y) &lt; DISTANCE_SNAP){
                return p;
              }
            }
          }
        }
      }
      else{ // ignorePoint
        var list = new ArrayList();

        if(_ignorePointList!=null){
          list.add(_ignorePointList);
        }

        return getPointByPosition(_x, _y, list);

      }
      break;

  }
}


</t>
<t tx="leo.20191210204217.46">function getLinkByPosition(_x, _y) {
  for (var ei in currentAssembly.getAllElement().array) {
    var e = currentAssembly.getAllElement().get(ei);
    if (!(e instanceof Space) &amp;&amp; e instanceof Link) {
      var l = e;

      var vertex = l.getGlobalRoundedVertex(0);
      var p = [];
      for (var i=0; i&lt;vertex.length; i+=2) {
        //p.addPoint((int)vertex[i+0], (int)vertex[i+1]);
        p.push( new Point2D(vertex[i+0], vertex[i+1]));
      }
      if (isPointInPoly(p, new Point2D(_x, _y))) {

        return l;
      }
    }
  }
  return null;
}

</t>
<t tx="leo.20191210204217.47">function getAllLinkByPosition(_x, _y) {
  var returnValue = [];

  for (var ei in currentAssembly.getAllElement().array) {
    var e = currentAssembly.getAllElement().get(ei);
    if (!(e instanceof Space) &amp;&amp; e instanceof Link) {
      var l = e;

      var vertex = l.getGlobalRoundedVertex(0);
      var p = [];
      for (var i=0; i&lt;vertex.length; i+=2) {
        //p.addPoint((int)vertex[i+0], (int)vertex[i+1]);
        p.push( new Point2D(vertex[i+0], vertex[i+1]));
      }
      if (isPointInPoly(p, new Point2D(_x, _y))) {
        returnValue.push(l);
      }
    }
  }
  return returnValue;
}

</t>
<t tx="leo.20191210204217.48">function getActuatorByPosition(_x, _y) {

  for (var ai in currentAssembly.getAllActuator().array) {
    var a = currentAssembly.getAllActuator().get(ai);

    if (a instanceof JointActuator) {
      var p = a.getOriginPoint();
      if (currentAssembly.getBelongedLink(p).getGlobalPosition(p).distance(_x, _y) &lt; DISTANCE_SNAP) {
        return a;
      }
    }
  }
  return null;
}


</t>
<t tx="leo.20191210204217.49">function isPointInPoly(poly, pt){
    for(var c = false, i = -1, l = poly.length, j = l - 1; ++i &lt; l; j = i)
        ((poly[i].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[j].y) || (poly[j].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[i].y))
        &amp;&amp; (pt.x &lt; (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)
        &amp;&amp; (c = !c);
    return c;
}

/*
function getLinkContainingPoints(_x1, _y1, _x2, _y2){
    var returnLink;
    var links = getAllLinkByPosition(_x1, _y1);

    var foundPointsNumber = new Array(2);

    for(var li in links){
      var _link = links[li];

      for(var pi in _link.getPointList().array){
        var _point = _link.getPointList().get(pi);

        if( _link.getGlobalPosition(_point).distance(_x1, _y1) &lt; 1 ){
          foundPointsNumber[0] = pi;
        }
        else if( _link.getGlobalPosition(_point).distance(_x2, _y2) &lt; 1 ){
          foundPointsNumber[1] = pi;
        }
      }
      if(foundPointsNumber[0] != null &amp;&amp; foundPointsNumber[1] != null){
        returnLink = _link;
        firstPointID = foundPointsNumber[0];
        secondPointID = foundPointsNumber[1];
      }

      foundPointsNumber[0] = null;
      foundPointsNumber[1] = null;

    }

    return returnLink;
}
*/


</t>
<t tx="leo.20191210204217.5">LinkInterface.prototype.mouseDownAndMove = function(_x, _y){
  if (this.activeLink!=null &amp;&amp; this.activePoint!=null) {
      hoverPoint = getPointByPosition(_x, _y, this.activePoint);
      if(hoverPoint==null){
        this.activePoint.setLocation(this.activeLink.getLocalPosition(new Point2D(_x, _y)));
        this.activeLink.redefineVertex();
      }else{
        var position = currentAssembly.getBelongedLink(hoverPoint).getGlobalPosition(hoverPoint);
        this.activePoint.setLocation( this.activeLink.getLocalPosition(position) );
        this.activeLink.redefineVertex();
      }
    }
    currentAssemblyGroup.load();
    //try360forAssemblies();
}

</t>
<t tx="leo.20191210204217.50">function try360forAssemblies(){
  if(isPlaying) return;
  for(var i=0; i&lt;AssemblyGroupList.length; i++){
    //AssemblyGroupList[i].loadTrajectories();
    //AssemblyGroupList[i].onStart();
    AssemblyGroupList[i].try360();
  }
}


// for change length of link

</t>
<t tx="leo.20191210204217.51">function setLengthToLink(_link, _p1, _p2, _legnth){

  var _tempAngle = Math.atan2(_p2.getY()-_p1.getY(), _p2.getX()-_p1.getX());

  var _newX1 = _p1.getX();
  var _newY1 = _p1.getY();
  var _newX2 = _legnth*Math.cos(_tempAngle) + _newX1;
  var _newY2 = _legnth*Math.sin(_tempAngle) + _newY1;

  _p1.setLocation( new Point2D(_newX1, _newY1) );
  _p2.setLocation( new Point2D(_newX2, _newY2) );
  _link.redefineVertex();

  currentAssemblyGroup.onStart();
  currentAssemblyGroup.calculateAssembly();

}

</t>
<t tx="leo.20191210204217.52">function findPointPair(_link, _x, _y){

  if (_link!=null &amp;&amp; _link.getPointList().length()&gt;1) {
    var localPos = _link.getLocalPosition(new Point2D(_x, _y));

    // to find the nearest Point pair //
    var p1r = new Point2D();
    var p2r = new Point2D();
    var shortestDist = Number.POSITIVE_INFINITY;
    for (var i=0; i&lt;_link.getPointList().length()-1; i++) {
      for (var j=i+1; j&lt;_link.getPointList().length(); j++) {
        var p1 = _link.getPointList().get(i);
        var p2 = _link.getPointList().get(j);
        var dist = MMath.distToSegment(localPos, p1, p2);

        if (dist&lt;shortestDist) {
          p1r = p1;
          p2r = p2;
          shortestDist = dist;
        }
      }
    }

    return [p1r, p2r];
    //console.log(_link + ", " + p1r + ", " + p2r);
  }
  return null;

}

</t>
<t tx="leo.20191210204217.53">function findSliderConstraint(_link, _x, _y){

  if (_link!=null &amp;&amp; _link.getPointList().length()&gt;1) {
    var localPos = _link.getLocalPosition(new Point2D(_x, _y));

    // to find the nearest Point pair //
    var p1r = new Point2D();
    var p2r = new Point2D();
    var shortestDist = Number.POSITIVE_INFINITY;
    for (var i=0; i&lt;_link.getPointList().length()-1; i++) {
      for (var j=i+1; j&lt;_link.getPointList().length(); j++) {
        var p1 = _link.getPointList().get(i);
        var p2 = _link.getPointList().get(j);
        var dist = MMath.distToSegment(localPos, p1, p2);

        if (dist&lt;shortestDist) {
          p1r = p1;
          p2r = p2;
          shortestDist = dist;
        }
      }
    }

    return new SliderConstraint(_link, null, p1r, p2r);
  }
  return null;

}
</t>
<t tx="leo.20191210204217.6">LinkInterface.prototype.mouseDownAndUp = function(_x, _y){
    if(this.activeLink!=null){
      this.activePoint = new Point2D(_x, _y);
      this.activeLink.addGlobalPoint(this.activePoint);
    }
    currentAssemblyGroup.load();
    try360forAssemblies();

    this.associatedPoint = null;
    this.associatedLink  = null;
    this.activePoint     = null;
    this.activeLink      = null;
}

</t>
<t tx="leo.20191210204217.7">LinkInterface.prototype.mouseMoveAndUp = function(_x, _y){
    if (this.activeLink!=null &amp;&amp; this.activePoint!=null) {
        hoverPoint = getPointByPosition(_x, _y, this.activePoint);

      if(hoverPoint!=null){
        currentAssembly.appendCoaxialConstraint(currentAssembly.getBelongedLink(hoverPoint), hoverPoint, this.activeLink, this.activePoint);
      }
    }
    currentAssemblyGroup.load();

    // for canceling
    if(getPointByPosition(_x, _y) == this.associatedPoint){
      var removedPointList = new ArrayList();

      //console.log(this.associatedPoint);
      //console.log(this.activeLink);
      removedPointList.addAll(this.activeLink.getPointList());
      currentAssembly.removeElement(this.activeLink);
      currentAssemblyGroup.load();

      for(var rmpti in removedPointList.array){
        var rmpt = removedPointList.get(rmpti);
        currentAssembly.removePointInConstraint(rmpt);
        currentAssemblyGroup.load();
      }
    }
    try360forAssemblies();

    this.associatedPoint = null;
    this.associatedLink  = null;
    this.activePoint     = null;
    this.activeLink      = null;
}


//--------------------
// JA Class
//--------------------
</t>
<t tx="leo.20191210204217.8">function JAInterface(){

}

</t>
<t tx="leo.20191210204217.9">JAInterface.prototype.mouseMove = function(_x, _y){
  var tempActuator = getActuatorByPosition(_x, _y);

  if(tempActuator != null){
    //console.log(tempActuator.getName());
  }

  hoverPoint = getPointByPosition(_x, _y);
}
</t>
<t tx="leo.20191210204227.1">@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204232.1">function checkHistory(){
	if(isPlaying) return;

	tempInfo = getMsketchInfo();

	if( tempInfo != historyInfo[ historyInfo.length - 1 - historyAddress ] ){
		historyInfo.splice( historyInfo.length - 1 - historyAddress + 1 , historyAddress );
		historyAddress = 0;
	}

	if(historyInfo[historyInfo.length-1] != tempInfo &amp;&amp; historyAddress==0){
		historyInfo.push(tempInfo);
	}

	if(historyInfo.length &gt; MAX_HISTORY){
		historyInfo.splice(0, 1);
	}

}

</t>
<t tx="leo.20191210204232.2">function undo(){
	if(isPlaying) return;
	if(historyInfo.length - 2 - historyAddress &lt; 0) return;

	var _tempIndex = findCurrentAssemblyNum();

	historyAddress++;
	loadMsketchInfo( historyInfo[historyInfo.length - 1 - historyAddress] , false);

	try360forAssemblies();

	selectAssembly(_tempIndex);
}

</t>
<t tx="leo.20191210204232.3">function redo(){
	if(isPlaying) return;
	if(historyAddress&lt;1) return;

	var _tempIndex = findCurrentAssemblyNum();

	historyAddress--;
	loadMsketchInfo( historyInfo[historyInfo.length - 1 - historyAddress] , false);

	try360forAssemblies();

	selectAssembly(_tempIndex);
}
</t>
<t tx="leo.20191210204255.1"></t>
<t tx="leo.20191210204301.1">//----------------------------------------------------------------------------------------------------
// ** FIleI/O Functions
//----------------------------------------------------------------------------------------------------

@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204310.1">function makeNewFile(){
	addAssemblyGroup(0);
	currentAssemblyGroup.init();
	selectAssembly(AssemblyGroupList.length-1);

	for(var i=AssemblyGroupList.length-2; i&gt;=0; i--){
		removeAssemblyGroup(i);
	}
	updateMotorList();
}

// Load File
</t>
<t tx="leo.20191210204310.2">function loadMsketchInfo(_data, _isNew){

	var _dataJSON = JSON.parse(_data);

	//check header
	if(_dataJSON.app != "EDISON" || _dataJSON.type != "Assembly"){
		showMessage("Wrong File");
		return null;
	}else{
		makeNewFile();
	}

	// generate planes
	for(var i=0; i&lt;_dataJSON.sketches.length; i++){
		loadMsketchInfoForPlane(_dataJSON.sketches[i], _isNew)
	}
	try360forAssemblies();
	updateMotorList();
	removeAssemblyGroup(0);
}

</t>
<t tx="leo.20191210204310.3">function importPlaneInfo(_data, _isNew){
	var _dataJSON = JSON.parse(_data);

	//check header
	if(_dataJSON.app != "EDISON" || _dataJSON.type != "Sketch"){
		showMessage("Wrong File");
		return null;
	}

	loadMsketchInfoForPlane(_dataJSON.sketch, _isNew)

	try360forAssemblies();
	updateMotorList();
	selectAssembly(AssemblyGroupList.length-1);
}

// Load File
</t>
<t tx="leo.20191210204310.4">function loadMsketchInfoForPlane(_sketch, _isNew){
	var nameTag = (_isNew)? "*":""; // to avoid duplicate of element names

	addAssemblyGroup(0);
	currentAssemblyGroup.init();

	//Space
	for(var j=0; j&lt;_sketch.anchor.points.length; j++){
		var _points = _sketch.anchor.points[j];
		currentSpace.addGlobalPoint( new Point2D( parseFloat(_points.x)/SCALE_TRANS, parseFloat(_points.y)/SCALE_TRANS ) );
	}

	//Links
	for(var j=0; j&lt;_sketch.links.length; j++){
		var _link = _sketch.links[j];
		var _linkElement = new Link(_link.name + nameTag, parseFloat(_link.points[0].x)/SCALE_TRANS, parseFloat(_link.points[0].y)/SCALE_TRANS )
		_linkElement.stack = _link.points[0].z/Link3D.HEIGHT; //yw_edited
		currentAssembly.addElement(_linkElement);

		currentAssemblyGroup.load();

		for(var k=1; k&lt;_link.points.length; k++){
			_linkElement.addGlobalPoint( parseFloat(_link.points[k].x)/SCALE_TRANS, parseFloat(_link.points[k].y)/SCALE_TRANS )
		}
	}

	// CC
	for(var j=0; j&lt;_sketch.constraints.length; j++){
		var _cc = _sketch.constraints[j];
		var _baseName = _cc.points[0].targetLink;
		var _baseIndex = parseInt(_cc.points[0].targetIndex);
		var _targetName =  _cc.points[1].targetLink;
		var _targetIndex = parseInt(_cc.points[1].targetIndex);

		var _base, _target;

		if(_baseName!="Anchor"){
			_baseName = _baseName+nameTag;
		}
		if(_targetName!="Anchor"){
			_targetName = _targetName+nameTag;
		}

		_base = currentAssembly.getLinkByName(_baseName);
		_target = currentAssembly.getLinkByName(_targetName);

		var _ccElement = new CoaxialConstraint(_cc.name + nameTag , _base, _base.getPointList().get(_baseIndex), _target, _target.getPointList().get(_targetIndex));;

		// Apendding CC
		for(var k=2; k&lt;_cc.points.length; k++){
			var _targetName =  _cc.points[k].targetLink;
			var _targetIndex = parseInt(_cc.points[k].targetIndex);
			var _target;

			if(_targetName!="Anchor"){
				_targetName = _targetName+nameTag;
			}

			_target = currentAssembly.getLinkByName(_targetName);

			_ccElement.addPoint(_target, _target.getPointList().get(_targetIndex));
		}

		currentAssembly.addConstraint(_ccElement);
	}

	// Slider
	for(var j=0; j&lt;_sketch.sliders.length; j++){
		var _sc = _sketch.sliders[j];
		var _baseName = _sc.baseLink +nameTag;
		var _targetName = _sc.targetLink +nameTag;

		var _base = currentAssembly.getLinkByName(_baseName);
		var _target = currentAssembly.getLinkByName(_targetName);

		var _scElement = new SliderConstraint(_base, null, _base.getPointList().get(_sc.baseIndex1), _base.getPointList().get(_sc.baseIndex2) );

		_target.setSlider(_scElement);
		_scElement.setLink(_scElement.TARGET, _target);

		_target.addLocalPoint(new Point2D(+50, 0));
		_target.addLocalPoint(new Point2D(-50, 0));
		_target.setAngle(_scElement.getLink(_scElement.BASE).getAngle()+_scElement.getAngle());

		currentAssembly.addConstraint(_scElement);
		_target.redefineVertex();
	}

	// JA
	for(var j=0; j&lt;_sketch.motors.length; j++){
		var _motor = _sketch.motors[j];

		var _ccName 	= _motor.targetConstraint + nameTag;
		var _baseName 	= _motor.targetLink1;
		var _targetName = _motor.targetLink2;

		var _base, _target, _cc;

		if(_baseName!="Anchor"){
			_baseName = _baseName+nameTag;
		}
		if(_targetName!="Anchor"){
			_targetName = _targetName+nameTag;
		}

		_base = currentAssembly.getLinkByName(_baseName);
		_target = currentAssembly.getLinkByName(_targetName);
		_cc = currentAssembly.getConstraintByName(_ccName);


		var _motorElement = new JointActuator(_motor.name, _cc, _base, _target);
		currentAssembly.addActuator(_motorElement);


		_motorElement.isServo = (_motor.type=="SERVO")? true:false;
		_motorElement.setPhase( Math.radians(parseFloat(_motor.phase)) );
		_motorElement.setSpeedMultiply( parseFloat(_motor.speed)/100 );
		_motorElement.setReverse( (parseInt(_motor.direction)==1)? true : false );
		_motorElement.setStartAngle( Math.radians(parseFloat(_motor.range.split("-")[0])) );
		_motorElement.setEndAngle( Math.radians(parseFloat(_motor.range.split("-")[1])) );
		if(_motorElement.isServo){
			//a.setInitAngle( a.startAngle );
			_motorElement.setValue( _motorElement.startAngle + _motorElement.phaseShift );
		}
		else{
			//a.setInitAngle( a.phaseShift );
			_motorElement.setValue( _motorElement.phaseShift );
		}
	}

	// Markers
	for(var j=0; j&lt;_sketch.markers.length; j++){
		var _marker = _sketch.markers[j];

		var _linkName 	= _marker.targetLink;
		var _index 		= _marker.targetIndex;

		if(_linkName!="Anchor"){
			_linkName = _linkName+nameTag;
		}

		_link = currentAssembly.getLinkByName(_linkName);

		currentAssemblyGroup.newTrajectory(_link.getPointList().get(_index));
	}

	// Plane Info
	var _planeData = {};
	_planeData.tx = parseFloat(_sketch.plane.translation.x)/SCALE_TRANS;
	_planeData.ty = parseFloat(_sketch.plane.translation.y)/SCALE_TRANS;
	_planeData.tz = parseFloat(_sketch.plane.translation.z)/SCALE_TRANS;
	_planeData.rx = Math.radians( parseFloat(_sketch.plane.rotation.x) );
	_planeData.ry = Math.radians( parseFloat(_sketch.plane.rotation.y) );
	_planeData.rz = Math.radians( parseFloat(_sketch.plane.rotation.z) );
	currentAssemblyGroup.setPositionData(_planeData);

	currentAssemblyGroup.load();
}


// Get Info
</t>
<t tx="leo.20191210204310.5">function getMsketchInfo(){
	var tempObject = {};

	tempObject.app = "EDISON";
	tempObject.type = "Assembly";
	tempObject.fileVersion = "2.0";
	tempObject.description = "Saved From M.Sketch v3.0";

	//part setting (yw_edited)
	tempObject.thickness = msketchSettings.linkThickness;
	tempObject.holeSize = msketchSettings.holeDiameter;
	tempObject.linkWidth = msketchSettings.linkWidth;

	saveAssemblyPositions();

	// Start to Save File
	tempObject.sketches = [];

	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		var tempAssembly = {};

		// Plane Info
		planeData = AssemblyGroupList[i].getPositionData();
		tempAssembly.plane = {};
		tempAssembly.plane.name = "Plane"+i;
		tempAssembly.plane.translation = {
										x: (planeData.tx*SCALE_TRANS).toFixed(2),
										y: (planeData.ty*SCALE_TRANS).toFixed(2),
										z: (planeData.tz*SCALE_TRANS).toFixed(2)
										}

		tempAssembly.plane.rotation = {
										x: Math.degrees(planeData.rx).toFixed(2),
										y: Math.degrees(planeData.ry).toFixed(2),
										z: Math.degrees(planeData.rz).toFixed(2)
		}

		// Element Info
		var elementList = AssemblyGroupList[i].assembly.getAllElement();

		tempAssembly.anchor = {};
		tempAssembly.links = [];

		for(var ei in elementList.array){
			var e = elementList.get(ei);
			if(e instanceof Space){
				tempAssembly.anchor.points = [];

				for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);
					tempAssembly.anchor.points.push({
						x: (_p.getX()*SCALE_TRANS).toFixed(2),
						y: (_p.getY()*SCALE_TRANS).toFixed(2),
						z: "0.00"
					});
				}
			}

			else if(e instanceof Link){
				var tempLink = {};
				tempLink.name = e.name;
				tempLink.points = [];

				for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);

					if(!e.isSlider || (e.isSlider &amp;&amp; pi == 0))
					tempLink.points.push({
						x: (e.getGlobalPosition(_p).getX()*SCALE_TRANS).toFixed(2),
						y: (e.getGlobalPosition(_p).getY()*SCALE_TRANS).toFixed(2),
						z: (e.stack * Link3D.HEIGHT).toFixed(2) //yw_edited
					});
				}

				tempAssembly.links.push(tempLink);
			}
		}

		// CC Info
		var constList = AssemblyGroupList[i].assembly.getAllConstraint();

		tempAssembly.constraints = [];
		tempAssembly.sliders = [];

		for(var ei in constList.array){
			var e = constList.get(ei);
			if(e instanceof CoaxialConstraint){
				var tempCC = {};
				tempCC.name = e.name;
				tempCC.points = [];

				for(var j = 0; j&lt;e.link.length(); j++){
					var _link = e.link.get(j);
					var _index;

					for(var k=0; k&lt;_link.getPointList().length(); k++){
		 				if(e.point.get(j).getX() == _link.getPointList().get(k).getX() &amp;&amp; e.point.get(j).getY() == _link.getPointList().get(k).getY()){
		 					_index = k;
		 				}
		 			}
					tempCC.points.push({targetLink: _link.name, targetIndex: _index})
				}

				tempAssembly.constraints.push(tempCC)
			}
			else if(e instanceof SliderConstraint){
				var tempSC = {};
				tempSC.name = e.name;
				tempSC.baseLink = e.link.get(e.BASE).name;
				tempSC.targetLink = e.link.get(e.TARGET).name;
				tempSC.baseIndex1 = 0;
				tempSC.baseIndex2 = 1;

				for(var k=0; k&lt;e.link.get(e.BASE).getPointList().length(); k++){
					if(e.getPoints()[0].getX() == e.link.get(e.BASE).getPointList().get(k).getX() &amp;&amp; e.getPoints()[0].getY() == e.link.get(e.BASE).getPointList().get(k).getY()){
						tempSC.baseIndex1 = k;
					}
					if(e.getPoints()[1].getX() == e.link.get(e.BASE).getPointList().get(k).getX() &amp;&amp; e.getPoints()[1].getY() == e.link.get(e.BASE).getPointList().get(k).getY()){
						tempSC.baseIndex2 = k;
					}
				}

				tempAssembly.sliders.push(tempSC);

			}
		}

		// Markers
		var _trajectoryList = AssemblyGroupList[i].getTrajectory();

		tempAssembly.markers = [];

		for(var ti in _trajectoryList.array){
			var t = _trajectoryList.get(ti);

			if(t instanceof Trajectory){
				_link = t.link;

				for(var k=0; k&lt;_link.getPointList().length(); k++){
	 				if(t.point.getX() == _link.getPointList().get(k).getX() &amp;&amp; t.point.getY() == _link.getPointList().get(k).getY()){
	 					_index = k;
	 				}
	 			}

				var tempTrj = {targetLink: _link.name, targetIndex: _index};
			}

			tempAssembly.markers.push(tempTrj);
		}

		// JA
		var _actuatorList = AssemblyGroupList[i].assembly.getAllActuator();

		tempAssembly.motors = [];

		for(var ai in _actuatorList.array){
			var a = _actuatorList.get(ai);
			if(a instanceof JointActuator){
				tempAssembly.motors.push({
					name: a.name,
					targetConstraint: a.coaxialConstraint.name,
					targetLink1: a.angularConstraint.link.get(0).name,
					targetLink2: a.angularConstraint.link.get(1).name,
					type: (a.isServo)? "SERVO":"DC",
					direction: (a.revDir)? 1:0,
					speed: Math.round(a.speedMultiply*100),
					phase: Math.round(Math.degrees(a.phaseShift)),
					range: Math.round(Math.degrees(a.startAngle)) +"-"+ Math.round(Math.degrees(a.endAngle))
				});
			}
		}

		tempObject.sketches.push( tempAssembly );
	}

	restoreAssemblyPositions();

	var tempText = JSON.stringify(tempObject, null, '\t');
	return tempText;

}

</t>
<t tx="leo.20191210204310.6">function getMsketchInfoForPlane(){
	var tempData = JSON.parse( getMsketchInfo() );

	tempData.type = "Sketch";

	tempData.sketch = tempData.sketches[findCurrentAssemblyNum()];
	delete tempData.sketches;

	var tempText = JSON.stringify(tempData, null, '\t');
	return tempText;
}


</t>
<t tx="leo.20191210204310.7">function saveAssemblyPositions(){
	// save positions
	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		AssemblyGroupList[i].savePositions();
		AssemblyGroupList[i].onStart();
		AssemblyGroupList[i].flushTrajectories();

		var _actuatorList = AssemblyGroupList[i].assembly.getAllActuator();
		for(var ai in _actuatorList.array){
			var a = _actuatorList.get(ai);
			if(a instanceof JointActuator){
				a.setValue(0);
			}
		}
		AssemblyGroupList[i].calculateAssembly();
	}
}

</t>
<t tx="leo.20191210204310.8">function restoreAssemblyPositions(){
	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		AssemblyGroupList[i].onEnd();
		AssemblyGroupList[i].restorePositions();
		AssemblyGroupList[i].initTrajectories();
		AssemblyGroupList[i].calculateAssembly();
	}
}

</t>
<t tx="leo.20191210204310.9">function saveAsText(filename, data){
    var blob = new Blob([data], {type: 'text/plane;charset=utf-8'});
    if(window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else{
        var elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;
        document.body.appendChild(elem)
        elem.click();
        document.body.removeChild(elem);
    }
}
</t>
<t tx="leo.20191210204330.1">//----------------------------------------------------------------------------------------------------
// ** Export to PDF
//----------------------------------------------------------------------------------------------------
@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204336.1">function exportDrawing(){
	if(isPlaying)	interfaceSelect(TOOL_RUN);

  	var doc = new jsPDF('landscape');

	var elementList = currentAssembly.getAllElement();
	if(elementList==null) return;

	doc.setFontSize(14);
	doc.text(12, 15, 'm.Sketch Drawing');
	doc.setFontSize(10);
	doc.text(12, 20, 'Assembled View');

	doc.setFontSize(8);
	doc.text(297-33.5, 210-15, 'EDISON DESIGN');
	doc.setFontSize(8);
	doc.text(297-42, 210-12, 'http://design.edison.re.kr');


	//get dimension
	var minX = 9999;
	var maxX = -9999;
	var minY = 9999;
	var maxY = -9999;
	var _scale = 10;


	var HOLE_RADIUS = 2;

	//========================= MAIN DRAWING ==========================
	for(var ei in elementList.array){
		var e = elementList.get(ei);

		if(e instanceof Link &amp;&amp; !(e instanceof Space)){

			for(var pi in e.getPointList().array){
	 			var _p = e.getPointList().get(pi);
	 			var _xM = e.getGlobalPosition(_p).getX()*SCALE_TRANS;
	 			var _yM = -e.getGlobalPosition(_p).getY()*SCALE_TRANS;

	 			if(minX&gt;_xM) minX = _xM;
	 			if(maxX&lt;_xM) maxX = _xM;
	 			if(minY&gt;_yM) minY = _yM;
	 			if(maxY&lt;_yM) maxY = _yM;
	 		}
	 	}
	}
	//
	var _x = (-minX)+20;
 	var _y = (-minY)+40;

	for(var ei in elementList.array){
	 	var e = elementList.get(ei);

	 	if(e instanceof Link &amp;&amp; !(e instanceof Space)){
	 		var v = e.getGlobalRoundedVertex(0);
	 		if(v!=null){
	 			v.push(v[0]);
	 			v.push(v[1]);

		 		for(var i=3; i&lt;v.length; i+=2){
		 			doc.line( v[i-3]*SCALE_TRANS+_x, -v[i-2]*SCALE_TRANS+_y, v[i-1]*SCALE_TRANS+_x, -v[i]*SCALE_TRANS+_y );
		 		}

		 		for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);
		 			var _xM = _x+e.getGlobalPosition(_p).getX()*SCALE_TRANS;
		 			var _yM = _y-e.getGlobalPosition(_p).getY()*SCALE_TRANS;

		 			doc.circle(_xM, _yM, HOLE_RADIUS);


		 		}

	 		}
	 	}
    }
    var number = 1;
    for(var ei in elementList.array){  //numbering
		var e = elementList.get(ei);

        if(e instanceof Link &amp;&amp; !(e instanceof Space)){

	 		var v = new Array();

		 	for(var pi in e.getPointList().array){
	 			var _p = e.getPointList().get(pi);
	 			v.push(e.getGlobalPosition(_p).getX());
	 			v.push(e.getGlobalPosition(_p).getY());
             }

        var sum_x = 0;
        var sum_y = 0;

        var i = 0;
        while(i&lt;v.length){
            sum_x += (_x+v[i]*SCALE_TRANS);
            i += 2;
        }
        var j = 1;
        while(j&lt;v.length){
            sum_y += (_y-v[j]*SCALE_TRANS);
            j += 2;
        }

        var _text = number.toString();
        var avr_x = sum_x/(v.length/2);
        var avr_y = sum_y/(v.length/2);
        doc.text(avr_x-1, avr_y+1, _text);
        number++;

        }
	}

	//========================= SCHEMATIC DRAWING ==========================
	doc.addPage();

	doc.setFontSize(14);
	doc.text(12, 15, 'm.Sketch Drawing');
	doc.setFontSize(10);
	doc.text(12, 20, 'Schematic Drawing');

	doc.setFontSize(8);
	doc.text(297-33.5, 210-15, 'EDISON DESIGN');
	doc.setFontSize(8);
	doc.text(297-42, 210-12, 'http://design.edison.re.kr');

	// for removing duplicated vertexs
	var pointList = new Array();

	for(var ei in elementList.array){
	 	var e = elementList.get(ei);

	 	if(e instanceof Link &amp;&amp; !(e instanceof Space)){

	 		var v = new Array();

	 		for(var pi in e.getPointList().array){
	 			var _p = e.getPointList().get(pi);
	 			v.push(e.getGlobalPosition(_p).getX());
	 			v.push(e.getGlobalPosition(_p).getY());

	 			_tX = _x+v[v.length-2]*SCALE_TRANS;
	 			_tY = _y-v[v.length-1]*SCALE_TRANS;

	 			doc.circle(_tX, _tY, 0.5);
	 			doc.setFontSize(10);

	 			var _text = "(" + (v[v.length-2]*SCALE_TRANS).toFixed(2) + " , " + (v[v.length-1]*SCALE_TRANS).toFixed(2) + ")"; //revised
	 			if(pointList.indexOf(_text)==-1){
	 				pointList.push(_text);
	 				doc.text(_tX+1, _tY-1, _text);   //text insert part
	 			}

	 		}

		 	if(v.length&gt;=6){
		 		v.push(v[0]);
	 			v.push(v[1]);
		 		for(var i=3; i&lt;v.length; i+=2){
		 			doc.line( v[i-3]*SCALE_TRANS+_x, -v[i-2]*SCALE_TRANS+_y, v[i-1]*SCALE_TRANS+_x, -v[i]*SCALE_TRANS+_y );
		 		}
		 	}else{
	 			doc.line( v[0]*SCALE_TRANS+_x, -v[1]*SCALE_TRANS+_y, v[2]*SCALE_TRANS+_x, -v[3]*SCALE_TRANS+_y );
		 	}

	 	}
	}

	//========================= PART DRAWING ==========================
	//rotated assembly
	doc.addPage();

	var offsetX = 0;
	var offsetY = 0;
	var maxOffsetX = 0;

    var number_2 = 1;//

	for(var ei in elementList.array){
	 	var e = elementList.get(ei);

	 	if(e instanceof Link &amp;&amp; !(e instanceof Space)){
	 		var v = e.getGlobalRoundedVertex(1);

	 		if(v!=null){
	 			var minLX = 9999;
				var maxLX = -9999;
				var minLY = 9999;
				var maxLY = -9999;

	 			for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);
		 			var _xM = e.getGlobalPositionRotated(_p).getX()*SCALE_TRANS;
		 			var _yM = -e.getGlobalPositionRotated(_p).getY()*SCALE_TRANS;

		 			if(minLX&gt;_xM) minLX = _xM;
		 			if(maxLX&lt;_xM) maxLX = _xM;
		 			if(minLY&gt;_yM) minLY = _yM;
		 			if(maxLY&lt;_yM) maxLY = _yM;

		 			//console.log (minLX +","+ maxLX+","+minLY+","+maxLY);
		 		}

		 		var _w = Math.abs(maxLX - minLX);
		 		var _h = Math.abs(maxLY - minLY);

		 		if(offsetY+_h &gt; 210-40){
		 			offsetX += maxOffsetX + 20;
		 			offsetY = 0;

		 			maxOffsetX=0;
		 		}
		 		if(offsetX+_w &gt; 297-40){
		 			doc.addPage();
		 			offsetX = 0;
		 			offsetY = 0;

		 			maxOffsetX=0;
		 		}

		 		var _x = (-minLX)+20 + offsetX;
			 	var _y = (-minLY)+20 + offsetY;

	 			v.push(v[0]);
	 			v.push(v[1]);

		 		for(var i=3; i&lt;v.length; i+=2){
		 			doc.line( _x+v[i-3]*SCALE_TRANS, _y-v[i-2]*SCALE_TRANS, _x+v[i-1]*SCALE_TRANS, _y-v[i]*SCALE_TRANS );
		 		}

                var w = new Array(); //

		 		for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);
		 			var _xM = _x+e.getGlobalPositionRotated(_p).getX()*SCALE_TRANS;
		 			var _yM = _y-e.getGlobalPositionRotated(_p).getY()*SCALE_TRANS;

                    w.push(_xM);
                    w.push(_yM);

		 			doc.circle(_xM, _yM, HOLE_RADIUS);
		 		}

                var sum_x = 0; //
                var sum_y = 0; //

                var i = 0;
                while(i&lt;w.length){
                    sum_x += w[i];
                    i += 2;
                }
                var j = 1;
                while(j&lt;w.length){
                    sum_y += w[j];
                    j += 2;
                }

                var _text = number_2.toString();
                var avr_x = sum_x/(w.length/2);
                var avr_y = sum_y/(w.length/2);
                doc.text(offsetX+8, avr_y+1, _text);
                number_2 ++;

		 		offsetY += (_h+12);
		 		if(maxOffsetX&lt;_w) maxOffsetX = _w;

	 		}
	 	}
	}



    /*
    var number_2 = 1;
    for(var ei in elementList.array){  //numbering
		var e = elementList.get(ei);

        if(e instanceof Link &amp;&amp; !(e instanceof Space)){

	 		var v = new Array();

		 	for(var pi in e.getPointList().array){
	 			var _p = e.getPointList().get(pi);
	 			v.push(e.getGlobalPositionRotated(_p).getX());
	 			v.push(e.getGlobalPositionRotated(_p).getY());
            }


        var sum_x = 0;
        var sum_y = 0;

        var i = 0;
        while(i&lt;v.length){
            sum_x += (_x+v[i]*SCALE_TRANS);
            i += 2;
        }
        var j = 1;
        while(j&lt;v.length){
            sum_y += (_y-v[j]*SCALE_TRANS);
            j += 2;
        }

        var _text = number_2.toString();
        var avr_x = sum_x/(v.length/2);
        var avr_y = sum_y/(v.length/2);
        doc.text(avr_x+1, avr_y-1, _text);
        number_2 ++;

        }
	}
    */

	var agent = navigator.userAgent.toLowerCase();
	var name = navigator.appName;
	//console.log(name);

	if ( name == "Microsoft Internet Explorer" || agent.search("trident") &gt; -1 || agent.search("edge/") &gt; -1){
		doc.save('mSketchDrawing.pdf');
	}
	else {
		//doc.output('dataurlnewwindow');
		var blob = doc.output('blob');
		window.open(URL.createObjectURL(blob));
	}

	//if (agent.indexOf("chrome") != -1){
	//}
}





//----------------------------------------------------------------------------------------------------
// ** Export to PDF (Silhouette Cutting)
//----------------------------------------------------------------------------------------------------
</t>
<t tx="leo.20191210204336.2">function exportCameoDrawing(){
	if(isPlaying)	interfaceSelect(TOOL_RUN);

  	var doc = new jsPDF('l', 'mm', [300, 300]);

	var elementList = currentAssembly.getAllElement();
	if(elementList==null) return;

	doc.setFontSize(8);

	//get dimension
	var minX = 9999;
	var maxX = -9999;
	var minY = 9999;
	var maxY = -9999;
	var _scale = 10;


	var HOLE_RADIUS = 2.5;

	// Cutting dimension (263.05mm)
	var sideLength = 263.05;
	doc.circle(5, 5, 0.1);
	doc.circle(5+sideLength, 5+sideLength, 0.1);


	//========================= PART DRAWING ==========================
	//rotated assembly

	var offsetX = 0;
	var offsetY = 0;
	var maxOffsetX = 0;

    var number_2 = 1;//

	for(var ei in elementList.array){
	 	var e = elementList.get(ei);

		if(e instanceof Space){
			if(e.getPointList().length()&gt;1){
				var v = e.getGlobalRoundedVertex(0);

				if(v!=null){
		 			var minLX = 9999;
					var maxLX = -9999;
					var minLY = 9999;
					var maxLY = -9999;
				}
				for(var pi in e.getPointList().array){
					var _p = e.getPointList().get(pi);
					var _xM = e.getGlobalPosition(_p).getX()*SCALE_TRANS;
					var _yM = -e.getGlobalPosition(_p).getY()*SCALE_TRANS;

					if(minLX&gt;_xM) minLX = _xM;
					if(maxLX&lt;_xM) maxLX = _xM;
					if(minLY&gt;_yM) minLY = _yM;
					if(maxLY&lt;_yM) maxLY = _yM;

					//console.log (minLX +","+ maxLX+","+minLY+","+maxLY);
				}

				var _w = Math.abs(maxLX - minLX);
				var _h = Math.abs(maxLY - minLY);

				if(offsetY+_h &gt; 280-40){
					offsetX += maxOffsetX + 20;
					offsetY = 0;

					maxOffsetX=0;
				}
				if(offsetX+_w &gt; 280-40){
					doc.addPage();
					offsetX = 0;
					offsetY = 0;

					maxOffsetX=0;
				}

				var _x = (-minLX)+15 + offsetX;
				var _y = (-minLY)+15 + offsetY;

				var spaceOffset = 10;

				//doc.roundedRect(_x+minLX, _y+minLY, (_w+spaceOffset*2)*2, _h+spaceOffset*2, 3, 3);

				var _rx = _x+minLX;
				var _ry = _y+minLY;
				var _rw = (_w+spaceOffset*2)*2;
				var _rh = (_h+spaceOffset*2);

				doc.line(_rx + 0.5, _ry, _rx + _rw - 1, _ry);
				doc.line(_rx, _ry, _rx, _ry + _rh);
				doc.line(_rx + _rw, _ry, _rx + _rw, _ry + _rh);
				doc.line(_rx + 0.5, _ry + _rh, _rx + _rw - 1, _ry + _rh);

				// folding Line
				var foldingLineX = _x + minLX + _w + spaceOffset*2;
				var foldingLineOffset = 15;
				for(var fi = 5; fi&lt; _h+spaceOffset*2-foldingLineOffset/2; fi+=foldingLineOffset){
					doc.line(foldingLineX, _y+minLY+fi, foldingLineX, _y+minLY+fi+foldingLineOffset/2);
				}


				/*
				v.push(v[0]);
				v.push(v[1]);

				for(var i=3; i&lt;v.length; i+=2){
					doc.line( _x+v[i-3]*SCALE_TRANS, _y-v[i-2]*SCALE_TRANS, _x+v[i-1]*SCALE_TRANS, _y-v[i]*SCALE_TRANS );
				}*/

				var w = new Array(); //

				for(var pi in e.getPointList().array){
					var _p = e.getPointList().get(pi);
					var _xM = _x+e.getGlobalPosition(_p).getX()*SCALE_TRANS;
					var _yM = _y-e.getGlobalPosition(_p).getY()*SCALE_TRANS;

					w.push(_xM);
					w.push(_yM);



					//doc.circle(_xM+spaceOffset, _yM+spaceOffset, HOLE_RADIUS);
					//doc.circle( foldingLineX+(foldingLineX-(_xM+spaceOffset)), _yM+spaceOffset, HOLE_RADIUS);

					doc.lines([[0, 0, 0, -HOLE_RADIUS, HOLE_RADIUS, -HOLE_RADIUS],[0, 0, HOLE_RADIUS, 0, HOLE_RADIUS, HOLE_RADIUS]], _xM+spaceOffset-HOLE_RADIUS, _yM+spaceOffset-0.25, [1, 1]);
					doc.lines([[0, 0, 0, HOLE_RADIUS, HOLE_RADIUS, HOLE_RADIUS],[0, 0, HOLE_RADIUS, 0, HOLE_RADIUS, -HOLE_RADIUS]],_xM+spaceOffset-HOLE_RADIUS, _yM+spaceOffset+0.25, [1, 1]);

					doc.lines([[0, 0, 0, -HOLE_RADIUS, HOLE_RADIUS, -HOLE_RADIUS],[0, 0, HOLE_RADIUS, 0, HOLE_RADIUS, HOLE_RADIUS]], foldingLineX+(foldingLineX-(_xM+spaceOffset))-HOLE_RADIUS, _yM+spaceOffset-0.25, [1, 1]);
					doc.lines([[0, 0, 0, HOLE_RADIUS, HOLE_RADIUS, HOLE_RADIUS],[0, 0, HOLE_RADIUS, 0, HOLE_RADIUS, -HOLE_RADIUS]], foldingLineX+(foldingLineX-(_xM+spaceOffset))-HOLE_RADIUS, _yM+spaceOffset+0.25, [1, 1]);
				}

				var sum_x = 0; //
				var sum_y = 0; //

				var i = 0;
				while(i&lt;w.length){
					sum_x += w[i];
					i += 2;
				}
				var j = 1;
				while(j&lt;w.length){
					sum_y += w[j];
					j += 2;
				}

				var _text = number_2.toString();
				var avr_x = sum_x/(w.length/2);
				var avr_y = sum_y/(w.length/2);
				//doc.text(offsetX+8, avr_y+1, _text);
				number_2 ++;

				offsetY += (_h+30);
				if(maxOffsetX&lt;_w) maxOffsetX = _w*2;
			}

		}

	 	if(e instanceof Link &amp;&amp; !(e instanceof Space)){
	 		var v = e.getGlobalRoundedVertex(1);

	 		if(v!=null){
	 			var minLX = 9999;
				var maxLX = -9999;
				var minLY = 9999;
				var maxLY = -9999;

	 			for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);
		 			var _xM = e.getGlobalPositionRotated(_p).getX()*SCALE_TRANS;
		 			var _yM = -e.getGlobalPositionRotated(_p).getY()*SCALE_TRANS;

		 			if(minLX&gt;_xM) minLX = _xM;
		 			if(maxLX&lt;_xM) maxLX = _xM;
		 			if(minLY&gt;_yM) minLY = _yM;
		 			if(maxLY&lt;_yM) maxLY = _yM;

		 			//console.log (minLX +","+ maxLX+","+minLY+","+maxLY);
		 		}

		 		var _w = Math.abs(maxLX - minLX);
		 		var _h = Math.abs(maxLY - minLY);

		 		if(offsetY+_h &gt; 280-40){
		 			offsetX += maxOffsetX + 20;
		 			offsetY = 0;

		 			maxOffsetX=0;
		 		}
		 		if(offsetX+_w &gt; 280-40){
		 			doc.addPage();
		 			offsetX = 0;
		 			offsetY = 0;

		 			maxOffsetX=0;
		 		}

		 		var _x = (-minLX)+20 + offsetX;
			 	var _y = (-minLY)+20 + offsetY;

	 			v.push(v[0]);
	 			v.push(v[1]);

		 		for(var i=3; i&lt;v.length; i+=2){

					var _x1 = _x+v[i-3]*SCALE_TRANS;
					var _y1 = _y-v[i-2]*SCALE_TRANS;
					var _x2 = _x+v[i-1]*SCALE_TRANS;
					var _y2 = _y-v[i]*SCALE_TRANS;

					var _p1 = new Point2D(_x1, _y1);
					var _p2 = new Point2D(_x2, _y2);

					//console.log(i + "," + Math.round(v.length/8) + "," + MMath.dist(_p1, _p2));

					if( (Math.round(i/2)%Math.round(v.length/16)==0) &amp;&amp; MMath.dist(_p1, _p2) &lt; 5 ){
						console.log(i);
					}else{
						doc.line(_x1, _y1, _x2, _y2);
					}

		 		}

                var w = new Array(); //

		 		for(var pi in e.getPointList().array){
		 			var _p = e.getPointList().get(pi);
		 			var _xM = _x+e.getGlobalPositionRotated(_p).getX()*SCALE_TRANS;
		 			var _yM = _y-e.getGlobalPositionRotated(_p).getY()*SCALE_TRANS;

                    w.push(_xM);
                    w.push(_yM);

		 			//doc.circle(_xM, _yM, HOLE_RADIUS);
					//upper arc and bottom arc
					doc.lines([[0, 0, 0, -HOLE_RADIUS, HOLE_RADIUS, -HOLE_RADIUS],[0, 0, HOLE_RADIUS, 0, HOLE_RADIUS, HOLE_RADIUS]], _xM-HOLE_RADIUS, _yM-0.25, [1, 1]);
					doc.lines([[0, 0, 0, HOLE_RADIUS, HOLE_RADIUS, HOLE_RADIUS],[0, 0, HOLE_RADIUS, 0, HOLE_RADIUS, -HOLE_RADIUS]], _xM-HOLE_RADIUS, _yM+0.25, [1, 1]);

		 		}

                var sum_x = 0; //
                var sum_y = 0; //

                var i = 0;
                while(i&lt;w.length){
                    sum_x += w[i];
                    i += 2;
                }
                var j = 1;
                while(j&lt;w.length){
                    sum_y += w[j];
                    j += 2;
                }

                var _text = number_2.toString();
                var avr_x = sum_x/(w.length/2);
                var avr_y = sum_y/(w.length/2);
                //doc.text(offsetX+8, avr_y+1, _text);
                number_2 ++;

		 		offsetY += (_h+12);
		 		if(maxOffsetX&lt;_w) maxOffsetX = _w;

	 		}
	 	}
	}


	var agent = navigator.userAgent.toLowerCase();
	var name = navigator.appName;
	//console.log(name);
	/*
	if ( name == "Microsoft Internet Explorer" || agent.search("trident") &gt; -1 || agent.search("edge/") &gt; -1){
		doc.save('mSketchDrawing.pdf');
	}
	else {
		doc.output('dataurlnewwindow');
	}
	*/
	var _date = new Date();
	//console.log(saveDate.getFullYear()+""+(saveDate.getMonth()+1)+""+saveDate.getDate()+"_"+saveDate.getHours()+""+saveDate.getMinutes()+""+saveDate.getSeconds());
	var _dateName = _date.getFullYear()+""+(_date.getMonth()+1)+""+_date.getDate()+"_"+_date.getHours()+""+_date.getMinutes()+""+_date.getSeconds();
	doc.save('mSketch_UIST_Drawing_'+ _dateName +'.pdf');

	//if (agent.indexOf("chrome") != -1){
	//}
}
</t>
<t tx="leo.20191210204346.1">// =============================================================================
// 									Variables
// =============================================================================

var MSKETCH_VERSION = "Ver. 3.0.171025";
var MANUAL_URL = "manual/";

var systemLang 			= "ko_KR";
var isTouchScreen		= false;
var historyInfo 		= [];
var historyAddress		= 0;
var MAX_HISTORY 		= 20;

//* ===== Assembly Unit =====
var AssemblyGroupList 	= new Array();
var currentAssembly;
var currentAssemblyGroup;
var currentMousePlane;

//* ===== Actuating variables =====
var angleRelations 		= new Object();
var speedRelations 		= new Object();
var reverseRotation 	= new Object();
var globalAngle 		= 0; 				//* Motors will be rotate with this in "actuate()";
var motorSpeed 			= Math.radians( 180 );
var stopAngle 			= 0;
var prevMillis, currentMillis;

var isPlaying 			= false;
var isControlable 		= false;
var prevControlable 	= false;
var MAX_TRAJECTORY_SIZE = 1800; // 3*x

//* ===== Interface variables =====
var isScienceBoxSanpOn 	= false;
var isScienceBoxLinkOn 	= false;
var isAnalysisOn 		= false;
var loadPlaneData 		= false;
var SCIENCEBOX_SNAP 	= 127; // 0.5inch
var SCALE_TRANS 		= 0.1;

var isPathOptimizing	= false;

//* ===== Visualization variables =====
var DISABLED_PLANE_OPA 	= 0.3;
var CAM_FACTOR 			= 1.2;

var EDISON_COLOR 		= 0x6a3fc4;
var EDISON_LIGHT_COLOR	= 0x833ac7; // NOT USED
var NORMAL_COLOR 		= 0x27262c;
var WHITE_COLOR 		= 0xffffff;
var ERROR_COLOR 		= 0xFC315A;
var ACTUATOR_COLOR 		= 0x27262c;
var BACKGROUND_COLOR 	= 0xffffff;
var TRAJECTORY_COLOR	= 0x6a3fc4;
var HOVER_COLOR			= 0x6a3fc4;
var SELECTED_COLOR		= 0x4bb7ba;
var OPT_PATH_COLOR 		= 0xFC315A;

// for Settings
var msketchSettings = {};
viewMode = 0;

msketchSettings.showGrid = true;
msketchSettings.showText = true;
msketchSettings.showPlane = true;

msketchSettings.gridGap = 10;
msketchSettings.planeSize = 100;

msketchSettings.linkWidth = 12.7; // 0.5inch
msketchSettings.holeDiameter = 4;
msketchSettings.linkThickness = 5;

msketchSettings.MaxHistorySize = 20;


// =============================================================================
// 									Main Script
// =============================================================================
initSettings();

init();					//* initializing Three.js environment
initMechCalc();			//* initializing Pre-defined Mechanism
animate();				//* calls every frame

interfaceSelect(-1);	// init interface


// =============================================================================
// 									Animate (Loop)
// =============================================================================


@others
@language javascript
@tabwidth -4
</t>
<t tx="leo.20191210204410.1">function animate(){

	requestAnimationFrame( animate );

	if (isPlaying)	{
		actuate();		//* Calls actuate in every frame
		for(var i=0; i&lt;AssemblyGroupList.length; i++){
			AssemblyGroupList[i].recordTrajectories();	// Trajectory recording function in [assembly/AssemblyGroup.js]
		}
	}

	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		AssemblyGroupList[i].update();
	}

	if(currentInterface instanceof OptInterface &amp;&amp; isPathOptimizing){
		optimize();
	}

	render();
}


</t>
<t tx="leo.20191210204410.2">function render(){
	controls.update();
	transformControl.update();
	renderer.render(scene, camera);
}

// =============================================================================
// 									Actuation
// =============================================================================
</t>
<t tx="leo.20191210204410.3">function actuate(){

	currentMillis = new Date().getTime();
	if(isAnalysisOn)	globalAngle += 0.02
	else				globalAngle = (motorSpeed*(currentMillis-prevMillis)/1000);

	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		AssemblyGroupList[i].actuateAll(globalAngle);
	}

	getAnalysisInfo();
}


// =============================================================================
// 							Mechanical Parts Predefine
// =============================================================================

</t>
<t tx="leo.20191210204410.4">function initMechCalc(){
	addAssemblyGroup(0);
	currentAssemblyGroup.init();
	selectAssembly(0);

	//jansen();				//** ======================= Example Jansen Mechanism Case in [common/MechExample.js]
	//currentAssemblyGroup.init();
}


// =============================================================================
// 							Assembly Organizing Functions
// =============================================================================

</t>
<t tx="leo.20191210204410.5">function addAssemblyGroup(_z){
	AssemblyGroupList.push( new AssemblyGroup() );
	currentAssemblyGroup = AssemblyGroupList[AssemblyGroupList.length-1];
	currentAssembly = currentAssemblyGroup.getAssembly();
	currentSpace = currentAssemblyGroup.getSpace();
	currentTrajectory = currentAssemblyGroup.getTrajectory();
	currentMousePlane = currentAssemblyGroup.getMousePlane();
	currentAssemblyGroup.setPlane(_z);
}

</t>
<t tx="leo.20191210204410.6">function removeAssemblyGroup(_index){
	if(AssemblyGroupList.length&gt;1){
		AssemblyGroupList[_index].remove();
		AssemblyGroupList.splice(_index, 1);
		if(_index&gt;0){
			selectAssembly(_index-1);
		}
		else{
			selectAssembly(_index);
		}
	}
	else{
		showMessage("Cannot remove: Last plane.")
	}
	updateMotorList();
}

</t>
<t tx="leo.20191210204410.7">function selectAssembly(_k){
	if(_k &gt; AssemblyGroupList.length-1) _k = AssemblyGroupList.length-1;

	currentAssemblyGroup = AssemblyGroupList[_k];
	currentAssembly = currentAssemblyGroup.getAssembly();
	currentSpace = currentAssemblyGroup.getSpace();
	currentTrajectory = currentAssemblyGroup.getTrajectory();
	currentMousePlane = currentAssemblyGroup.getMousePlane();

	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		if(AssemblyGroupList[i] == currentAssemblyGroup){
			AssemblyGroupList[i].showPlane();
		}
		else{
			AssemblyGroupList[i].hidePlane();
		}
	}

	if(toolState==TOOL_PTRANS || toolState==TOOL_PROT){
		transformControl.attach( currentAssemblyGroup.group );
	}

}

</t>
<t tx="leo.20191210204410.8">function findCurrentAssemblyNum(){
	for(var i=0; i&lt;AssemblyGroupList.length; i++){
		if(AssemblyGroupList[i] == currentAssemblyGroup){
			return i;
		}
	}
	return -1;
}
</t>
<t tx="leo.20191210220017.1"></t>
<t tx="leo.20191210220042.1">  &lt;script src="./public/js/jquery.min.js"&gt;&lt;/script&gt;
  必須放在 head 命名節點, 若放在 included_javascript 會產生移動機構節點的錯誤.</t>
</tnodes>
</leo_file>
